// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../../../node_modules/@babel/runtime/helpers/esm/typeof.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _typeof;

function _typeof2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return typeof obj;
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof2(obj);
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    exports.default = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    exports.default = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}
},{}],"../../../node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"../../../node_modules/@deck.gl/core/dist/esm/utils/globals.js":[function(require,module,exports) {
var process = require("process");
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.document = exports.global = exports.window = exports.isBrowser = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || true;
exports.isBrowser = isBrowser;
var window_ = typeof window !== 'undefined' ? window : global;
exports.window = window_;
var global_ = typeof global !== 'undefined' ? global : window;
exports.global = global_;
var document_ = typeof document !== 'undefined' ? document : {};
exports.document = document_;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/probe.gl/dist/esm/env/is-electron.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && (0, _typeof2.default)(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && (0, _typeof2.default)(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  var realUserAgent = (typeof navigator === "undefined" ? "undefined" : (0, _typeof2.default)(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  var userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/probe.gl/dist/esm/env/is-browser.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBrowser() {
  var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && String(process) === '[object process]' && !true;
  return !isNode || (0, _isElectron.default)();
}

function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","./is-electron":"../../../node_modules/probe.gl/dist/esm/env/is-electron.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/probe.gl/dist/esm/env/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.console = exports.process = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && process
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var process_ = globals.process || {};
exports.process = process_;
var console_ = console;
exports.console = console_;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/probe.gl/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals.console;
  }
});
exports.isBrowser = exports.VERSION = void 0;

var _isBrowser = _interopRequireDefault(require("../env/is-browser"));

var _globals = require("../env/globals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
var isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;
},{"../env/is-browser":"../../../node_modules/probe.gl/dist/esm/env/is-browser.js","../env/globals":"../../../node_modules/probe.gl/dist/esm/env/globals.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/probe.gl/dist/esm/init.js":[function(require,module,exports) {

"use strict";

var _globals = require("./utils/globals");

_globals.global.probe = {};
},{"./utils/globals":"../../../node_modules/probe.gl/dist/esm/utils/globals.js"}],"../../../node_modules/probe.gl/dist/esm/env/get-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobile = isMobile;
exports.default = getBrowser;

var _globals = require("./globals");

var _isBrowser = _interopRequireDefault(require("./is-browser"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isMobile() {
  return typeof _globals.window.orientation !== 'undefined';
}

function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }

  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }

  var navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  var userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals.window.chrome) {
    return 'Chrome';
  }

  if (_globals.window.safari) {
    return 'Safari';
  }

  if (_globals.window.mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}
},{"./globals":"../../../node_modules/probe.gl/dist/esm/env/globals.js","./is-browser":"../../../node_modules/probe.gl/dist/esm/env/is-browser.js","./is-electron":"../../../node_modules/probe.gl/dist/esm/env/is-electron.js"}],"../../../node_modules/probe.gl/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _classCallCheck;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/createClass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _createClass;

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
},{}],"../../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;

var _globals = require("./globals");

function getHiResTimestamp() {
  var timestamp;

  if (_globals.isBrowser && _globals.window.performance) {
    timestamp = _globals.window.performance.now();
  } else if (_globals.process.hrtime) {
    var timeParts = _globals.process.hrtime();

    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
},{"./globals":"../../../node_modules/probe.gl/dist/esm/utils/globals.js"}],"../../../node_modules/probe.gl/dist/esm/lib/stat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Stat = function () {
  function Stat(name) {
    (0, _classCallCheck2.default)(this, Stat);
    this.name = name;
    this.reset();
  }

  (0, _createClass2.default)(Stat, [{
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this.count += value;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this.count -= value;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this.time += time;
      this.lastTiming = time;
      this.count++;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = (0, _hiResTimestamp.default)();
      this._timerPending = true;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return;
      }

      this.addTime((0, _hiResTimestamp.default)() - this._startTime);
      this._timerPending = false;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.count > 0 ? this.time / this.count : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.count / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.lastTiming = 0;
      this._startTime = 0;
      this._timerPending = false;
    }
  }]);
  return Stat;
}();

exports.default = Stat;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils/hi-res-timestamp":"../../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js"}],"../../../node_modules/probe.gl/dist/esm/lib/stats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _stat = _interopRequireDefault(require("./stat"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id;
    (0, _classCallCheck2.default)(this, Stats);
    this.id = id;
    this.stats = {};
    Object.seal(this);
  }

  (0, _createClass2.default)(Stats, [{
    key: "get",
    value: function get(name) {
      this.stats[name] = this.stats[name] || new _stat.default(name);
      return this.stats[name];
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }]);
  return Stats;
}();

exports.default = Stats;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./stat":"../../../node_modules/probe.gl/dist/esm/lib/stat.js"}],"../../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _arrayWithoutHoles;

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _iterableToArray;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _nonIterableSpread;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _toConsumableArray;

var _arrayWithoutHoles = _interopRequireDefault(require("./arrayWithoutHoles"));

var _iterableToArray = _interopRequireDefault(require("./iterableToArray"));

var _nonIterableSpread = _interopRequireDefault(require("./nonIterableSpread"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) {
  return (0, _arrayWithoutHoles.default)(arr) || (0, _iterableToArray.default)(arr) || (0, _nonIterableSpread.default)();
}
},{"./arrayWithoutHoles":"../../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","./iterableToArray":"../../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","./nonIterableSpread":"../../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"}],"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _defineProperty;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
},{}],"../../../node_modules/probe.gl/dist/esm/utils/local-storage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getStorage(type) {
  try {
    var storage = window[type];
    var x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

var LocalStorage = function () {
  function LocalStorage(id, defaultSettings) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    (0, _classCallCheck2.default)(this, LocalStorage);
    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  (0, _createClass2.default)(LocalStorage, [{
    key: "getConfiguration",
    value: function getConfiguration() {
      return this.config;
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
  }, {
    key: "updateConfiguration",
    value: function updateConfiguration(configuration) {
      Object.assign(this.config, configuration);

      if (this.storage) {
        var serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }

      return this;
    }
  }, {
    key: "_loadConfiguration",
    value: function _loadConfiguration() {
      var configuration = {};

      if (this.storage) {
        var serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }

      Object.assign(this.config, configuration);
      return this;
    }
  }]);
  return LocalStorage;
}();

exports.default = LocalStorage;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js"}],"../../../node_modules/probe.gl/dist/esm/utils/formatters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTime = formatTime;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
exports.formatValue = formatValue;
exports.formatImage = formatImage;

function formatTime(ms) {
  var formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}

function leftPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}

function rightPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}

function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  var imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  var width = image.width * scale;
  var height = image.height * scale;
  var style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
},{}],"../../../node_modules/probe.gl/dist/esm/utils/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addColor = addColor;
exports.COLOR = void 0;

var _globals = require("./globals");

var COLOR = {
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97
};
exports.COLOR = COLOR;

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_globals.isBrowser && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}
},{"./globals":"../../../node_modules/probe.gl/dist/esm/utils/globals.js"}],"../../../node_modules/probe.gl/dist/esm/utils/autobind.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;

function autobind(obj) {
  var predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  var proto = Object.getPrototypeOf(obj);
  var propNames = Object.getOwnPropertyNames(proto);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var key = _step.value;

      if (typeof obj[key] === 'function') {
        if (!predefined.find(function (name) {
          return key === name;
        })) {
          obj[key] = obj[key].bind(obj);
        }
      }
    };

    for (var _iterator = propNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
},{}],"../../../node_modules/probe.gl/dist/esm/lib/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _globals = require("../utils/globals");

var _localStorage = _interopRequireDefault(require("../utils/local-storage"));

var _formatters = require("../utils/formatters");

var _color = require("../utils/color");

var _autobind = require("../utils/autobind");

var _assert2 = _interopRequireDefault(require("../utils/assert"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var originalConsole = {
  debug: _globals.isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: false,
  priority: 0
};

function noop() {}

var cache = {};

function getTableHeader(table) {
  for (var key in table) {
    for (var title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

var Log = function () {
  function Log() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id;

    (0, _classCallCheck2.default)(this, Log);
    this.id = id;
    this.VERSION = _globals.VERSION;
    this._startTs = (0, _hiResTimestamp.default)();
    this._deltaTs = (0, _hiResTimestamp.default)();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new _localStorage.default("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }

  (0, _createClass2.default)(Log, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this._storage.config.enabled;
    }
  }, {
    key: "getPriority",
    value: function getPriority() {
      return this._storage.config.priority;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._storage.config.priority;
    }
  }, {
    key: "getTotal",
    value: function getTotal() {
      return Number(((0, _hiResTimestamp.default)() - this._startTs).toPrecision(10));
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      return Number(((0, _hiResTimestamp.default)() - this._deltaTs).toPrecision(10));
    }
  }, {
    key: "enable",
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._storage.updateConfiguration({
        enabled: enabled
      });

      return this;
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      this._storage.updateConfiguration({
        priority: level
      });

      return this;
    }
  }, {
    key: "assert",
    value: function assert(condition, message) {
      (0, _assert2.default)(condition, message);
    }
  }, {
    key: "warn",
    value: function warn(message) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this._getLogFunction({
        message: message,
        args: args,
        method: originalConsole.warn,
        once: true
      });
    }
  }, {
    key: "error",
    value: function error(message) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this._getLogFunction({
        message: message,
        args: args,
        method: originalConsole.error
      });
    }
  }, {
    key: "deprecated",
    value: function deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "removed",
    value: function removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "probe",
    value: function probe(priority, message) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.log,
        time: true,
        once: true
      });
    }
  }, {
    key: "log",
    value: function log(priority, message) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.debug
      });
    }
  }, {
    key: "info",
    value: function info(priority, message) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
        args[_key5 - 2] = arguments[_key5];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: console.info
      });
    }
  }, {
    key: "once",
    value: function once(priority, message) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
        args[_key6 - 2] = arguments[_key6];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.debug || originalConsole.info,
        once: true
      });
    }
  }, {
    key: "table",
    value: function table(priority, _table, columns) {
      if (_table) {
        var tag = getTableHeader(_table);
        return this._getLogFunction({
          priority: priority,
          message: _table,
          args: columns && [columns],
          tag: tag,
          method: console.table || noop
        });
      }

      return noop;
    }
  }, {
    key: "image",
    value: function image(_ref2) {
      var priority = _ref2.priority,
          _image = _ref2.image,
          _ref2$message = _ref2.message,
          message = _ref2$message === void 0 ? '' : _ref2$message,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? 1 : _ref2$scale;

      if (priority > this.getPriority()) {
        return noop;
      }

      return _globals.isBrowser ? this._logImageInBrowser({
        image: _image,
        message: message,
        scale: scale
      }) : this._logImageInNode({
        image: _image,
        message: message,
        scale: scale
      });
    }
  }, {
    key: "settings",
    value: function settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
  }, {
    key: "get",
    value: function get(setting) {
      return this._storage.config[setting];
    }
  }, {
    key: "set",
    value: function set(setting, value) {
      this._storage.updateConfiguration((0, _defineProperty2.default)({}, setting, value));
    }
  }, {
    key: "_logImageInNode",
    value: function _logImageInNode(_ref3) {
      var image = _ref3.image,
          _ref3$message = _ref3.message,
          message = _ref3$message === void 0 ? '' : _ref3$message,
          _ref3$scale = _ref3.scale,
          scale = _ref3$scale === void 0 ? 1 : _ref3$scale;
      var asciify = null;

      try {
        asciify = module.require('asciify-image');
      } catch (error) {}

      if (asciify) {
        return function () {
          return asciify(image, {
            fit: 'box',
            width: "".concat(Math.round(80 * scale), "%")
          }).then(function (data) {
            return console.log(data);
          });
        };
      }

      return noop;
    }
  }, {
    key: "_logImageInBrowser",
    value: function _logImageInBrowser(_ref4) {
      var image = _ref4.image,
          _ref4$message = _ref4.message,
          message = _ref4$message === void 0 ? '' : _ref4$message,
          _ref4$scale = _ref4.scale,
          scale = _ref4$scale === void 0 ? 1 : _ref4$scale;

      if (typeof image === 'string') {
        var img = new Image();

        img.onload = function () {
          var _console;

          var args = (0, _formatters.formatImage)(img, message, scale);

          (_console = console).log.apply(_console, (0, _toConsumableArray2.default)(args));
        };

        img.src = image;
        return noop;
      }

      var element = image.nodeName || '';

      if (element.toLowerCase() === 'img') {
        var _console2;

        (_console2 = console).log.apply(_console2, (0, _toConsumableArray2.default)((0, _formatters.formatImage)(image, message, scale)));

        return noop;
      }

      if (element.toLowerCase() === 'canvas') {
        var _img = new Image();

        _img.onload = function () {
          var _console3;

          return (_console3 = console).log.apply(_console3, (0, _toConsumableArray2.default)((0, _formatters.formatImage)(_img, message, scale)));
        };

        _img.src = image.toDataURL();
        return noop;
      }

      return noop;
    }
  }, {
    key: "time",
    value: function time(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.time ? console.time : console.info
      });
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.timeEnd ? console.timeEnd : console.info
      });
    }
  }, {
    key: "timeStamp",
    value: function timeStamp(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.timeStamp || noop
      });
    }
  }, {
    key: "group",
    value: function group(priority, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        collapsed: false
      };
      opts = this._normalizeArguments({
        priority: priority,
        message: message,
        opts: opts
      });
      var _opts = opts,
          collapsed = _opts.collapsed;
      return this._getLogFunction({
        priority: priority,
        message: message,
        opts: opts,
        method: (collapsed ? console.groupCollapsed : console.group) || console.info
      });
    }
  }, {
    key: "groupCollapsed",
    value: function groupCollapsed(priority, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.group(priority, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
  }, {
    key: "groupEnd",
    value: function groupEnd(priority) {
      return this._getLogFunction({
        priority: priority,
        message: '',
        method: console.groupEnd || noop
      });
    }
  }, {
    key: "withGroup",
    value: function withGroup(priority, message, func) {
      var opts = this._normalizeArguments({
        priority: priority,
        message: message
      });

      this.group(opts);

      try {
        func();
      } finally {
        this.groupEnd(opts.message);
      }
    }
  }, {
    key: "trace",
    value: function trace() {
      if (console.trace) {
        console.trace();
      }
    }
  }, {
    key: "_shouldLog",
    value: function _shouldLog(priority) {
      priority = this._normalizePriority(priority);
      return priority === 0 || this.isEnabled() && this.getPriority() >= priority;
    }
  }, {
    key: "_getElapsedTime",
    value: function _getElapsedTime() {
      var total = this.getTotal();
      var delta = this.getDelta();
      this._deltaTs = (0, _hiResTimestamp.default)();
      return {
        total: total,
        delta: delta
      };
    }
  }, {
    key: "_getLogFunction",
    value: function _getLogFunction(opts) {
      if (this._shouldLog(opts.priority)) {
        var _opts2 = opts,
            method = _opts2.method;
        opts = this._parseArguments(opts);
        (0, _assert2.default)(method);
        var _opts3 = opts,
            message = _opts3.message;
        var tag = opts.tag || opts.message;

        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = (0, _hiResTimestamp.default)();
          } else {
            return noop;
          }
        }

        message = this._decorateMessage(message, opts);
        return method.bind.apply(method, [console, message].concat((0, _toConsumableArray2.default)(opts.args)));
      }

      return noop;
    }
  }, {
    key: "_parseArguments",
    value: function _parseArguments(options) {
      var normOpts = this._normalizeArguments(options);

      var _this$_getElapsedTime = this._getElapsedTime(),
          delta = _this$_getElapsedTime.delta,
          total = _this$_getElapsedTime.total;

      return Object.assign(options, normOpts, {
        delta: delta,
        total: total
      });
    }
  }, {
    key: "_normalizePriority",
    value: function _normalizePriority(priority) {
      var resolvedPriority;

      switch ((0, _typeof2.default)(priority)) {
        case 'number':
          resolvedPriority = priority;
          break;

        case 'object':
          resolvedPriority = priority.priority || 0;
          break;

        default:
          resolvedPriority = 0;
      }

      (0, _assert2.default)(Number.isFinite(resolvedPriority) && resolvedPriority >= 0);
      return resolvedPriority;
    }
  }, {
    key: "_normalizeArguments",
    value: function _normalizeArguments(_ref5) {
      var priority = _ref5.priority,
          message = _ref5.message,
          _ref5$args = _ref5.args,
          args = _ref5$args === void 0 ? [] : _ref5$args,
          opts = _ref5.opts;
      var newOpts = {
        priority: this._normalizePriority(priority),
        message: message,
        args: args
      };

      switch ((0, _typeof2.default)(priority)) {
        case 'string':
        case 'function':
          if (message !== undefined) {
            args.unshift(message);
          }

          Object.assign(newOpts, {
            message: priority
          });
          break;

        case 'object':
          Object.assign(newOpts, priority);
          break;

        default:
      }

      if (typeof newOpts.message === 'function') {
        newOpts.message = this._shouldLog(newOpts.priority) ? newOpts.message() : '';
      }

      (0, _assert2.default)(typeof newOpts.message === 'string' || (0, _typeof2.default)(newOpts.message) === 'object');
      return Object.assign(newOpts, opts);
    }
  }, {
    key: "_decorateMessage",
    value: function _decorateMessage(message, opts) {
      if (typeof message === 'string') {
        var time = '';

        if (opts.time) {
          var _this$_getElapsedTime2 = this._getElapsedTime(),
              total = _this$_getElapsedTime2.total;

          time = (0, _formatters.leftPad)((0, _formatters.formatTime)(total));
        }

        message = opts.time ? "".concat(this.id, ": ").concat(time, "  ").concat(message) : "".concat(this.id, ": ").concat(message);
        message = (0, _color.addColor)(message, opts.color, opts.background);
      }

      return message;
    }
  }, {
    key: "priority",
    set: function set(newPriority) {
      this._storage.updateConfiguration({
        priority: newPriority
      });

      return this;
    },
    get: function get() {
      return this._storage.config.priority;
    }
  }]);
  return Log;
}();

exports.default = Log;
Log.VERSION = _globals.VERSION;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","@babel/runtime/helpers/esm/toConsumableArray":"../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils/globals":"../../../node_modules/probe.gl/dist/esm/utils/globals.js","../utils/local-storage":"../../../node_modules/probe.gl/dist/esm/utils/local-storage.js","../utils/formatters":"../../../node_modules/probe.gl/dist/esm/utils/formatters.js","../utils/color":"../../../node_modules/probe.gl/dist/esm/utils/color.js","../utils/autobind":"../../../node_modules/probe.gl/dist/esm/utils/autobind.js","../utils/assert":"../../../node_modules/probe.gl/dist/esm/utils/assert.js","../utils/hi-res-timestamp":"../../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js"}],"../../../node_modules/probe.gl/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals2.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function () {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function () {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function () {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function () {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function () {
    return _stats.default;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function () {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function () {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function () {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function () {
    return _formatters.rightPad;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function () {
    return _autobind.autobind;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function () {
    return _localStorage.default;
  }
});
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.default;
  }
});
exports.default = void 0;

require("./init");

var _globals = require("./utils/globals");

var _globals2 = require("./env/globals");

var _isBrowser = _interopRequireWildcard(require("./env/is-browser"));

var _getBrowser = _interopRequireWildcard(require("./env/get-browser"));

var _isElectron = _interopRequireDefault(require("./env/is-electron"));

var _assert = _interopRequireDefault(require("./utils/assert"));

var _stats = _interopRequireDefault(require("./lib/stats"));

var _log = _interopRequireDefault(require("./lib/log"));

var _color = require("./utils/color");

var _formatters = require("./utils/formatters");

var _autobind = require("./utils/autobind");

var _localStorage = _interopRequireDefault(require("./utils/local-storage"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var _default = new _log.default({
  id: 'probe.gl'
});

exports.default = _default;
},{"./init":"../../../node_modules/probe.gl/dist/esm/init.js","./utils/globals":"../../../node_modules/probe.gl/dist/esm/utils/globals.js","./env/globals":"../../../node_modules/probe.gl/dist/esm/env/globals.js","./env/is-browser":"../../../node_modules/probe.gl/dist/esm/env/is-browser.js","./env/get-browser":"../../../node_modules/probe.gl/dist/esm/env/get-browser.js","./env/is-electron":"../../../node_modules/probe.gl/dist/esm/env/is-electron.js","./utils/assert":"../../../node_modules/probe.gl/dist/esm/utils/assert.js","./lib/stats":"../../../node_modules/probe.gl/dist/esm/lib/stats.js","./lib/log":"../../../node_modules/probe.gl/dist/esm/lib/log.js","./utils/color":"../../../node_modules/probe.gl/dist/esm/utils/color.js","./utils/formatters":"../../../node_modules/probe.gl/dist/esm/utils/formatters.js","./utils/autobind":"../../../node_modules/probe.gl/dist/esm/utils/autobind.js","./utils/local-storage":"../../../node_modules/probe.gl/dist/esm/utils/local-storage.js","./utils/hi-res-timestamp":"../../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _probe = require("probe.gl");

var _default = new _probe.Log({
  id: 'deck'
}).enable();

exports.default = _default;
},{"probe.gl":"../../../node_modules/probe.gl/dist/esm/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-electron.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isElectron() {
  if (typeof window !== 'undefined' && (0, _typeof2.default)(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && (0, _typeof2.default)(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  if ((typeof navigator === "undefined" ? "undefined" : (0, _typeof2.default)(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}

var _default = isElectron();

exports.default = _default;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-browser.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.isBrowserMainThread = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && String(process) === '[object process]' && !true;
var isBrowser = !isNode || _isElectron.default;
var isBrowserMainThread = isBrowser && typeof document !== 'undefined';
exports.isBrowserMainThread = isBrowserMainThread;
var _default = isBrowser;
exports.default = _default;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","./is-electron":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-electron.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.document = exports.global = exports.window = exports.self = void 0;
var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _probe = require("probe.gl");

var _default = new _probe.Log({
  id: 'luma'
}).enable();

exports.default = _default;
},{"probe.gl":"../../../node_modules/probe.gl/dist/esm/index.js"}],"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'webgl2-polyfill: assertion failed.');
  }
}
},{}],"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/polyfills/get-parameter-polyfill.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParameterPolyfill = getParameterPolyfill;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _WEBGL_PARAMETERS;

var OES_element_index = 'OES_element_index';
var WEBGL_draw_buffers = 'WEBGL_draw_buffers';
var EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
var EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
var EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
var WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';
var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
var GL_DONT_CARE = 0x1100;
var GL_GPU_DISJOINT_EXT = 0x8fbb;
var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
var GL_UNMASKED_VENDOR_WEBGL = 0x9245;
var GL_UNMASKED_RENDERER_WEBGL = 0x9246;

var getWebGL2ValueOrZero = function getWebGL2ValueOrZero(gl) {
  return !isWebGL2(gl) ? 0 : undefined;
};

var WEBGL_PARAMETERS = (_WEBGL_PARAMETERS = {}, (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 3074, function (gl) {
  return !isWebGL2(gl) ? 36064 : undefined;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, GL_FRAGMENT_SHADER_DERIVATIVE_HINT, function (gl) {
  return !isWebGL2(gl) ? GL_DONT_CARE : undefined;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35977, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 32937, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, GL_GPU_DISJOINT_EXT, function (gl, getParameter) {
  var ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
  return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, GL_UNMASKED_VENDOR_WEBGL, function (gl, getParameter) {
  var ext = gl.getExtension(WEBGL_debug_renderer_info);
  return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, GL_UNMASKED_RENDERER_WEBGL, function (gl, getParameter) {
  var ext = gl.getExtension(WEBGL_debug_renderer_info);
  return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, function (gl, getParameter) {
  var ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
  return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 32883, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35071, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 37447, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 36063, function (gl, getParameter) {
  if (!isWebGL2(gl)) {
    var ext = gl.getExtension(WEBGL_draw_buffers);
    return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
  }

  return undefined;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35379, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35374, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35377, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 34852, function (gl) {
  if (!isWebGL2(gl)) {
    var ext = gl.getExtension(WEBGL_draw_buffers);
    return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
  }

  return undefined;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 36203, function (gl) {
  return gl.getExtension(OES_element_index) ? 2147483647 : 65535;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 33001, function (gl) {
  return gl.getExtension(OES_element_index) ? 16777216 : 65535;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 33000, function (gl) {
  return 16777216;
}), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 37157, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35373, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35657, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 36183, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 37137, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 34045, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35978, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35979, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35968, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35376, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35375, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35659, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 37154, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35371, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35658, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35076, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35077, getWebGL2ValueOrZero), (0, _defineProperty2.default)(_WEBGL_PARAMETERS, 35380, getWebGL2ValueOrZero), _WEBGL_PARAMETERS);

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function getParameterPolyfill(gl, originalGetParameter, pname) {
  var limit = WEBGL_PARAMETERS[pname];
  var value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
  var result = value !== undefined ? value : originalGetParameter(pname);
  return result;
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/polyfill-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEBGL2_CONTEXT_OVERRIDES = exports.WEBGL2_CONTEXT_POLYFILLS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _assert = _interopRequireDefault(require("./assert"));

var _getParameterPolyfill = require("./polyfills/get-parameter-polyfill");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _WEBGL2_CONTEXT_POLYF;

var OES_vertex_array_object = 'OES_vertex_array_object';
var ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
var WEBGL_draw_buffers = 'WEBGL_draw_buffers';
var EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
var EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
var ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function getExtensionData(gl, extension) {
  return {
    webgl2: isWebGL2(gl),
    ext: gl.getExtension(extension)
  };
}

var WEBGL2_CONTEXT_POLYFILLS = (_WEBGL2_CONTEXT_POLYF = {}, (0, _defineProperty2.default)(_WEBGL2_CONTEXT_POLYF, OES_vertex_array_object, {
  meta: {
    suffix: 'OES'
  },
  createVertexArray: function createVertexArray() {
    (0, _assert.default)(false, ERR_VAO_NOT_SUPPORTED);
  },
  deleteVertexArray: function deleteVertexArray() {},
  bindVertexArray: function bindVertexArray() {},
  isVertexArray: function isVertexArray() {
    return false;
  }
}), (0, _defineProperty2.default)(_WEBGL2_CONTEXT_POLYF, ANGLE_instanced_arrays, {
  meta: {
    suffix: 'ANGLE'
  },
  vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
    (0, _assert.default)(divisor === 0, 'WebGL instanced rendering not supported');
  },
  drawElementsInstanced: function drawElementsInstanced() {},
  drawArraysInstanced: function drawArraysInstanced() {}
}), (0, _defineProperty2.default)(_WEBGL2_CONTEXT_POLYF, WEBGL_draw_buffers, {
  meta: {
    suffix: 'WEBGL'
  },
  drawBuffers: function drawBuffers() {
    (0, _assert.default)(false);
  }
}), (0, _defineProperty2.default)(_WEBGL2_CONTEXT_POLYF, EXT_disjoint_timer_query, {
  meta: {
    suffix: 'EXT'
  },
  createQuery: function createQuery() {
    (0, _assert.default)(false);
  },
  deleteQuery: function deleteQuery() {
    (0, _assert.default)(false);
  },
  beginQuery: function beginQuery() {
    (0, _assert.default)(false);
  },
  endQuery: function endQuery() {},
  getQuery: function getQuery(handle, pname) {
    return this.getQueryObject(handle, pname);
  },
  getQueryParameter: function getQueryParameter(handle, pname) {
    return this.getQueryObject(handle, pname);
  },
  getQueryObject: function getQueryObject() {}
}), _WEBGL2_CONTEXT_POLYF);
exports.WEBGL2_CONTEXT_POLYFILLS = WEBGL2_CONTEXT_POLYFILLS;
var WEBGL2_CONTEXT_OVERRIDES = {
  readBuffer: function readBuffer(gl, originalFunc, attachment) {
    if (isWebGL2(gl)) {
      originalFunc(attachment);
    } else {}
  },
  getVertexAttrib: function getVertexAttrib(gl, originalFunc, location, pname) {
    var _getExtensionData = getExtensionData(gl, ANGLE_instanced_arrays),
        webgl2 = _getExtensionData.webgl2,
        ext = _getExtensionData.ext;

    var result;

    switch (pname) {
      case 35069:
        result = !webgl2 ? false : undefined;
        break;

      case 35070:
        result = !webgl2 && !ext ? 0 : undefined;
        break;

      default:
    }

    return result !== undefined ? result : originalFunc(location, pname);
  },
  getProgramParameter: function getProgramParameter(gl, originalFunc, program, pname) {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case 35967:
          return 35981;

        case 35971:
          return 0;

        case 35382:
          return 0;

        default:
      }
    }

    return originalFunc(program, pname);
  },
  getInternalformatParameter: function getInternalformatParameter(gl, originalFunc, target, format, pname) {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case 32937:
          return new Int32Array([0]);

        default:
      }
    }

    return gl.getInternalformatParameter(target, format, pname);
  },
  getTexParameter: function getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case 34046:
        var extensions = gl.luma.extensions;
        var ext = extensions[EXT_texture_filter_anisotropic];
        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;

      default:
    }

    return originalFunc(target, pname);
  },
  getParameter: _getParameterPolyfill.getParameterPolyfill,
  hint: function hint(gl, originalFunc, pname, value) {
    return originalFunc(pname, value);
  }
};
exports.WEBGL2_CONTEXT_OVERRIDES = WEBGL2_CONTEXT_OVERRIDES;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","./assert":"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/assert.js","./polyfills/get-parameter-polyfill":"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/polyfills/get-parameter-polyfill.js"}],"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/polyfill-context.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = polyfillContext;

var _assert = _interopRequireDefault(require("./assert"));

var _polyfillTable = require("./polyfill-table");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  initializeExtensions(gl);

  if (!gl.luma.polyfilled) {
    installPolyfills(gl, _polyfillTable.WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, {
      target: gl.luma,
      target2: gl
    });
    gl.luma.polyfilled = true;
  }

  return gl;
}

var global_ = typeof global !== 'undefined' ? global : window;
global_.polyfillContext = polyfillContext;

function initializeExtensions(gl) {
  gl.luma.extensions = {};
  var EXTENSIONS = gl.getSupportedExtensions() || [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = EXTENSIONS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var extension = _step.value;
      gl.luma[extension] = gl.getExtension(extension);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function installOverrides(gl, _ref) {
  var target = _ref.target,
      target2 = _ref.target2;
  Object.keys(_polyfillTable.WEBGL2_CONTEXT_OVERRIDES).forEach(function (key) {
    if (typeof _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key] === 'function') {
      var originalFunc = gl[key] ? gl[key].bind(gl) : function () {};

      var polyfill = _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);

      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}

function installPolyfills(gl, polyfills) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = Object.getOwnPropertyNames(polyfills)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var extension = _step2.value;

      if (extension !== 'overrides') {
        polyfillExtension(gl, {
          extension: extension,
          target: gl.luma,
          target2: gl
        });
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

function polyfillExtension(gl, _ref2) {
  var extension = _ref2.extension,
      target = _ref2.target,
      target2 = _ref2.target2;
  var defaults = _polyfillTable.WEBGL2_CONTEXT_POLYFILLS[extension];
  (0, _assert.default)(defaults);
  var _defaults$meta = defaults.meta,
      meta = _defaults$meta === void 0 ? {} : _defaults$meta;
  var _meta$suffix = meta.suffix,
      suffix = _meta$suffix === void 0 ? '' : _meta$suffix;
  var ext = gl.getExtension(extension);

  var _loop = function _loop() {
    var key = _Object$keys[_i];
    var extKey = "".concat(key).concat(suffix);
    var polyfill = null;

    if (key === 'meta') {} else if (typeof gl[key] === 'function') {} else if (ext && typeof ext[extKey] === 'function') {
      polyfill = function polyfill() {
        return ext[extKey].apply(ext, arguments);
      };
    } else if (typeof defaults[key] === 'function') {
      polyfill = defaults[key].bind(target);
    }

    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  };

  for (var _i = 0, _Object$keys = Object.keys(defaults); _i < _Object$keys.length; _i++) {
    _loop();
  }
}
},{"./assert":"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/assert.js","./polyfill-table":"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/polyfill-table.js"}],"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "polyfillContext", {
  enumerable: true,
  get: function () {
    return _polyfillContext.default;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _polyfillContext.default;
  }
});

var _polyfillContext = _interopRequireDefault(require("./polyfill-context"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./polyfill-context":"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/polyfill-context.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/init.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
exports.default = exports.lumaStats = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _isBrowser = _interopRequireDefault(require("./utils/is-browser"));

var _globals = require("./utils/globals");

var _log = _interopRequireDefault(require("./utils/log"));

var _probe = require("probe.gl");

require("@luma.gl/webgl2-polyfill");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VERSION = typeof "7.1.0" !== 'undefined' ? "7.1.0" : 'untranspiled source';
var STARTUP_MESSAGE = 'set luma.log.priority=1 (or higher) to trace rendering';

var StatsManager = function () {
  function StatsManager() {
    (0, _classCallCheck2.default)(this, StatsManager);
    this.stats = new Map();
  }

  (0, _createClass2.default)(StatsManager, [{
    key: "get",
    value: function get(name) {
      if (!this.stats.has(name)) {
        this.stats.set(name, new _probe.Stats({
          id: name
        }));
      }

      return this.stats.get(name);
    }
  }]);
  return StatsManager;
}();

var lumaStats = new StatsManager();
exports.lumaStats = lumaStats;

if (_globals.global.luma && _globals.global.luma.VERSION !== VERSION) {
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(_globals.global.luma.VERSION, " vs ").concat(VERSION));
}

if (!_globals.global.luma) {
  if (_isBrowser.default) {
    _log.default.log(1, "luma.gl ".concat(VERSION, " - ").concat(STARTUP_MESSAGE))();
  }

  _globals.global.luma = _globals.global.luma || {
    VERSION: VERSION,
    version: VERSION,
    log: _log.default,
    stats: lumaStats,
    globals: {
      modules: {},
      nodeIO: {}
    }
  };
}

var _default = _globals.global.luma;
exports.default = _default;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./utils/is-browser":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-browser.js","./utils/globals":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/globals.js","./utils/log":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/log.js","probe.gl":"../../../node_modules/probe.gl/dist/esm/index.js","@luma.gl/webgl2-polyfill":"../../../node_modules/@luma.gl/webgl2-polyfill/dist/esm/index.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
},{}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/deep-array-equal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deepArrayEqual;

function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }

  var isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  var isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

  if (isArrayX && isArrayY && x.length === y.length) {
    for (var i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
}
},{}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectEmpty = isObjectEmpty;
exports.isWebGL2 = isWebGL2;

function isObjectEmpty(object) {
  for (var key in object) {
    return false;
  }

  return true;
}

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}
},{}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "deepArrayEqual", {
  enumerable: true,
  get: function () {
    return _deepArrayEqual.default;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _utils.isWebGL2;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function () {
    return _utils.isObjectEmpty;
  }
});

var _assert = _interopRequireDefault(require("./assert"));

var _deepArrayEqual = _interopRequireDefault(require("./deep-array-equal"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./assert":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/assert.js","./deep-array-equal":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/deep-array-equal.js","./utils":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/utils.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/webgl-parameter-tables.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GL_PARAMETER_GETTERS = exports.GL_COMPOSITE_PARAMETER_SETTERS = exports.GL_PARAMETER_SETTERS = exports.GL_PARAMETER_DEFAULTS = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _GL_PARAMETER_DEFAULT, _GL_PARAMETER_SETTERS, _GL_PARAMETER_GETTERS;

var GL_PARAMETER_DEFAULTS = (_GL_PARAMETER_DEFAULT = {}, (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3042, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32773, new Float32Array([0, 0, 0, 0])), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32777, 32774), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 34877, 32774), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32969, 1), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32968, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32971, 1), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32970, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3106, new Float32Array([0, 0, 0, 0])), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3107, [true, true, true, true]), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2884, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2885, 1029), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2929, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2931, 1), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2932, 513), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2928, new Float32Array([0, 1])), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2930, true), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3024, true), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 36006, null), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2886, 2305), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 33170, 4352), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2849, 1), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32823, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32824, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 10752, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32938, 1.0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32939, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3089, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3088, new Int32Array([0, 0, 1024, 1024])), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2960, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2961, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2968, 0xffffffff), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 36005, 0xffffffff), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2962, 519), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2967, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2963, 0xffffffff), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 34816, 519), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 36003, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 36004, 0xffffffff), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2964, 7680), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2965, 7680), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2966, 7680), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 34817, 7680), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 34818, 7680), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 34819, 7680), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 2978, new Int32Array([0, 0, 1024, 1024])), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3333, 4), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3317, 4), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 37440, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 37441, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 37443, 37444), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 35723, 4352), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 36010, null), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 35977, false), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3330, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3332, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3331, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3314, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32878, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3316, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 3315, 0), (0, _defineProperty2.default)(_GL_PARAMETER_DEFAULT, 32877, 0), _GL_PARAMETER_DEFAULT);
exports.GL_PARAMETER_DEFAULTS = GL_PARAMETER_DEFAULTS;

var enable = function enable(gl, value, key) {
  return value ? gl.enable(key) : gl.disable(key);
};

var hint = function hint(gl, value, key) {
  return gl.hint(key, value);
};

var pixelStorei = function pixelStorei(gl, value, key) {
  return gl.pixelStorei(key, value);
};

var drawFramebuffer = function drawFramebuffer(gl, value) {
  var target = (0, _utils.isWebGL2)(gl) ? 36009 : 36160;
  return gl.bindFramebuffer(target, value);
};

var readFramebuffer = function readFramebuffer(gl, value) {
  return gl.bindFramebuffer(36008, value);
};

var GL_PARAMETER_SETTERS = (_GL_PARAMETER_SETTERS = {}, (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3042, enable), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32773, function (gl, value) {
  return gl.blendColor.apply(gl, (0, _toConsumableArray2.default)(value));
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32777, 'blendEquation'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 34877, 'blendEquation'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32969, 'blendFunc'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32968, 'blendFunc'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32971, 'blendFunc'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32970, 'blendFunc'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3106, function (gl, value) {
  return gl.clearColor.apply(gl, (0, _toConsumableArray2.default)(value));
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3107, function (gl, value) {
  return gl.colorMask.apply(gl, (0, _toConsumableArray2.default)(value));
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2884, enable), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2885, function (gl, value) {
  return gl.cullFace(value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2929, enable), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2931, function (gl, value) {
  return gl.clearDepth(value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2932, function (gl, value) {
  return gl.depthFunc(value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2928, function (gl, value) {
  return gl.depthRange.apply(gl, (0, _toConsumableArray2.default)(value));
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2930, function (gl, value) {
  return gl.depthMask(value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3024, enable), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 35723, hint), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 36006, drawFramebuffer), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2886, function (gl, value) {
  return gl.frontFace(value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 33170, hint), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2849, function (gl, value) {
  return gl.lineWidth(value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32823, enable), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32824, 'polygonOffset'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 10752, 'polygonOffset'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 35977, enable), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32938, 'sampleCoverage'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32939, 'sampleCoverage'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3089, enable), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3088, function (gl, value) {
  return gl.scissor.apply(gl, (0, _toConsumableArray2.default)(value));
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2960, enable), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2961, function (gl, value) {
  return gl.clearStencil(value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2968, function (gl, value) {
  return gl.stencilMaskSeparate(1028, value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 36005, function (gl, value) {
  return gl.stencilMaskSeparate(1029, value);
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2962, 'stencilFuncFront'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2967, 'stencilFuncFront'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2963, 'stencilFuncFront'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 34816, 'stencilFuncBack'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 36003, 'stencilFuncBack'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 36004, 'stencilFuncBack'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2964, 'stencilOpFront'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2965, 'stencilOpFront'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2966, 'stencilOpFront'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 34817, 'stencilOpBack'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 34818, 'stencilOpBack'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 34819, 'stencilOpBack'), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 2978, function (gl, value) {
  return gl.viewport.apply(gl, (0, _toConsumableArray2.default)(value));
}), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3333, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3317, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 37440, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 37441, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 37443, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3330, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3332, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3331, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 36010, readFramebuffer), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3314, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32878, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3316, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 3315, pixelStorei), (0, _defineProperty2.default)(_GL_PARAMETER_SETTERS, 32877, pixelStorei), _GL_PARAMETER_SETTERS);
exports.GL_PARAMETER_SETTERS = GL_PARAMETER_SETTERS;
var GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: function blendEquation(gl, values) {
    return gl.blendEquationSeparate(values[32777], values[34877]);
  },
  blendFunc: function blendFunc(gl, values) {
    return gl.blendFuncSeparate(values[32969], values[32968], values[32971], values[32970]);
  },
  polygonOffset: function polygonOffset(gl, values) {
    return gl.polygonOffset(values[32824], values[10752]);
  },
  sampleCoverage: function sampleCoverage(gl, values) {
    return gl.sampleCoverage(values[32938], values[32939]);
  },
  stencilFuncFront: function stencilFuncFront(gl, values) {
    return gl.stencilFuncSeparate(1028, values[2962], values[2967], values[2963]);
  },
  stencilFuncBack: function stencilFuncBack(gl, values) {
    return gl.stencilFuncSeparate(1029, values[34816], values[36003], values[36004]);
  },
  stencilOpFront: function stencilOpFront(gl, values) {
    return gl.stencilOpSeparate(1028, values[2964], values[2965], values[2966]);
  },
  stencilOpBack: function stencilOpBack(gl, values) {
    return gl.stencilOpSeparate(1029, values[34817], values[34818], values[34819]);
  }
};
exports.GL_COMPOSITE_PARAMETER_SETTERS = GL_COMPOSITE_PARAMETER_SETTERS;

var isEnabled = function isEnabled(gl, key) {
  return gl.isEnabled(key);
};

var GL_PARAMETER_GETTERS = (_GL_PARAMETER_GETTERS = {}, (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 3042, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 2884, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 2929, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 3024, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 32823, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 32926, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 32928, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 3089, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 2960, isEnabled), (0, _defineProperty2.default)(_GL_PARAMETER_GETTERS, 35977, isEnabled), _GL_PARAMETER_GETTERS);
exports.GL_PARAMETER_GETTERS = GL_PARAMETER_GETTERS;
},{"@babel/runtime/helpers/esm/toConsumableArray":"../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/unified-parameter-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setParameter = setParameter;
exports.setParameters = setParameters;
exports.getParameter = getParameter;
exports.getParameters = getParameters;
exports.getDefaultParameters = getDefaultParameters;
exports.resetParameters = resetParameters;
exports.getModifiedParameters = getModifiedParameters;

var _webglParameterTables = require("./webgl-parameter-tables");

var _deepArrayEqual = _interopRequireDefault(require("../utils/deep-array-equal"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function setParameter(gl, key, value) {
  var getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
  var prevValue = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  var setter = _webglParameterTables.GL_PARAMETER_SETTERS[key];
  (0, _utils.assert)(typeof setter === 'function');
  setter(gl, value, Number(key));
  return prevValue;
}

function setParameters(gl, values) {
  var compositeSetters = {};

  for (var key in values) {
    var glConstant = Number(key);
    var setter = _webglParameterTables.GL_PARAMETER_SETTERS[key];

    if (setter) {
      if (typeof setter === 'string') {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }

  var cache = gl.state && gl.state.cache;

  if (cache) {
    var mergedValues = Object.assign({}, cache, values);

    for (var _key in compositeSetters) {
      var compositeSetter = _webglParameterTables.GL_COMPOSITE_PARAMETER_SETTERS[_key];
      compositeSetter(gl, mergedValues);
    }
  }
}

function getParameter(gl, key) {
  var getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
  return getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
}

function getParameters(gl, parameters) {
  parameters = parameters || _webglParameterTables.GL_PARAMETER_DEFAULTS;
  var parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  var state = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = parameterKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      state[key] = getParameter(gl, key);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return state;
}

function getDefaultParameters(gl) {
  return Object.assign({}, _webglParameterTables.GL_PARAMETER_DEFAULTS, {});
}

function resetParameters(gl) {
  setParameters(gl, getDefaultParameters(gl));
}

function getModifiedParameters(gl) {
  var values = getParameters(_webglParameterTables.GL_PARAMETER_DEFAULTS);
  var modified = {};

  for (var key in _webglParameterTables.GL_PARAMETER_DEFAULTS) {
    if (!(0, _deepArrayEqual.default)(values[key], _webglParameterTables.GL_PARAMETER_DEFAULTS[key])) {
      modified[key] = values[key];
    }
  }

  return modified;
}
},{"./webgl-parameter-tables":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/webgl-parameter-tables.js","../utils/deep-array-equal":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/deep-array-equal.js","../utils":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/index.js"}],"../../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _arrayWithHoles;

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _iterableToArrayLimit;

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _nonIterableRest;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _slicedToArray;

var _arrayWithHoles = _interopRequireDefault(require("./arrayWithHoles"));

var _iterableToArrayLimit = _interopRequireDefault(require("./iterableToArrayLimit"));

var _nonIterableRest = _interopRequireDefault(require("./nonIterableRest"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) {
  return (0, _arrayWithHoles.default)(arr) || (0, _iterableToArrayLimit.default)(arr, i) || (0, _nonIterableRest.default)();
}
},{"./arrayWithHoles":"../../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","./iterableToArrayLimit":"../../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","./nonIterableRest":"../../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/webgl-setter-function-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/toConsumableArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}

var _default = {
  framebuffer: function framebuffer(gl, _framebuffer) {
    var handle = _framebuffer && 'handle' in _framebuffer ? _framebuffer.handle : _framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: function blend(gl, value) {
    return value ? gl.enable(3042) : gl.disable(3042);
  },
  blendColor: function blendColor(gl, value) {
    return gl.blendColor.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  blendEquation: function blendEquation(gl, args) {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate.apply(gl, (0, _toConsumableArray2.default)(args));
  },
  blendFunc: function blendFunc(gl, args) {
    args = isArray(args) && args.length === 2 ? [].concat((0, _toConsumableArray2.default)(args), (0, _toConsumableArray2.default)(args)) : args;
    gl.blendFuncSeparate.apply(gl, (0, _toConsumableArray2.default)(args));
  },
  clearColor: function clearColor(gl, value) {
    return gl.clearColor.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  clearDepth: function clearDepth(gl, value) {
    return gl.clearDepth(value);
  },
  clearStencil: function clearStencil(gl, value) {
    return gl.clearStencil(value);
  },
  colorMask: function colorMask(gl, value) {
    return gl.colorMask.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  cull: function cull(gl, value) {
    return value ? gl.enable(2884) : gl.disable(2884);
  },
  cullFace: function cullFace(gl, value) {
    return gl.cullFace(value);
  },
  depthTest: function depthTest(gl, value) {
    return value ? gl.enable(2929) : gl.disable(2929);
  },
  depthFunc: function depthFunc(gl, value) {
    return gl.depthFunc(value);
  },
  depthMask: function depthMask(gl, value) {
    return gl.depthMask(value);
  },
  depthRange: function depthRange(gl, value) {
    return gl.depthRange.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  dither: function dither(gl, value) {
    return value ? gl.enable(3024) : gl.disable(3024);
  },
  derivativeHint: function derivativeHint(gl, value) {
    gl.hint(35723, value);
  },
  frontFace: function frontFace(gl, value) {
    return gl.frontFace(value);
  },
  mipmapHint: function mipmapHint(gl, value) {
    return gl.hint(33170, value);
  },
  lineWidth: function lineWidth(gl, value) {
    return gl.lineWidth(value);
  },
  polygonOffsetFill: function polygonOffsetFill(gl, value) {
    return value ? gl.enable(32823) : gl.disable(32823);
  },
  polygonOffset: function polygonOffset(gl, value) {
    return gl.polygonOffset.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  sampleCoverage: function sampleCoverage(gl, value) {
    return gl.sampleCoverage.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  scissorTest: function scissorTest(gl, value) {
    return value ? gl.enable(3089) : gl.disable(3089);
  },
  scissor: function scissor(gl, value) {
    return gl.scissor.apply(gl, (0, _toConsumableArray2.default)(value));
  },
  stencilTest: function stencilTest(gl, value) {
    return value ? gl.enable(2960) : gl.disable(2960);
  },
  stencilMask: function stencilMask(gl, value) {
    value = isArray(value) ? value : [value, value];

    var _value = value,
        _value2 = (0, _slicedToArray2.default)(_value, 2),
        mask = _value2[0],
        backMask = _value2[1];

    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: function stencilFunc(gl, args) {
    args = isArray(args) && args.length === 3 ? [].concat((0, _toConsumableArray2.default)(args), (0, _toConsumableArray2.default)(args)) : args;

    var _args = args,
        _args2 = (0, _slicedToArray2.default)(_args, 6),
        func = _args2[0],
        ref = _args2[1],
        mask = _args2[2],
        backFunc = _args2[3],
        backRef = _args2[4],
        backMask = _args2[5];

    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: function stencilOp(gl, args) {
    args = isArray(args) && args.length === 3 ? [].concat((0, _toConsumableArray2.default)(args), (0, _toConsumableArray2.default)(args)) : args;

    var _args3 = args,
        _args4 = (0, _slicedToArray2.default)(_args3, 6),
        sfail = _args4[0],
        dpfail = _args4[1],
        dppass = _args4[2],
        backSfail = _args4[3],
        backDpfail = _args4[4],
        backDppass = _args4[5];

    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: function viewport(gl, value) {
    return gl.viewport.apply(gl, (0, _toConsumableArray2.default)(value));
  }
};
exports.default = _default;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/toConsumableArray":"../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/set-parameters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setParameters = setParameters;

var _unifiedParameterApi = require("./unified-parameter-api");

var _webglSetterFunctionTable = _interopRequireDefault(require("./webgl-setter-function-table"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function setParameters(gl, parameters) {
  (0, _unifiedParameterApi.setParameters)(gl, parameters);

  for (var key in parameters) {
    var setter = _webglSetterFunctionTable.default[key];

    if (setter) {
      setter(gl, parameters[key], key);
    }
  }
}
},{"./unified-parameter-api":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/unified-parameter-api.js","./webgl-setter-function-table":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/webgl-setter-function-table.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/state-tracking/webgl-function-to-parameters-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  enable: function enable(update, capability) {
    return update((0, _defineProperty2.default)({}, capability, true));
  },
  disable: function disable(update, capability) {
    return update((0, _defineProperty2.default)({}, capability, false));
  },
  pixelStorei: function pixelStorei(update, pname, value) {
    return update((0, _defineProperty2.default)({}, pname, value));
  },
  hint: function hint(update, pname, _hint) {
    return update((0, _defineProperty2.default)({}, pname, _hint));
  },
  bindFramebuffer: function bindFramebuffer(update, target, framebuffer) {
    var _update5;

    switch (target) {
      case 36160:
        return update((_update5 = {}, (0, _defineProperty2.default)(_update5, 36006, framebuffer), (0, _defineProperty2.default)(_update5, 36010, framebuffer), _update5));

      case 36009:
        return update((0, _defineProperty2.default)({}, 36006, framebuffer));

      case 36008:
        return update((0, _defineProperty2.default)({}, 36010, framebuffer));

      default:
        return null;
    }
  },
  blendColor: function blendColor(update, r, g, b, a) {
    return update((0, _defineProperty2.default)({}, 32773, new Float32Array([r, g, b, a])));
  },
  blendEquation: function blendEquation(update, mode) {
    var _update9;

    return update((_update9 = {}, (0, _defineProperty2.default)(_update9, 32777, mode), (0, _defineProperty2.default)(_update9, 34877, mode), _update9));
  },
  blendEquationSeparate: function blendEquationSeparate(update, modeRGB, modeAlpha) {
    var _update10;

    return update((_update10 = {}, (0, _defineProperty2.default)(_update10, 32777, modeRGB), (0, _defineProperty2.default)(_update10, 34877, modeAlpha), _update10));
  },
  blendFunc: function blendFunc(update, src, dst) {
    var _update11;

    return update((_update11 = {}, (0, _defineProperty2.default)(_update11, 32969, src), (0, _defineProperty2.default)(_update11, 32968, dst), (0, _defineProperty2.default)(_update11, 32971, src), (0, _defineProperty2.default)(_update11, 32970, dst), _update11));
  },
  blendFuncSeparate: function blendFuncSeparate(update, srcRGB, dstRGB, srcAlpha, dstAlpha) {
    var _update12;

    return update((_update12 = {}, (0, _defineProperty2.default)(_update12, 32969, srcRGB), (0, _defineProperty2.default)(_update12, 32968, dstRGB), (0, _defineProperty2.default)(_update12, 32971, srcAlpha), (0, _defineProperty2.default)(_update12, 32970, dstAlpha), _update12));
  },
  clearColor: function clearColor(update, r, g, b, a) {
    return update((0, _defineProperty2.default)({}, 3106, new Float32Array([r, g, b, a])));
  },
  clearDepth: function clearDepth(update, depth) {
    return update((0, _defineProperty2.default)({}, 2931, depth));
  },
  clearStencil: function clearStencil(update, s) {
    return update((0, _defineProperty2.default)({}, 2961, s));
  },
  colorMask: function colorMask(update, r, g, b, a) {
    return update((0, _defineProperty2.default)({}, 3107, [r, g, b, a]));
  },
  cullFace: function cullFace(update, mode) {
    return update((0, _defineProperty2.default)({}, 2885, mode));
  },
  depthFunc: function depthFunc(update, func) {
    return update((0, _defineProperty2.default)({}, 2932, func));
  },
  depthRange: function depthRange(update, zNear, zFar) {
    return update((0, _defineProperty2.default)({}, 2928, new Float32Array([zNear, zFar])));
  },
  depthMask: function depthMask(update, mask) {
    return update((0, _defineProperty2.default)({}, 2930, mask));
  },
  frontFace: function frontFace(update, face) {
    return update((0, _defineProperty2.default)({}, 2886, face));
  },
  lineWidth: function lineWidth(update, width) {
    return update((0, _defineProperty2.default)({}, 2849, width));
  },
  polygonOffset: function polygonOffset(update, factor, units) {
    var _update23;

    return update((_update23 = {}, (0, _defineProperty2.default)(_update23, 32824, factor), (0, _defineProperty2.default)(_update23, 10752, units), _update23));
  },
  sampleCoverage: function sampleCoverage(update, value, invert) {
    var _update24;

    return update((_update24 = {}, (0, _defineProperty2.default)(_update24, 32938, value), (0, _defineProperty2.default)(_update24, 32939, invert), _update24));
  },
  scissor: function scissor(update, x, y, width, height) {
    return update((0, _defineProperty2.default)({}, 3088, new Int32Array([x, y, width, height])));
  },
  stencilMask: function stencilMask(update, mask) {
    var _update26;

    return update((_update26 = {}, (0, _defineProperty2.default)(_update26, 2968, mask), (0, _defineProperty2.default)(_update26, 36005, mask), _update26));
  },
  stencilMaskSeparate: function stencilMaskSeparate(update, face, mask) {
    return update((0, _defineProperty2.default)({}, face === 1028 ? 2968 : 36005, mask));
  },
  stencilFunc: function stencilFunc(update, func, ref, mask) {
    var _update28;

    return update((_update28 = {}, (0, _defineProperty2.default)(_update28, 2962, func), (0, _defineProperty2.default)(_update28, 2967, ref), (0, _defineProperty2.default)(_update28, 2963, mask), (0, _defineProperty2.default)(_update28, 34816, func), (0, _defineProperty2.default)(_update28, 36003, ref), (0, _defineProperty2.default)(_update28, 36004, mask), _update28));
  },
  stencilFuncSeparate: function stencilFuncSeparate(update, face, func, ref, mask) {
    var _update29;

    return update((_update29 = {}, (0, _defineProperty2.default)(_update29, face === 1028 ? 2962 : 34816, func), (0, _defineProperty2.default)(_update29, face === 1028 ? 2967 : 36003, ref), (0, _defineProperty2.default)(_update29, face === 1028 ? 2963 : 36004, mask), _update29));
  },
  stencilOp: function stencilOp(update, fail, zfail, zpass) {
    var _update30;

    return update((_update30 = {}, (0, _defineProperty2.default)(_update30, 2964, fail), (0, _defineProperty2.default)(_update30, 2965, zfail), (0, _defineProperty2.default)(_update30, 2966, zpass), (0, _defineProperty2.default)(_update30, 34817, fail), (0, _defineProperty2.default)(_update30, 34818, zfail), (0, _defineProperty2.default)(_update30, 34819, zpass), _update30));
  },
  stencilOpSeparate: function stencilOpSeparate(update, face, fail, zfail, zpass) {
    var _update31;

    return update((_update31 = {}, (0, _defineProperty2.default)(_update31, face === 1028 ? 2964 : 34817, fail), (0, _defineProperty2.default)(_update31, face === 1028 ? 2965 : 34818, zfail), (0, _defineProperty2.default)(_update31, face === 1028 ? 2966 : 34819, zpass), _update31));
  },
  viewport: function viewport(update, x, y, width, height) {
    return update((0, _defineProperty2.default)({}, 2978, new Int32Array([x, y, width, height])));
  }
};
exports.default = _default;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/state-tracking/track-context-state.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = trackContextState;
exports.pushContextState = pushContextState;
exports.popContextState = popContextState;
exports.deepEqual = exports.clone = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _webglFunctionToParametersTable = _interopRequireDefault(require("./webgl-function-to-parameters-table"));

var _webglParameterTables = require("../unified-parameter-api/webgl-parameter-tables");

var _unifiedParameterApi = require("../unified-parameter-api/unified-parameter-api");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clone = function clone(x) {
  return Array.isArray(x) || ArrayBuffer.isView(x) ? x.slice() : x;
};

exports.clone = clone;

var deepEqual = function deepEqual(x, y) {
  var isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  var isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

  if (isArrayX && isArrayY && x.length === y.length) {
    for (var i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }

    return true;
  }

  return x === y;
};

exports.deepEqual = deepEqual;

function installGetterOverride(gl, functionName) {
  var originalGetterFunc = gl[functionName].bind(gl);

  gl[functionName] = function get() {
    var pname = arguments.length <= 0 ? undefined : arguments[0];

    if (!(pname in gl.state.cache)) {
      gl.state.cache[pname] = originalGetterFunc.apply(void 0, arguments);
    }

    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc.apply(void 0, arguments);
  };

  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-from-cache"),
    configurable: false
  });
}

function installSetterSpy(gl, functionName, setter) {
  var originalSetterFunc = gl[functionName].bind(gl);

  gl[functionName] = function set() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }

    var _setter = setter.apply(void 0, [gl.state._updateCache].concat(params)),
        valueChanged = _setter.valueChanged,
        oldValue = _setter.oldValue;

    if (valueChanged) {
      var _gl$state;

      (_gl$state = gl.state).log.apply(_gl$state, ["gl.".concat(functionName)].concat(params));

      originalSetterFunc.apply(void 0, params);
    }

    return oldValue;
  };

  Object.defineProperty(gl[functionName], 'name', {
    value: "".concat(functionName, "-to-cache"),
    configurable: false
  });
}

var GLState = function () {
  function GLState(gl) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$copyState = _ref.copyState,
        copyState = _ref$copyState === void 0 ? false : _ref$copyState,
        _ref$log = _ref.log,
        log = _ref$log === void 0 ? function () {} : _ref$log;

    (0, _classCallCheck2.default)(this, GLState);
    this.gl = gl;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? (0, _unifiedParameterApi.getParameters)(gl) : Object.assign({}, _webglParameterTables.GL_PARAMETER_DEFAULTS);
    this.log = log;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }

  (0, _createClass2.default)(GLState, [{
    key: "push",
    value: function push() {
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.stateStack.push({});
    }
  }, {
    key: "pop",
    value: function pop() {
      (0, _utils.assert)(this.stateStack.length > 0);
      var oldValues = this.stateStack[this.stateStack.length - 1];
      (0, _unifiedParameterApi.setParameters)(this.gl, oldValues, this.cache);
      this.stateStack.pop();
    }
  }, {
    key: "_updateCache",
    value: function _updateCache(values) {
      var valueChanged = false;
      var oldValue;
      var oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];

      for (var key in values) {
        (0, _utils.assert)(key !== undefined);

        if (!deepEqual(values[key], this.cache[key])) {
          valueChanged = true;
          oldValue = this.cache[key];

          if (oldValues && !(key in oldValues)) {
            oldValues[key] = this.cache[key];
          }

          this.cache[key] = values[key];
        }
      }

      return {
        valueChanged: valueChanged,
        oldValue: oldValue
      };
    }
  }]);
  return GLState;
}();

function trackContextState(gl) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$enable = _ref2.enable,
      enable = _ref2$enable === void 0 ? true : _ref2$enable,
      copyState = _ref2.copyState;

  (0, _utils.assert)(copyState !== undefined);

  if (!gl.state) {
    var global_ = typeof global !== 'undefined' ? global : window;

    if (global_.polyfillContext) {
      global_.polyfillContext(gl);
    }

    gl.state = new GLState(gl, {
      copyState: copyState,
      enable: enable
    });

    for (var key in _webglFunctionToParametersTable.default) {
      var setter = _webglFunctionToParametersTable.default[key];
      installSetterSpy(gl, key, setter);
    }

    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }

  gl.state.enable = enable;
  return gl;
}

function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }

  gl.state.push();
}

function popContextState(gl) {
  (0, _utils.assert)(gl.state);
  gl.state.pop();
}
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./webgl-function-to-parameters-table":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/state-tracking/webgl-function-to-parameters-table.js","../unified-parameter-api/webgl-parameter-tables":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/webgl-parameter-tables.js","../unified-parameter-api/unified-parameter-api":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/unified-parameter-api.js","../utils":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/state-tracking/with-parameters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withParameters = withParameters;

var _trackContextState = require("./track-context-state");

var _setParameters = require("../unified-parameter-api/set-parameters");

var _utils = require("../utils");

function withParameters(gl, parameters, func) {
  if ((0, _utils.isObjectEmpty)(parameters)) {
    return func(gl);
  }

  var _parameters$nocatch = parameters.nocatch,
      nocatch = _parameters$nocatch === void 0 ? true : _parameters$nocatch;
  (0, _utils.assert)(!parameters.frameBuffer);
  (0, _trackContextState.pushContextState)(gl);
  (0, _setParameters.setParameters)(gl, parameters);
  var value;

  if (nocatch) {
    value = func(gl);
    (0, _trackContextState.popContextState)(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      (0, _trackContextState.popContextState)(gl);
    }
  }

  return value;
}
},{"./track-context-state":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/state-tracking/track-context-state.js","../unified-parameter-api/set-parameters":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/set-parameters.js","../utils":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.setParameter;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.resetParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.getModifiedParameters;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _setParameters.setParameters;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _trackContextState.default;
  }
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.default;
  }
});
Object.defineProperty(exports, "pushContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.pushContextState;
  }
});
Object.defineProperty(exports, "popContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.popContextState;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _withParameters.withParameters;
  }
});

var _unifiedParameterApi = require("./unified-parameter-api/unified-parameter-api");

var _setParameters = require("./unified-parameter-api/set-parameters");

var _trackContextState = _interopRequireWildcard(require("./state-tracking/track-context-state"));

var _withParameters = require("./state-tracking/with-parameters");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }
},{"./unified-parameter-api/unified-parameter-api":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/unified-parameter-api.js","./unified-parameter-api/set-parameters":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/unified-parameter-api/set-parameters.js","./state-tracking/track-context-state":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/state-tracking/track-context-state.js","./state-tracking/with-parameters":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/state-tracking/with-parameters.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/webgl-types.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.headlessGL = headlessGL;
exports.WebGL2RenderingContext = exports.WebGLShaderPrecisionFormat = exports.WebGLActiveInfo = exports.WebGLUniformLocation = exports.WebGLTexture = exports.WebGLRenderbuffer = exports.WebGLFramebuffer = exports.WebGLBuffer = exports.WebGLShader = exports.WebGLProgram = exports.WebGLRenderingContext = exports.Image = exports.webGLTypesAvailable = exports.headlessTypes = exports.ERR_HEADLESSGL_LOAD = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _globals = require("../utils/globals");

var _isBrowser = _interopRequireDefault(require("../utils/is-browser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_HEADLESSGL_LOAD = "luma.gl: loaded under Node.js without headless gl installed, meaning that WebGL contexts can not be created. This may not be an error. For example, this is a typical configuration for isorender applications running on the server.";
exports.ERR_HEADLESSGL_LOAD = ERR_HEADLESSGL_LOAD;
var m = module;
var headlessTypes = null;
exports.headlessTypes = headlessTypes;

function headlessGL() {
  var headless = m.require('gl');

  if (!headless) {
    throw new Error(ERR_HEADLESSGL_LOAD);
  }

  return headless.apply(void 0, arguments);
}

if (!_isBrowser.default) {
  try {
    exports.headlessTypes = headlessTypes = m.require('gl/wrap');
  } catch (error) {}
}

var DummyType = function DummyType() {
  (0, _classCallCheck2.default)(this, DummyType);
};

var _ref = headlessTypes || _globals.global,
    _ref$WebGLRenderingCo = _ref.WebGLRenderingContext,
    WebGLRenderingContext = _ref$WebGLRenderingCo === void 0 ? DummyType : _ref$WebGLRenderingCo,
    _ref$WebGLProgram = _ref.WebGLProgram,
    WebGLProgram = _ref$WebGLProgram === void 0 ? DummyType : _ref$WebGLProgram,
    _ref$WebGLShader = _ref.WebGLShader,
    WebGLShader = _ref$WebGLShader === void 0 ? DummyType : _ref$WebGLShader,
    _ref$WebGLBuffer = _ref.WebGLBuffer,
    WebGLBuffer = _ref$WebGLBuffer === void 0 ? DummyType : _ref$WebGLBuffer,
    _ref$WebGLFramebuffer = _ref.WebGLFramebuffer,
    WebGLFramebuffer = _ref$WebGLFramebuffer === void 0 ? DummyType : _ref$WebGLFramebuffer,
    _ref$WebGLRenderbuffe = _ref.WebGLRenderbuffer,
    WebGLRenderbuffer = _ref$WebGLRenderbuffe === void 0 ? DummyType : _ref$WebGLRenderbuffe,
    _ref$WebGLTexture = _ref.WebGLTexture,
    WebGLTexture = _ref$WebGLTexture === void 0 ? DummyType : _ref$WebGLTexture,
    _ref$WebGLUniformLoca = _ref.WebGLUniformLocation,
    WebGLUniformLocation = _ref$WebGLUniformLoca === void 0 ? DummyType : _ref$WebGLUniformLoca,
    _ref$WebGLActiveInfo = _ref.WebGLActiveInfo,
    WebGLActiveInfo = _ref$WebGLActiveInfo === void 0 ? DummyType : _ref$WebGLActiveInfo,
    _ref$WebGLShaderPreci = _ref.WebGLShaderPrecisionFormat,
    WebGLShaderPrecisionFormat = _ref$WebGLShaderPreci === void 0 ? DummyType : _ref$WebGLShaderPreci;

exports.WebGLShaderPrecisionFormat = WebGLShaderPrecisionFormat;
exports.WebGLActiveInfo = WebGLActiveInfo;
exports.WebGLUniformLocation = WebGLUniformLocation;
exports.WebGLTexture = WebGLTexture;
exports.WebGLRenderbuffer = WebGLRenderbuffer;
exports.WebGLFramebuffer = WebGLFramebuffer;
exports.WebGLBuffer = WebGLBuffer;
exports.WebGLShader = WebGLShader;
exports.WebGLProgram = WebGLProgram;
exports.WebGLRenderingContext = WebGLRenderingContext;
var webGLTypesAvailable = WebGLRenderingContext !== DummyType && WebGLProgram !== DummyType && WebGLShader !== DummyType && WebGLBuffer !== DummyType && WebGLFramebuffer !== DummyType && WebGLRenderbuffer !== DummyType && WebGLTexture !== DummyType && WebGLUniformLocation !== DummyType && WebGLActiveInfo !== DummyType && WebGLShaderPrecisionFormat !== DummyType;
exports.webGLTypesAvailable = webGLTypesAvailable;

function getWebGL2RenderingContext() {
  var WebGL2RenderingContextNotSupported = function WebGL2RenderingContextNotSupported() {
    (0, _classCallCheck2.default)(this, WebGL2RenderingContextNotSupported);
  };

  return _globals.global.WebGL2RenderingContext || WebGL2RenderingContextNotSupported;
}

function getImage() {
  var ImageNotSupported = function ImageNotSupported() {
    (0, _classCallCheck2.default)(this, ImageNotSupported);
  };

  return _globals.global.Image || ImageNotSupported;
}

var WebGL2RenderingContext = getWebGL2RenderingContext();
exports.WebGL2RenderingContext = WebGL2RenderingContext;
var Image = getImage();
exports.Image = Image;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../utils/globals":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/globals.js","../utils/is-browser":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-browser.js"}],"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _objectSpread;

var _defineProperty = _interopRequireDefault(require("./defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      (0, _defineProperty.default)(target, key, source[key]);
    });
  }

  return target;
}
},{"./defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/context/create-headless-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHeadlessContext = createHeadlessContext;

var _webglTypes = require("../webgl-utils/webgl-types");

var ERR_HEADLESSGL_NOT_AVAILABLE = 'Failed to create WebGL context in Node.js, headless gl not available';
var ERR_HEADLESSGL_FAILED = 'Failed to create WebGL context in Node.js, headless gl returned null';

function createHeadlessContext(options) {
  var width = options.width,
      height = options.height,
      webgl1 = options.webgl1,
      webgl2 = options.webgl2,
      onError = options.onError;

  if (webgl2 && !webgl1) {
    return onError('headless-gl does not support WebGL2');
  }

  if (!_webglTypes.headlessGL) {
    return onError(ERR_HEADLESSGL_NOT_AVAILABLE);
  }

  var gl = (0, _webglTypes.headlessGL)(width, height, options);

  if (!gl) {
    return onError(ERR_HEADLESSGL_FAILED);
  }

  return gl;
}
},{"../webgl-utils/webgl-types":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/webgl-types.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;

var _globals = require("./globals");

function isOldIE() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var navigator = _globals.window.navigator || {};
  var userAgent = opts.userAgent || navigator.userAgent || '';
  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{"./globals":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/globals.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uid = uid;
exports.isPowerOfTwo = isPowerOfTwo;
exports.isObjectEmpty = isObjectEmpty;

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uidCounters = {};

function uid() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';
  uidCounters[id] = uidCounters[id] || 1;
  var count = uidCounters[id]++;
  return "".concat(id, "-").concat(count);
}

function isPowerOfTwo(n) {
  (0, _assert.default)(typeof n === 'number', 'Input must be a number');
  return n && (n & n - 1) === 0;
}

function isObjectEmpty(obj) {
  var isEmpty = true;

  for (var key in obj) {
    isEmpty = false;
    break;
  }

  return isEmpty;
}
},{"./assert":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatValue = formatValue;

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stubRemovedMethods = stubRemovedMethods;

var _log = _interopRequireDefault(require("./log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stubRemovedMethods(instance, className, version, methodNames) {
  var upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at http://uber.github.io/luma.gl/#/documentation/overview/upgrade-guide");
  var prototype = Object.getPrototypeOf(instance);
  methodNames.forEach(function (methodName) {
    if (prototype.methodName) {
      return;
    }

    prototype[methodName] = function () {
      _log.default.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();

      throw new Error(methodName);
    };
  });
}
},{"./log":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/log.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkProps = checkProps;

var _log = _interopRequireDefault(require("./log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function checkProps(className, props, propChecks) {
  var _propChecks$removedPr = propChecks.removedProps,
      removedProps = _propChecks$removedPr === void 0 ? {} : _propChecks$removedPr,
      _propChecks$deprecate = propChecks.deprecatedProps,
      deprecatedProps = _propChecks$deprecate === void 0 ? {} : _propChecks$deprecate,
      _propChecks$replacedP = propChecks.replacedProps,
      replacedProps = _propChecks$replacedP === void 0 ? {} : _propChecks$replacedP;

  for (var propName in removedProps) {
    if (propName in props) {
      var replacementProp = removedProps[propName];
      var replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : 'N/A';

      _log.default.removed("".concat(className, ".").concat(propName), replacement)();
    }
  }

  for (var _propName in deprecatedProps) {
    if (_propName in props) {
      var _replacementProp = deprecatedProps[_propName];

      _log.default.deprecated("".concat(className, ".").concat(_propName), "".concat(className, ".").concat(_replacementProp))();
    }
  }

  var newProps = null;

  for (var _propName2 in replacedProps) {
    if (_propName2 in props) {
      var _replacementProp2 = replacedProps[_propName2];

      _log.default.deprecated("".concat(className, ".").concat(_propName2), "".concat(className, ".").concat(_replacementProp2))();

      newProps = newProps || Object.assign({}, props);
      newProps[_replacementProp2] = props[_propName2];
      delete newProps[_propName2];
    }
  }

  return newProps || props;
}
},{"./log":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/log.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isOldIE", {
  enumerable: true,
  get: function () {
    return _isOldIe.default;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _utils.uid;
  }
});
Object.defineProperty(exports, "isPowerOfTwo", {
  enumerable: true,
  get: function () {
    return _utils.isPowerOfTwo;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function () {
    return _utils.isObjectEmpty;
  }
});
Object.defineProperty(exports, "formatValue", {
  enumerable: true,
  get: function () {
    return _formatValue.formatValue;
  }
});
Object.defineProperty(exports, "stubRemovedMethods", {
  enumerable: true,
  get: function () {
    return _stubMethods.stubRemovedMethods;
  }
});
Object.defineProperty(exports, "checkProps", {
  enumerable: true,
  get: function () {
    return _checkProps.checkProps;
  }
});

var _assert = _interopRequireDefault(require("./assert"));

var _log = _interopRequireDefault(require("./log"));

var _isBrowser = _interopRequireDefault(require("./is-browser"));

var _isOldIe = _interopRequireDefault(require("./is-old-ie"));

var _utils = require("./utils");

var _formatValue = require("./format-value");

var _stubMethods = require("./stub-methods");

var _checkProps = require("./check-props");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./assert":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","./log":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/log.js","./is-browser":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-browser.js","./is-old-ie":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-old-ie.js","./utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","./format-value":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js","./stub-methods":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js","./check-props":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/context/create-canvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPageLoadPromise = getPageLoadPromise;
exports.createCanvas = createCanvas;
exports.getCanvas = getCanvas;

var _utils = require("../utils");

var isPage = _utils.isBrowser && typeof document !== 'undefined';
var isPageLoaded = isPage && document.readyState === 'complete';
var pageLoadPromise;

function getPageLoadPromise() {
  if (!pageLoadPromise) {
    pageLoadPromise = isPage ? new Promise(function (resolve, reject) {
      if (isPage && document.readyState === 'complete') {
        isPageLoaded = true;
        resolve(document);
        return;
      }

      window.onload = function () {
        isPageLoaded = true;
        resolve(document);
      };
    }) : Promise.resolve({});
  }

  return pageLoadPromise;
}

function createCanvas(_ref) {
  var _ref$width = _ref.width,
      width = _ref$width === void 0 ? 800 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? 600 : _ref$height,
      _ref$id = _ref.id,
      id = _ref$id === void 0 ? 'gl-canvas' : _ref$id,
      _ref$insert = _ref.insert,
      insert = _ref$insert === void 0 ? true : _ref$insert;
  var canvas = document.createElement('canvas');
  canvas.id = id;
  canvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : '100%';
  canvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : '100%';

  if (insert) {
    var body = document.body;
    body.insertBefore(canvas, body.firstChild);
  }

  return canvas;
}

function getCanvas(_ref2) {
  var canvas = _ref2.canvas,
      width = _ref2.width,
      height = _ref2.height,
      _ref2$onError = _ref2.onError,
      onError = _ref2$onError === void 0 ? function () {} : _ref2$onError;
  var targetCanvas;

  if (typeof canvas === 'string') {
    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }

    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = createCanvas({
      id: 'lumagl-canvas',
      width: width,
      height: height,
      onError: onError
    });
  }

  return targetCanvas;
}
},{"../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/context/create-browser-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBrowserContext = createBrowserContext;

function createBrowserContext(canvas, options) {
  var _options$onError = options.onError,
      onError = _options$onError === void 0 ? function (message) {
    return null;
  } : _options$onError;

  var onCreateError = function onCreateError(error) {
    return onError("WebGL context: ".concat(error.statusMessage || 'error'));
  };

  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);
  var _options$webgl = options.webgl1,
      webgl1 = _options$webgl === void 0 ? true : _options$webgl,
      _options$webgl2 = options.webgl2,
      webgl2 = _options$webgl2 === void 0 ? true : _options$webgl2;
  var gl = null;

  if (webgl2) {
    gl = gl || canvas.getContext('webgl2', options);
    gl = gl || canvas.getContext('experimental-webgl2', options);
  }

  if (webgl1) {
    gl = gl || canvas.getContext('webgl', options);
    gl = gl || canvas.getContext('experimental-webgl', options);
  }

  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);

  if (!gl) {
    return onError("Failed to create ".concat(webgl2 && !webgl1 ? 'WebGL2' : 'WebGL', " context"));
  }

  return gl;
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/debug/get-context-debug-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextDebugInfo = getContextDebugInfo;

function getContextDebugInfo(gl) {
  var vendorMasked = gl.getParameter(7936);
  var rendererMasked = gl.getParameter(7937);
  var ext = gl.getExtension('WEBGL_debug_renderer_info');
  var vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  var rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked: vendorMasked,
    rendererMasked: rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/webgl-checks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWebGL = isWebGL;
exports.isWebGL2 = isWebGL2;
exports.assertWebGLContext = assertWebGLContext;
exports.assertWebGL2Context = assertWebGL2Context;
exports.ERR_WEBGL2 = exports.ERR_WEBGL = exports.ERR_CONTEXT = void 0;

var _utils = require("../utils");

var ERR_CONTEXT = 'Invalid WebGLRenderingContext';
exports.ERR_CONTEXT = ERR_CONTEXT;
var ERR_WEBGL = ERR_CONTEXT;
exports.ERR_WEBGL = ERR_WEBGL;
var ERR_WEBGL2 = 'Requires WebGL2';
exports.ERR_WEBGL2 = ERR_WEBGL2;

function isWebGL(gl) {
  return Boolean(gl && Number.isFinite(gl._version));
}

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function assertWebGLContext(gl) {
  (0, _utils.assert)(isWebGL(gl), ERR_CONTEXT);
}

function assertWebGL2Context(gl) {
  (0, _utils.assert)(isWebGL2(gl), ERR_WEBGL2);
}
},{"../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requestAnimationFrame = requestAnimationFrame;
exports.cancelAnimationFrame = cancelAnimationFrame;

function requestAnimationFrame(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}

function cancelAnimationFrame(timerId) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGLTypeFromTypedArray = getGLTypeFromTypedArray;
exports.getTypedArrayFromGLType = getTypedArrayFromGLType;
exports.flipRows = flipRows;
exports.scalePixels = scalePixels;
var ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';

function getGLTypeFromTypedArray(arrayOrType) {
  var type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;

  switch (type) {
    case Float32Array:
      return 5126;

    case Uint16Array:
      return 5123;

    case Uint32Array:
      return 5125;

    case Uint8Array:
      return 5121;

    case Uint8ClampedArray:
      return 5121;

    case Int8Array:
      return 5120;

    case Int16Array:
      return 5122;

    case Int32Array:
      return 5124;

    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}

function getTypedArrayFromGLType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === void 0 ? true : _ref$clamped;

  switch (glType) {
    case 5126:
      return Float32Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}

function flipRows(_ref2) {
  var data = _ref2.data,
      width = _ref2.width,
      height = _ref2.height,
      _ref2$bytesPerPixel = _ref2.bytesPerPixel,
      bytesPerPixel = _ref2$bytesPerPixel === void 0 ? 4 : _ref2$bytesPerPixel,
      temp = _ref2.temp;
  var bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);

  for (var y = 0; y < height / 2; ++y) {
    var topOffset = y * bytesPerRow;
    var bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data.set(temp, bottomOffset);
  }
}

function scalePixels(_ref3) {
  var data = _ref3.data,
      width = _ref3.width,
      height = _ref3.height;
  var newWidth = Math.round(width / 2);
  var newHeight = Math.round(height / 2);
  var newData = new Uint8Array(newWidth * newHeight * 4);

  for (var y = 0; y < newHeight; y++) {
    for (var x = 0; x < newWidth; x++) {
      for (var c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }

  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKeyValue = getKeyValue;
exports.getKey = getKey;
exports.getKeyType = getKeyType;

var _utils = require("../utils");

function getKeyValue(gl, name) {
  if (typeof name !== 'string') {
    return name;
  }

  var number = Number(name);

  if (!isNaN(number)) {
    return number;
  }

  name = name.replace(/^.*\./, '');
  var value = gl[name];
  (0, _utils.assert)(value !== undefined, "Accessing undefined constant GL.".concat(name));
  return value;
}

function getKey(gl, value) {
  value = Number(value);

  for (var key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }

  return String(value);
}

function getKeyType(gl, value) {
  (0, _utils.assert)(value !== undefined, 'undefined key');
  value = Number(value);

  for (var key in gl) {
    if (gl[key] === value) {
      return "GL.".concat(key);
    }
  }

  return String(value);
}
},{"../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _assertThisInitialized;

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _possibleConstructorReturn;

var _typeof2 = _interopRequireDefault(require("../../helpers/esm/typeof"));

var _assertThisInitialized = _interopRequireDefault(require("./assertThisInitialized"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) {
  if (call && ((0, _typeof2.default)(call) === "object" || typeof call === "function")) {
    return call;
  }

  return (0, _assertThisInitialized.default)(self);
}
},{"../../helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","./assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"}],"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _getPrototypeOf;

function _getPrototypeOf(o) {
  exports.default = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _setPrototypeOf;

function _setPrototypeOf(o, p) {
  exports.default = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/inherits.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _inherits;

var _setPrototypeOf = _interopRequireDefault(require("./setPrototypeOf"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) (0, _setPrototypeOf.default)(subClass, superClass);
}
},{"./setPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _init = require("../init");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';

var Resource = function () {
  function Resource(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Resource);
    (0, _webglUtils.assertWebGLContext)(gl);
    var id = opts.id,
        _opts$userData = opts.userData,
        userData = _opts$userData === void 0 ? {} : _opts$userData;
    this.gl = gl;
    this.id = id || (0, _utils.uid)(this.constructor.name);
    this.userData = userData;
    this._bound = false;
    this._handle = opts.handle;

    if (this._handle === undefined) {
      this._handle = this._createHandle();
    }

    this.byteLength = 0;

    this._addStats();
  }

  (0, _createClass2.default)(Resource, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.constructor.name, "(").concat(this.id, ")");
    }
  }, {
    key: "delete",
    value: function _delete() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$deleteChildren = _ref.deleteChildren,
          deleteChildren = _ref$deleteChildren === void 0 ? false : _ref$deleteChildren;

      var children = this._handle && this._deleteHandle(this._handle);

      if (this._handle) {
        this._removeStats();
      }

      this._handle = null;

      if (children && deleteChildren) {
        children.filter(Boolean).forEach(function (child) {
          child["delete"]();
        });
      }

      return this;
    }
  }, {
    key: "bind",
    value: function bind() {
      var funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;

      if (typeof funcOrHandle !== 'function') {
        this._bindHandle(funcOrHandle);

        return this;
      }

      var value;

      if (!this._bound) {
        this._bindHandle(this.handle);

        this._bound = true;
        value = funcOrHandle();
        this._bound = false;

        this._bindHandle(null);
      } else {
        value = funcOrHandle();
      }

      return value;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      this.bind(null);
    }
  }, {
    key: "getParameter",
    value: function getParameter(pname) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      pname = (0, _webglUtils.getKeyValue)(this.gl, pname);
      (0, _utils.assert)(pname);
      var parameters = this.constructor.PARAMETERS || {};
      var parameter = parameters[pname];

      if (parameter) {
        var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl);
        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

        if (!parameterAvailable) {
          var webgl1Default = parameter.webgl1;
          var webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
          var defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue;
        }
      }

      return this._getParameter(pname, opts);
    }
  }, {
    key: "getParameters",
    value: function getParameters() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref2 = {},
          parameters = _ref2.parameters,
          keys = _ref2.keys;
      var PARAMETERS = this.constructor.PARAMETERS || {};
      var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl);
      var values = {};
      var parameterKeys = parameters || Object.keys(PARAMETERS);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = parameterKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pname = _step.value;
          var parameter = PARAMETERS[pname];
          var parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

          if (parameterAvailable) {
            var key = keys ? (0, _webglUtils.getKey)(this.gl, pname) : pname;
            values[key] = this.getParameter(pname, opts);

            if (keys && parameter.type === 'GLenum') {
              values[key] = (0, _webglUtils.getKey)(this.gl, values[key]);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return values;
    }
  }, {
    key: "setParameter",
    value: function setParameter(pname, value) {
      pname = (0, _webglUtils.getKeyValue)(this.gl, pname);
      (0, _utils.assert)(pname);
      var parameters = this.constructor.PARAMETERS || {};
      var parameter = parameters[pname];

      if (parameter) {
        var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl);
        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

        if (!parameterAvailable) {
          throw new Error('Parameter not available on this platform');
        }

        if (parameter.type === 'GLenum') {
          value = (0, _webglUtils.getKeyValue)(value);
        }
      }

      this._setParameter(pname, value);

      return this;
    }
  }, {
    key: "setParameters",
    value: function setParameters(parameters) {
      for (var pname in parameters) {
        this.setParameter(pname, parameters[pname]);
      }

      return this;
    }
  }, {
    key: "stubRemovedMethods",
    value: function stubRemovedMethods(className, version, methodNames) {
      return (0, _utils.stubRemovedMethods)(this, className, version, methodNames);
    }
  }, {
    key: "initialize",
    value: function initialize(opts) {}
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_getOptsFromHandle",
    value: function _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname, opts) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_setParameter",
    value: function _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
  }, {
    key: "_context",
    value: function _context() {
      this.gl.luma = this.gl.luma || {};
      return this.gl.luma;
    }
  }, {
    key: "_addStats",
    value: function _addStats() {
      var name = this.constructor.name;

      var stats = _init.lumaStats.get('Resource Counts');

      stats.get('Resources Created').incrementCount();
      stats.get("".concat(name, "s Created")).incrementCount();
      stats.get("".concat(name, "s Active")).incrementCount();
    }
  }, {
    key: "_removeStats",
    value: function _removeStats() {
      var name = this.constructor.name;

      var stats = _init.lumaStats.get('Resource Counts');

      stats.get("".concat(name, "s Active")).decrementCount();
    }
  }, {
    key: "_trackAllocatedMemory",
    value: function _trackAllocatedMemory(bytes) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.name;

      var stats = _init.lumaStats.get('Memory Usage');

      stats.get('GPU Memory').addCount(bytes);
      stats.get("".concat(name, " Memory")).addCount(bytes);
      this.byteLength = bytes;
    }
  }, {
    key: "_trackDeallocatedMemory",
    value: function _trackDeallocatedMemory() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.constructor.name;

      var stats = _init.lumaStats.get('Memory Usage');

      stats.get('GPU Memory').subtractCount(this.byteLength);
      stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
      this.byteLength = 0;
    }
  }, {
    key: "handle",
    get: function get() {
      return this._handle;
    }
  }]);
  return Resource;
}();

exports.default = Resource;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../init":"../../../node_modules/@luma.gl/webgl/dist/esm/init.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@babel/runtime/helpers/esm/construct.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _construct;

var _setPrototypeOf = _interopRequireDefault(require("./setPrototypeOf"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    exports.default = _construct = Reflect.construct;
  } else {
    exports.default = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) (0, _setPrototypeOf.default)(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}
},{"./setPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ACCESSOR_VALUES = exports.default = void 0;

var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/construct"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
exports.DEFAULT_ACCESSOR_VALUES = DEFAULT_ACCESSOR_VALUES;
var PROP_CHECKS = {
  deprecatedProps: {
    instanced: 'divisor',
    isInstanced: 'divisor'
  }
};

var Accessor = function () {
  (0, _createClass2.default)(Accessor, null, [{
    key: "getBytesPerElement",
    value: function getBytesPerElement(accessor) {
      var ArrayType = (0, _webglUtils.getTypedArrayFromGLType)(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
  }, {
    key: "getBytesPerVertex",
    value: function getBytesPerVertex(accessor) {
      (0, _utils.assert)(accessor.size);
      var ArrayType = (0, _webglUtils.getTypedArrayFromGLType)(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
  }, {
    key: "resolve",
    value: function resolve() {
      for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
        accessors[_key] = arguments[_key];
      }

      return (0, _construct2.default)(Accessor, [DEFAULT_ACCESSOR_VALUES].concat(accessors));
    }
  }]);

  function Accessor() {
    var _this = this;

    (0, _classCallCheck2.default)(this, Accessor);

    for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      accessors[_key2] = arguments[_key2];
    }

    accessors.forEach(function (accessor) {
      return _this._assign(accessor);
    });
    Object.freeze(this);
  }

  (0, _createClass2.default)(Accessor, [{
    key: "toString",
    value: function toString() {
      return JSON.stringify(this);
    }
  }, {
    key: "_assign",
    value: function _assign() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      props = (0, _utils.checkProps)('Accessor', props, PROP_CHECKS);

      if (props.type !== undefined) {
        this.type = props.type;

        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }

      if (props.size !== undefined) {
        this.size = props.size;
      }

      if (props.offset !== undefined) {
        this.offset = props.offset;
      }

      if (props.stride !== undefined) {
        this.stride = props.stride;
      }

      if (props.normalized !== undefined) {
        this.normalized = props.normalized;
      }

      if (props.integer !== undefined) {
        this.integer = props.integer;
      }

      if (props.divisor !== undefined) {
        this.divisor = props.divisor;
      }

      if (props.buffer !== undefined) {
        this.buffer = props.buffer;
      }

      if (props.index !== undefined) {
        if (typeof index === 'boolean') {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }

      if (props.instanced !== undefined) {
        this.divisor = props.instanced ? 1 : 0;
      }

      if (props.isInstanced !== undefined) {
        this.divisor = props.isInstanced ? 1 : 0;
      }

      return this;
    }
  }, {
    key: "BYTES_PER_ELEMENT",
    get: function get() {
      return Accessor.getBytesPerElement(this);
    }
  }, {
    key: "BYTES_PER_VERTEX",
    get: function get() {
      return Accessor.getBytesPerVertex(this);
    }
  }]);
  return Accessor;
}();

exports.default = Accessor;
},{"@babel/runtime/helpers/esm/construct":"../../../node_modules/@babel/runtime/helpers/esm/construct.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _accessor = _interopRequireDefault(require("./accessor"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEBUG_DATA_LENGTH = 10;
var DEPRECATED_PROPS = {
  offset: 'accessor.offset',
  stride: 'accessor.stride',
  type: 'accessor.type',
  size: 'accessor.size',
  divisor: 'accessor.divisor',
  normalized: 'accessor.normalized',
  integer: 'accessor.integer',
  instanced: 'accessor.divisor',
  isInstanced: 'accessor.divisor'
};
var PROP_CHECKS_INITIALIZE = {
  removedProps: {},
  replacedProps: {
    bytes: 'byteLength'
  },
  deprecatedProps: DEPRECATED_PROPS
};
var PROP_CHECKS_SET_PROPS = {
  removedProps: DEPRECATED_PROPS
};

var Buffer = function (_Resource) {
  (0, _inherits2.default)(Buffer, _Resource);

  function Buffer(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Buffer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Buffer).call(this, gl, props));

    _this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);

    _this.target = props.target || (_this.gl.webgl2 ? 36662 : 34962);

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(Buffer, [{
    key: "getElementCount",
    value: function getElementCount() {
      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / _accessor.default.getBytesPerElement(accessor));
    }
  }, {
    key: "getVertexCount",
    value: function getVertexCount() {
      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / _accessor.default.getBytesPerVertex(accessor));
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }

      if (Number.isFinite(props)) {
        props = {
          byteLength: props
        };
      }

      props = (0, _utils.checkProps)('Buffer', props, PROP_CHECKS_INITIALIZE);
      this.usage = props.usage || 35044;
      this.debugData = null;
      this.setAccessor(Object.assign({}, props, props.accessor));

      if (props.data) {
        this._setData(props.data);
      } else {
        this._setByteLength(props.byteLength || 0);
      }

      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      props = (0, _utils.checkProps)('Buffer', props, PROP_CHECKS_SET_PROPS);

      if ('accessor' in props) {
        this.setAccessor(props.accessor);
      }

      return this;
    }
  }, {
    key: "setAccessor",
    value: function setAccessor(accessor) {
      accessor = Object.assign({}, accessor);
      delete accessor.buffer;
      this.accessor = new _accessor.default(accessor);
      return this;
    }
  }, {
    key: "reallocate",
    value: function reallocate(byteLength) {
      if (byteLength > this.byteLength) {
        this._setByteLength(byteLength);

        return true;
      }

      this.bytesUsed = byteLength;
      return false;
    }
  }, {
    key: "setData",
    value: function setData(props) {
      return this.initialize(props);
    }
  }, {
    key: "subData",
    value: function subData(props) {
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }

      var _props = props,
          data = _props.data,
          _props$offset = _props.offset,
          offset = _props$offset === void 0 ? 0 : _props$offset,
          _props$srcOffset = _props.srcOffset,
          srcOffset = _props$srcOffset === void 0 ? 0 : _props$srcOffset;
      var byteLength = props.byteLength || props.length;
      (0, _utils.assert)(data);
      var target = this.gl.webgl2 ? 36663 : this.target;
      this.gl.bindBuffer(target, this.handle);

      if (srcOffset !== 0 || byteLength !== undefined) {
        (0, _webglUtils.assertWebGL2Context)(this.gl);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(target, offset, data);
      }

      this.gl.bindBuffer(target, null);
      this.debugData = null;

      this._inferType(data);

      return this;
    }
  }, {
    key: "copyData",
    value: function copyData(_ref) {
      var sourceBuffer = _ref.sourceBuffer,
          _ref$readOffset = _ref.readOffset,
          readOffset = _ref$readOffset === void 0 ? 0 : _ref$readOffset,
          _ref$writeOffset = _ref.writeOffset,
          writeOffset = _ref$writeOffset === void 0 ? 0 : _ref$writeOffset,
          size = _ref.size;
      var gl = this.gl;
      (0, _webglUtils.assertWebGL2Context)(gl);
      gl.bindBuffer(36662, sourceBuffer.handle);
      gl.bindBuffer(36663, this.handle);
      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
      gl.bindBuffer(36662, null);
      gl.bindBuffer(36663, null);
      this.debugData = null;
      return this;
    }
  }, {
    key: "getData",
    value: function getData() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$dstData = _ref2.dstData,
          dstData = _ref2$dstData === void 0 ? null : _ref2$dstData,
          _ref2$srcByteOffset = _ref2.srcByteOffset,
          srcByteOffset = _ref2$srcByteOffset === void 0 ? 0 : _ref2$srcByteOffset,
          _ref2$dstOffset = _ref2.dstOffset,
          dstOffset = _ref2$dstOffset === void 0 ? 0 : _ref2$dstOffset,
          _ref2$length = _ref2.length,
          length = _ref2$length === void 0 ? 0 : _ref2$length;

      (0, _webglUtils.assertWebGL2Context)(this.gl);
      var ArrayType = (0, _webglUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
        clamped: false
      });

      var sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);

      var dstElementOffset = dstOffset;
      var dstAvailableElementCount;
      var dstElementCount;

      if (dstData) {
        dstElementCount = dstData.length;
        dstAvailableElementCount = dstElementCount - dstElementOffset;
      } else {
        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
        dstElementCount = dstElementOffset + dstAvailableElementCount;
      }

      var copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
      length = length || copyElementCount;
      (0, _utils.assert)(length <= copyElementCount);
      dstData = dstData || new ArrayType(dstElementCount);
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
      this.gl.bindBuffer(36662, null);
      return dstData;
    }
  }, {
    key: "bind",
    value: function bind() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$target = _ref3.target,
          target = _ref3$target === void 0 ? this.target : _ref3$target,
          _ref3$index = _ref3.index,
          index = _ref3$index === void 0 ? this.accessor && this.accessor.index : _ref3$index,
          _ref3$offset = _ref3.offset,
          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
          size = _ref3.size;

      if (target === 35345 || target === 35982) {
        if (size !== undefined) {
          this.gl.bindBufferRange(target, index, this.handle, offset, size);
        } else {
          (0, _utils.assert)(offset === 0);
          this.gl.bindBufferBase(target, index, this.handle);
        }
      } else {
        this.gl.bindBuffer(target, this.handle);
      }

      return this;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$target = _ref4.target,
          target = _ref4$target === void 0 ? this.target : _ref4$target,
          _ref4$index = _ref4.index,
          index = _ref4$index === void 0 ? this.accessor && this.accessor.index : _ref4$index;

      var isIndexedBuffer = target === 35345 || target === 35982;

      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target, index, null);
      } else {
        this.gl.bindBuffer(target, null);
      }

      return this;
    }
  }, {
    key: "getDebugData",
    value: function getDebugData() {
      if (!this.debugData) {
        this.debugData = this.getData({
          length: DEBUG_DATA_LENGTH
        });
        return {
          data: this.debugData,
          changed: true
        };
      }

      return {
        data: this.debugData,
        changed: false
      };
    }
  }, {
    key: "invalidateDebugData",
    value: function invalidateDebugData() {
      this.debugData = null;
    }
  }, {
    key: "_setData",
    value: function _setData(data) {
      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
      (0, _utils.assert)(ArrayBuffer.isView(data));

      this._trackDeallocatedMemory();

      var target = this._getTarget();

      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
      this.bytesUsed = data.byteLength;

      this._trackAllocatedMemory(data.byteLength);

      var type = (0, _webglUtils.getGLTypeFromTypedArray)(data);
      (0, _utils.assert)(type);
      this.setAccessor(new _accessor.default(this.accessor, {
        type: type
      }));
      return this;
    }
  }, {
    key: "_setByteLength",
    value: function _setByteLength(byteLength) {
      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;
      (0, _utils.assert)(byteLength >= 0);

      this._trackDeallocatedMemory();

      var data = byteLength;

      if (byteLength === 0) {
        data = new Float32Array(0);
      }

      var target = this._getTarget();

      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = null;
      this.bytesUsed = byteLength;

      this._trackAllocatedMemory(byteLength);

      return this;
    }
  }, {
    key: "_getTarget",
    value: function _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
  }, {
    key: "_getAvailableElementCount",
    value: function _getAvailableElementCount(srcByteOffset) {
      var ArrayType = (0, _webglUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
        clamped: false
      });
      var sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
      return this.getElementCount() - sourceElementOffset;
    }
  }, {
    key: "_inferType",
    value: function _inferType(data) {
      if (!this.accessor.type) {
        this.setAccessor(new _accessor.default(this.accessor, {
          type: (0, _webglUtils.getGLTypeFromTypedArray)(data)
        }));
      }
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createBuffer();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteBuffer(this.handle);

      this._trackDeallocatedMemory();
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      var value = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value;
    }
  }, {
    key: "setByteLength",
    value: function setByteLength(byteLength) {
      _utils.log.deprecated('setByteLength', 'reallocate')();

      return this.reallocate(byteLength);
    }
  }, {
    key: "updateAccessor",
    value: function updateAccessor(opts) {
      _utils.log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();

      this.accessor = new _accessor.default(this.accessor, opts);
      return this;
    }
  }, {
    key: "type",
    get: function get() {
      _utils.log.deprecated('Buffer.type', 'Buffer.accessor.type')();

      return this.accessor.type;
    }
  }, {
    key: "bytes",
    get: function get() {
      _utils.log.deprecated('Buffer.bytes', 'Buffer.byteLength')();

      return this.byteLength;
    }
  }]);
  return Buffer;
}(_resource.default);

exports.default = Buffer;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./accessor":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFormatSupported = isFormatSupported;
exports.isLinearFilteringSupported = isLinearFilteringSupported;
exports.TYPE_SIZES = exports.DATA_FORMAT_CHANNELS = exports.TEXTURE_FORMATS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _webglUtils = require("../webgl-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _TEXTURE_FORMATS, _DATA_FORMAT_CHANNELS, _TYPE_SIZES;

var TEXTURE_FORMATS = (_TEXTURE_FORMATS = {}, (0, _defineProperty2.default)(_TEXTURE_FORMATS, 6407, {
  dataFormat: 6407,
  types: [5121, 33635]
}), (0, _defineProperty2.default)(_TEXTURE_FORMATS, 6408, {
  dataFormat: 6408,
  types: [5121, 32819, 32820]
}), (0, _defineProperty2.default)(_TEXTURE_FORMATS, 6406, {
  dataFormat: 6406,
  types: [5121]
}), (0, _defineProperty2.default)(_TEXTURE_FORMATS, 6409, {
  dataFormat: 6409,
  types: [5121]
}), (0, _defineProperty2.default)(_TEXTURE_FORMATS, 6410, {
  dataFormat: 6410,
  types: [5121]
}), (0, _defineProperty2.default)(_TEXTURE_FORMATS, 33326, {
  dataFormat: 6403,
  types: [5126],
  gl2: true
}), (0, _defineProperty2.default)(_TEXTURE_FORMATS, 33328, {
  dataFormat: 33319,
  types: [5126],
  gl2: true
}), (0, _defineProperty2.default)(_TEXTURE_FORMATS, 34837, {
  dataFormat: 6407,
  types: [5126],
  gl2: true
}), (0, _defineProperty2.default)(_TEXTURE_FORMATS, 34836, {
  dataFormat: 6408,
  types: [5126],
  gl2: true
}), _TEXTURE_FORMATS);
exports.TEXTURE_FORMATS = TEXTURE_FORMATS;
var DATA_FORMAT_CHANNELS = (_DATA_FORMAT_CHANNELS = {}, (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 6403, 1), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 36244, 1), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 33319, 2), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 33320, 2), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 6407, 3), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 36248, 3), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 6408, 4), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 36249, 4), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 6402, 1), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 34041, 1), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 6406, 1), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 6409, 1), (0, _defineProperty2.default)(_DATA_FORMAT_CHANNELS, 6410, 2), _DATA_FORMAT_CHANNELS);
exports.DATA_FORMAT_CHANNELS = DATA_FORMAT_CHANNELS;
var TYPE_SIZES = (_TYPE_SIZES = {}, (0, _defineProperty2.default)(_TYPE_SIZES, 5126, 4), (0, _defineProperty2.default)(_TYPE_SIZES, 5125, 4), (0, _defineProperty2.default)(_TYPE_SIZES, 5124, 4), (0, _defineProperty2.default)(_TYPE_SIZES, 5123, 2), (0, _defineProperty2.default)(_TYPE_SIZES, 5122, 2), (0, _defineProperty2.default)(_TYPE_SIZES, 5131, 2), (0, _defineProperty2.default)(_TYPE_SIZES, 5120, 1), (0, _defineProperty2.default)(_TYPE_SIZES, 5121, 1), _TYPE_SIZES);
exports.TYPE_SIZES = TYPE_SIZES;

function isFormatSupported(gl, format) {
  var info = TEXTURE_FORMATS[format];

  if (!info) {
    return false;
  }

  if (info.gl1 === undefined && info.gl2 === undefined) {
    return true;
  }

  var value = (0, _webglUtils.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === 'string' ? gl.getExtension(value) : value;
}

function isLinearFilteringSupported(gl, format) {
  var info = TEXTURE_FORMATS[format];

  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension('OES_texture_float_linear');

    case 5131:
      return gl.getExtension('OES_texture_half_float_linear');

    default:
      return true;
  }
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/context/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.trackContextState;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.resetParameters;
  }
});
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.setParameter;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.setParameters;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.withParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getModifiedParameters;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _context.createGLContext;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function () {
    return _context.instrumentGLContext;
  }
});
Object.defineProperty(exports, "destroyGLContext", {
  enumerable: true,
  get: function () {
    return _context.destroyGLContext;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function () {
    return _context.resizeGLContext;
  }
});
Object.defineProperty(exports, "setGLContextDefaults", {
  enumerable: true,
  get: function () {
    return _context.setGLContextDefaults;
  }
});
Object.defineProperty(exports, "getPageLoadPromise", {
  enumerable: true,
  get: function () {
    return _createCanvas.getPageLoadPromise;
  }
});
Object.defineProperty(exports, "getCanvas", {
  enumerable: true,
  get: function () {
    return _createCanvas.getCanvas;
  }
});

var _webglStateTracker = require("@luma.gl/webgl-state-tracker");

var _context = require("./context");

var _createCanvas = require("./create-canvas");
},{"@luma.gl/webgl-state-tracker":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/index.js","./context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/context.js","./create-canvas":"../../../node_modules/@luma.gl/webgl/dist/esm/context/create-canvas.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _textureFormats = require("./texture-formats");

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NPOT_MIN_FILTERS = [9729, 9728];

var Texture = function (_Resource) {
  (0, _inherits2.default)(Texture, _Resource);
  (0, _createClass2.default)(Texture, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          format = _ref.format,
          linearFiltering = _ref.linearFiltering;

      var supported = true;

      if (format) {
        supported = supported && (0, _textureFormats.isFormatSupported)(gl, format);
        supported = supported && (!linearFiltering || (0, _textureFormats.isLinearFilteringSupported)(gl, format));
      }

      return supported;
    }
  }]);

  function Texture(gl, props) {
    var _this;

    (0, _classCallCheck2.default)(this, Texture);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('texture') : _props$id,
        handle = props.handle,
        target = props.target;
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Texture).call(this, gl, {
      id: id,
      handle: handle
    }));
    _this.target = target;
    _this.hasFloatTexture = gl.getExtension('OES_texture_float');
    _this.textureUnit = undefined;
    _this.loaded = false;
    _this.width = undefined;
    _this.height = undefined;
    _this.depth = undefined;
    _this.format = undefined;
    _this.type = undefined;
    _this.dataFormat = undefined;
    _this.border = undefined;
    _this.textureUnit = undefined;
    _this.mipmaps = undefined;
    return _this;
  }

  (0, _createClass2.default)(Texture, [{
    key: "toString",
    value: function toString() {
      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var data = props.data;

      if (data instanceof Promise) {
        data.then(function (resolvedImageData) {
          return _this2.initialize(Object.assign({}, props, {
            pixels: resolvedImageData,
            data: resolvedImageData
          }));
        });
        return this;
      }

      var _props$pixels = props.pixels,
          pixels = _props$pixels === void 0 ? null : _props$pixels,
          _props$format = props.format,
          format = _props$format === void 0 ? 6408 : _props$format,
          _props$type = props.type,
          type = _props$type === void 0 ? 5121 : _props$type,
          _props$border = props.border,
          border = _props$border === void 0 ? 0 : _props$border,
          _props$recreate = props.recreate,
          recreate = _props$recreate === void 0 ? false : _props$recreate,
          _props$parameters = props.parameters,
          parameters = _props$parameters === void 0 ? {} : _props$parameters,
          _props$pixelStore = props.pixelStore,
          pixelStore = _props$pixelStore === void 0 ? {} : _props$pixelStore,
          _props$textureUnit = props.textureUnit,
          textureUnit = _props$textureUnit === void 0 ? undefined : _props$textureUnit,
          _props$unpackFlipY = props.unpackFlipY,
          unpackFlipY = _props$unpackFlipY === void 0 ? true : _props$unpackFlipY;
      var _props$mipmaps = props.mipmaps,
          mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps;

      if (!data) {
        data = pixels;
      }

      var width = props.width,
          height = props.height,
          dataFormat = props.dataFormat;
      var _props$depth = props.depth,
          depth = _props$depth === void 0 ? 0 : _props$depth;

      var _this$_deduceParamete = this._deduceParameters({
        format: format,
        type: type,
        dataFormat: dataFormat,
        compressed: false,
        data: data,
        width: width,
        height: height
      });

      width = _this$_deduceParamete.width;
      height = _this$_deduceParamete.height;
      dataFormat = _this$_deduceParamete.dataFormat;
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.format = format;
      this.type = type;
      this.dataFormat = dataFormat;
      this.border = border;
      this.textureUnit = textureUnit;

      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }

      var DEFAULT_TEXTURE_SETTINGS = (0, _defineProperty2.default)({}, 37440, unpackFlipY);
      var glSettings = Object.assign({}, DEFAULT_TEXTURE_SETTINGS, pixelStore);

      if (mipmaps && this._isNPOT()) {
        _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();

        mipmaps = false;

        this._updateForNPOT(parameters);
      }

      this.mipmaps = mipmaps;
      this.setImageData({
        data: data,
        width: width,
        height: height,
        depth: depth,
        format: format,
        type: type,
        dataFormat: dataFormat,
        border: border,
        mipmaps: mipmaps,
        parameters: glSettings
      });

      if (mipmaps) {
        this.generateMipmap();
      }

      this.setParameters(parameters);

      if (recreate) {
        this.data = data;
      }

      return this;
    }
  }, {
    key: "resize",
    value: function resize(_ref2) {
      var width = _ref2.width,
          height = _ref2.height;

      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width: width,
          height: height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          border: this.border,
          mipmaps: false
        });
      }

      return this;
    }
  }, {
    key: "generateMipmap",
    value: function generateMipmap() {
      var _this3 = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.gl.bindTexture(this.target, this.handle);
      (0, _context.withParameters)(this.gl, params, function () {
        _this3.gl.generateMipmap(_this3.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
  }, {
    key: "setImageData",
    value: function setImageData(options) {
      this._trackDeallocatedMemory('Texture');

      var _options$target = options.target,
          target = _options$target === void 0 ? this.target : _options$target,
          _options$pixels = options.pixels,
          pixels = _options$pixels === void 0 ? null : _options$pixels,
          _options$level = options.level,
          level = _options$level === void 0 ? 0 : _options$level,
          _options$format = options.format,
          format = _options$format === void 0 ? this.format : _options$format,
          _options$border = options.border,
          border = _options$border === void 0 ? this.border : _options$border,
          _options$offset = options.offset,
          offset = _options$offset === void 0 ? 0 : _options$offset,
          _options$parameters = options.parameters,
          parameters = _options$parameters === void 0 ? {} : _options$parameters;
      var _options$data = options.data,
          data = _options$data === void 0 ? null : _options$data,
          _options$type = options.type,
          type = _options$type === void 0 ? this.type : _options$type,
          _options$width = options.width,
          width = _options$width === void 0 ? this.width : _options$width,
          _options$height = options.height,
          height = _options$height === void 0 ? this.height : _options$height,
          _options$dataFormat = options.dataFormat,
          dataFormat = _options$dataFormat === void 0 ? this.dataFormat : _options$dataFormat,
          _options$compressed = options.compressed,
          compressed = _options$compressed === void 0 ? false : _options$compressed;

      if (!data) {
        data = pixels;
      }

      var _this$_deduceParamete2 = this._deduceParameters({
        format: format,
        type: type,
        dataFormat: dataFormat,
        compressed: compressed,
        data: data,
        width: width,
        height: height
      });

      type = _this$_deduceParamete2.type;
      dataFormat = _this$_deduceParamete2.dataFormat;
      compressed = _this$_deduceParamete2.compressed;
      width = _this$_deduceParamete2.width;
      height = _this$_deduceParamete2.height;
      var gl = this.gl;
      gl.bindTexture(this.target, this.handle);
      var dataType = null;

      var _this$_getDataType = this._getDataType({
        data: data,
        compressed: compressed
      });

      data = _this$_getDataType.data;
      dataType = _this$_getDataType.dataType;
      (0, _context.withParameters)(this.gl, parameters, function () {
        switch (dataType) {
          case 'null':
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            break;

          case 'typed-array':
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
            break;

          case 'buffer':
            (0, _webglUtils.assertWebGL2Context)(gl);
            gl.bindBuffer(35052, data.handle || data);
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
            gl.bindBuffer(35052, null);
            break;

          case 'browser-object':
            if ((0, _webglUtils.isWebGL2)(gl)) {
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            } else {
              gl.texImage2D(target, level, format, dataFormat, type, data);
            }

            break;

          case 'compressed':
            gl.compressedTexImage2D(target, level, format, width, height, border, data);
            break;

          default:
            (0, _utils.assert)(false, 'Unknown image data type');
        }
      });

      if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, 'Texture');
      } else {
        var channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        var channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;

        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');
      }

      this.loaded = true;
      return this;
    }
  }, {
    key: "setSubImageData",
    value: function setSubImageData(_ref3) {
      var _this4 = this;

      var _ref3$target = _ref3.target,
          target = _ref3$target === void 0 ? this.target : _ref3$target,
          _ref3$pixels = _ref3.pixels,
          pixels = _ref3$pixels === void 0 ? null : _ref3$pixels,
          _ref3$data = _ref3.data,
          data = _ref3$data === void 0 ? null : _ref3$data,
          _ref3$x = _ref3.x,
          x = _ref3$x === void 0 ? 0 : _ref3$x,
          _ref3$y = _ref3.y,
          y = _ref3$y === void 0 ? 0 : _ref3$y,
          _ref3$width = _ref3.width,
          width = _ref3$width === void 0 ? this.width : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === void 0 ? this.height : _ref3$height,
          _ref3$level = _ref3.level,
          level = _ref3$level === void 0 ? 0 : _ref3$level,
          _ref3$format = _ref3.format,
          format = _ref3$format === void 0 ? this.format : _ref3$format,
          _ref3$type = _ref3.type,
          type = _ref3$type === void 0 ? this.type : _ref3$type,
          _ref3$dataFormat = _ref3.dataFormat,
          dataFormat = _ref3$dataFormat === void 0 ? this.dataFormat : _ref3$dataFormat,
          _ref3$compressed = _ref3.compressed,
          compressed = _ref3$compressed === void 0 ? false : _ref3$compressed,
          _ref3$offset = _ref3.offset,
          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
          _ref3$border = _ref3.border,
          border = _ref3$border === void 0 ? this.border : _ref3$border,
          _ref3$parameters = _ref3.parameters,
          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters;

      var _this$_deduceParamete3 = this._deduceParameters({
        format: format,
        type: type,
        dataFormat: dataFormat,
        compressed: compressed,
        data: data,
        width: width,
        height: height
      });

      type = _this$_deduceParamete3.type;
      dataFormat = _this$_deduceParamete3.dataFormat;
      compressed = _this$_deduceParamete3.compressed;
      width = _this$_deduceParamete3.width;
      height = _this$_deduceParamete3.height;
      (0, _utils.assert)(this.depth === 0, 'texSubImage not supported for 3D textures');

      if (!data) {
        data = pixels;
      }

      if (data && data.data) {
        var ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }

      if (data instanceof _buffer.default) {
        data = data.handle;
      }

      this.gl.bindTexture(this.target, this.handle);
      (0, _context.withParameters)(this.gl, parameters, function () {
        if (compressed) {
          _this4.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
        } else if (data === null) {
          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
        } else if (data instanceof _webglUtils.WebGLBuffer) {
          (0, _webglUtils.assertWebGL2Context)(_this4.gl);

          _this4.gl.bindBuffer(35052, data);

          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);

          _this4.gl.bindBuffer(35052, null);
        } else if ((0, _webglUtils.isWebGL2)(_this4.gl)) {
          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
        } else {
          _this4.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
  }, {
    key: "copyFramebuffer",
    value: function copyFramebuffer() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();

      return null;
    }
  }, {
    key: "getActiveUnit",
    value: function getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
  }, {
    key: "bind",
    value: function bind() {
      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
      var gl = this.gl;

      if (textureUnit !== undefined) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }

      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
      var gl = this.gl;

      if (textureUnit !== undefined) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }

      gl.bindTexture(this.target, null);
      return textureUnit;
    }
  }, {
    key: "_getDataType",
    value: function _getDataType(_ref4) {
      var data = _ref4.data,
          _ref4$compressed = _ref4.compressed,
          compressed = _ref4$compressed === void 0 ? false : _ref4$compressed;

      if (compressed) {
        return {
          data: data,
          dataType: 'compressed'
        };
      }

      if (data === null) {
        return {
          data: data,
          dataType: 'null'
        };
      }

      if (ArrayBuffer.isView(data)) {
        return {
          data: data,
          dataType: 'typed-array'
        };
      }

      if (data instanceof _buffer.default) {
        return {
          data: data.handle,
          dataType: 'buffer'
        };
      }

      if (data instanceof _webglUtils.WebGLBuffer) {
        return {
          data: data,
          dataType: 'buffer'
        };
      }

      return {
        data: data,
        dataType: 'browser-object'
      };
    }
  }, {
    key: "_deduceParameters",
    value: function _deduceParameters(opts) {
      var format = opts.format,
          data = opts.data;
      var width = opts.width,
          height = opts.height,
          dataFormat = opts.dataFormat,
          type = opts.type,
          compressed = opts.compressed;
      var textureFormat = _textureFormats.TEXTURE_FORMATS[format];
      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
      type = type || textureFormat && textureFormat.types[0];
      compressed = compressed || textureFormat && textureFormat.compressed;

      var _this$_deduceImageSiz = this._deduceImageSize(data, width, height);

      width = _this$_deduceImageSiz.width;
      height = _this$_deduceImageSiz.height;
      return {
        dataFormat: dataFormat,
        type: type,
        compressed: compressed,
        width: width,
        height: height,
        format: format,
        data: data
      };
    }
  }, {
    key: "_deduceImageSize",
    value: function _deduceImageSize(data, width, height) {
      var size;

      if (typeof ImageData !== 'undefined' && data instanceof ImageData) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
        size = {
          width: data.naturalWidth,
          height: data.naturalHeight
        };
      } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
        size = {
          width: data.videoWidth,
          height: data.videoHeight
        };
      } else if (!data) {
        size = {
          width: width >= 0 ? width : 1,
          height: height >= 0 ? height : 1
        };
      } else {
        size = {
          width: width,
          height: height
        };
      }

      (0, _utils.assert)(size, 'Could not deduced texture size');
      (0, _utils.assert)(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');
      (0, _utils.assert)(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');
      return size;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createTexture();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteTexture(this.handle);

      this._trackDeallocatedMemory('Texture');
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      switch (pname) {
        case 4096:
          return this.width;

        case 4097:
          return this.height;

        default:
          this.gl.bindTexture(this.target, this.handle);
          var value = this.gl.getTexParameter(this.target, pname);
          this.gl.bindTexture(this.target, null);
          return value;
      }
    }
  }, {
    key: "_setParameter",
    value: function _setParameter(pname, param) {
      this.gl.bindTexture(this.target, this.handle);
      param = this._getNPOTParam(pname, param);

      switch (pname) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.handle, pname, param);
          break;

        case 4096:
        case 4097:
          (0, _utils.assert)(false);
          break;

        default:
          this.gl.texParameteri(this.target, pname, param);
          break;
      }

      this.gl.bindTexture(this.target, null);
      return this;
    }
  }, {
    key: "_isNPOT",
    value: function _isNPOT() {
      if ((0, _webglUtils.isWebGL2)(this.gl)) {
        return false;
      }

      if (!this.width || !this.height) {
        return false;
      }

      return !(0, _utils.isPowerOfTwo)(this.width) || !(0, _utils.isPowerOfTwo)(this.height);
    }
  }, {
    key: "_updateForNPOT",
    value: function _updateForNPOT(parameters) {
      if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {
        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
      }

      if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {
        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
      }

      if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {
        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
      }
    }
  }, {
    key: "_getNPOTParam",
    value: function _getNPOTParam(pname, param) {
      if (this._isNPOT()) {
        switch (pname) {
          case 10241:
            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
              param = 9729;
            }

            break;

          case 10242:
          case 10243:
            if (param !== 33071) {
              param = 33071;
            }

            break;

          default:
            break;
        }
      }

      return param;
    }
  }]);
  return Texture;
}(_resource.default);

exports.default = Texture;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./texture-formats":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js","../context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/index.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setPathPrefix = setPathPrefix;
exports.loadFile = loadFile;
exports.loadImage = loadImage;

var _utils = require("../utils");

var pathPrefix = '';

function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function loadFile(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _utils.assert)(typeof url === 'string');
  url = pathPrefix + url;
  var dataType = options.dataType || 'text';
  return fetch(url, options).then(function (res) {
    return res[dataType]();
  });
}

function loadImage(url, opts) {
  (0, _utils.assert)(typeof url === 'string');
  url = pathPrefix + url;
  return new Promise(function (resolve, reject) {
    try {
      var image = new Image();

      image.onload = function () {
        return resolve(image);
      };

      image.onerror = function () {
        return reject(new Error("Could not load image ".concat(url, ".")));
      };

      image.crossOrigin = opts && opts.crossOrigin || 'anonymous';
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}
},{"../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _texture = _interopRequireDefault(require("./texture"));

var _webglUtils = require("../webgl-utils");

var _loadFile = require("../utils/load-file");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Texture2D = function (_Texture) {
  (0, _inherits2.default)(Texture2D, _Texture);
  (0, _createClass2.default)(Texture2D, null, [{
    key: "isSupported",
    value: function isSupported(gl, opts) {
      return _texture.default.isSupported(gl, opts);
    }
  }]);

  function Texture2D(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Texture2D);
    (0, _webglUtils.assertWebGLContext)(gl);

    if (props instanceof Promise || typeof props === 'string') {
      props = {
        data: props
      };
    }

    if (typeof props.data === 'string') {
      props = Object.assign({}, props, {
        data: (0, _loadFile.loadImage)(props.data)
      });
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Texture2D).call(this, gl, Object.assign({}, props, {
      target: 3553
    })));

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  return Texture2D;
}(_texture.default);

exports.default = Texture2D;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./texture":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils/load-file":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js"}],"../../../node_modules/regenerator-runtime/runtime.js":[function(require,module,exports) {
var global = arguments[3];
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);

},{}],"../../../node_modules/regenerator-runtime/runtime-module.js":[function(require,module,exports) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() {
  return this || (typeof self === "object" && self);
})() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":"../../../node_modules/regenerator-runtime/runtime.js"}],"../../../node_modules/@babel/runtime/regenerator/index.js":[function(require,module,exports) {
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":"../../../node_modules/regenerator-runtime/runtime-module.js"}],"../../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _asyncToGenerator;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _texture = _interopRequireDefault(require("./texture"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FACES = [34069, 34070, 34071, 34072, 34073, 34074];

var TextureCube = function (_Texture) {
  (0, _inherits2.default)(TextureCube, _Texture);

  function TextureCube(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TextureCube);
    (0, _webglUtils.assertWebGLContext)(gl);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TextureCube).call(this, gl, Object.assign({}, props, {
      target: 34067
    })));

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(TextureCube, [{
    key: "initialize",
    value: function initialize() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _props$mipmaps = props.mipmaps,
          mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps,
          _props$parameters = props.parameters,
          parameters = _props$parameters === void 0 ? {} : _props$parameters;
      this.opts = props;
      this.setCubeMapImageData(props).then(function () {
        _this2.loaded = true;

        if (mipmaps) {
          _this2.generateMipmap(props);
        }

        _this2.setParameters(parameters);
      });
    }
  }, {
    key: "subImage",
    value: function subImage(_ref) {
      var face = _ref.face,
          data = _ref.data,
          _ref$x = _ref.x,
          x = _ref$x === void 0 ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === void 0 ? 0 : _ref$y,
          _ref$mipmapLevel = _ref.mipmapLevel,
          mipmapLevel = _ref$mipmapLevel === void 0 ? 0 : _ref$mipmapLevel;
      return this._subImage({
        target: face,
        data: data,
        x: x,
        y: y,
        mipmapLevel: mipmapLevel
      });
    }
  }, {
    key: "setCubeMapImageData",
    value: function () {
      var _setCubeMapImageData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(_ref2) {
        var _this3 = this;

        var width, height, pixels, data, _ref2$border, border, _ref2$format, format, _ref2$type, type, gl, imageDataMap, resolvedFaces;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                width = _ref2.width, height = _ref2.height, pixels = _ref2.pixels, data = _ref2.data, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? 0 : _ref2$border, _ref2$format = _ref2.format, format = _ref2$format === void 0 ? 6408 : _ref2$format, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? 5121 : _ref2$type;
                gl = this.gl;
                imageDataMap = pixels || data;
                _context.next = 5;
                return Promise.all(FACES.map(function (face) {
                  var facePixels = imageDataMap[face];
                  return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
                }));

              case 5:
                resolvedFaces = _context.sent;
                this.bind();
                FACES.forEach(function (face, index) {
                  if (resolvedFaces[index].length > 1 && _this3.opts.mipmaps !== false) {
                    _utils.log.warn("".concat(_this3.id, " has mipmap and multiple LODs."))();
                  }

                  resolvedFaces[index].forEach(function (image, lodLevel) {
                    if (width && height) {
                      gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
                    } else {
                      gl.texImage2D(face, lodLevel, format, format, type, image);
                    }
                  });
                });
                this.unbind();

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setCubeMapImageData(_x) {
        return _setCubeMapImageData.apply(this, arguments);
      }

      return setCubeMapImageData;
    }()
  }, {
    key: "setImageDataForFace",
    value: function setImageDataForFace(options) {
      var _this4 = this;

      var face = options.face,
          width = options.width,
          height = options.height,
          pixels = options.pixels,
          data = options.data,
          _options$border = options.border,
          border = _options$border === void 0 ? 0 : _options$border,
          _options$format = options.format,
          format = _options$format === void 0 ? 6408 : _options$format,
          _options$type = options.type,
          type = _options$type === void 0 ? 5121 : _options$type;
      var gl = this.gl;
      var imageData = pixels || data;
      this.bind();

      if (imageData instanceof Promise) {
        imageData.then(function (resolvedImageData) {
          return _this4.setImageDataForFace(Object.assign({}, options, {
            face: face,
            data: resolvedImageData,
            pixels: resolvedImageData
          }));
        });
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }

      return this;
    }
  }]);
  return TextureCube;
}(_texture.default);

exports.default = TextureCube;
TextureCube.FACES = FACES;
},{"@babel/runtime/regenerator":"../../../node_modules/@babel/runtime/regenerator/index.js","@babel/runtime/helpers/esm/asyncToGenerator":"../../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./texture":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _texture = _interopRequireDefault(require("./texture"));

var _textureFormats = require("./texture-formats");

var _buffer = _interopRequireDefault(require("./buffer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Texture3D = function (_Texture) {
  (0, _inherits2.default)(Texture3D, _Texture);
  (0, _createClass2.default)(Texture3D, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      return (0, _webglUtils.isWebGL2)(gl);
    }
  }]);

  function Texture3D(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Texture3D);
    (0, _webglUtils.assertWebGL2Context)(gl);
    props = Object.assign({
      depth: 1
    }, props, {
      target: 32879,
      unpackFlipY: false
    });
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Texture3D).call(this, gl, props));

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(Texture3D, [{
    key: "setImageData",
    value: function setImageData(_ref) {
      var _this2 = this;

      var _ref$level = _ref.level,
          level = _ref$level === void 0 ? 0 : _ref$level,
          _ref$dataFormat = _ref.dataFormat,
          dataFormat = _ref$dataFormat === void 0 ? 6408 : _ref$dataFormat,
          width = _ref.width,
          height = _ref.height,
          _ref$depth = _ref.depth,
          depth = _ref$depth === void 0 ? 1 : _ref$depth,
          _ref$border = _ref.border,
          border = _ref$border === void 0 ? 0 : _ref$border,
          format = _ref.format,
          _ref$type = _ref.type,
          type = _ref$type === void 0 ? 5121 : _ref$type,
          _ref$offset = _ref.offset,
          offset = _ref$offset === void 0 ? 0 : _ref$offset,
          data = _ref.data,
          _ref$parameters = _ref.parameters,
          parameters = _ref$parameters === void 0 ? {} : _ref$parameters;

      this._trackDeallocatedMemory('Texture');

      this.gl.bindTexture(this.target, this.handle);
      (0, _context.withParameters)(this.gl, parameters, function () {
        if (ArrayBuffer.isView(data)) {
          _this2.gl.texImage3D(_this2.target, level, dataFormat, width, height, depth, border, format, type, data);
        }

        if (data instanceof _buffer.default) {
          _this2.gl.bindBuffer(35052, data.handle);

          _this2.gl.texImage3D(_this2.target, level, dataFormat, width, height, depth, border, format, type, offset);
        }
      });

      if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, 'Texture');
      } else {
        var channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        var channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;

        this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');
      }

      this.loaded = true;
      return this;
    }
  }]);
  return Texture3D;
}(_texture.default);

exports.default = Texture3D;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/index.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","./texture":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","./texture-formats":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js","./buffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _$33190$36012$;

var EXT_FLOAT_WEBGL2 = 'EXT_color_buffer_float';

var _default = (_$33190$36012$ = {}, (0, _defineProperty2.default)(_$33190$36012$, 33189, {
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 33190, {
  gl2: true,
  bpp: 3
}), (0, _defineProperty2.default)(_$33190$36012$, 36012, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 36168, {
  bpp: 1
}), (0, _defineProperty2.default)(_$33190$36012$, 34041, {
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 35056, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 36013, {
  gl2: true,
  bpp: 5
}), (0, _defineProperty2.default)(_$33190$36012$, 32854, {
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 36194, {
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 32855, {
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 33321, {
  gl2: true,
  bpp: 1
}), (0, _defineProperty2.default)(_$33190$36012$, 33330, {
  gl2: true,
  bpp: 1
}), (0, _defineProperty2.default)(_$33190$36012$, 33329, {
  gl2: true,
  bpp: 1
}), (0, _defineProperty2.default)(_$33190$36012$, 33332, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 33331, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 33334, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 33333, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 33323, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 33336, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 33335, {
  gl2: true,
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 33338, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 33337, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 33340, {
  gl2: true,
  bpp: 8
}), (0, _defineProperty2.default)(_$33190$36012$, 33339, {
  gl2: true,
  bpp: 8
}), (0, _defineProperty2.default)(_$33190$36012$, 32849, {
  gl2: true,
  bpp: 3
}), (0, _defineProperty2.default)(_$33190$36012$, 32856, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 32857, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 36220, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 36238, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 36975, {
  gl2: true,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 36214, {
  gl2: true,
  bpp: 8
}), (0, _defineProperty2.default)(_$33190$36012$, 36232, {
  gl2: true,
  bpp: 8
}), (0, _defineProperty2.default)(_$33190$36012$, 36226, {
  gl2: true,
  bpp: 16
}), (0, _defineProperty2.default)(_$33190$36012$, 36208, {
  gl2: true,
  bpp: 16
}), (0, _defineProperty2.default)(_$33190$36012$, 33325, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 2
}), (0, _defineProperty2.default)(_$33190$36012$, 33327, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 34842, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 8
}), (0, _defineProperty2.default)(_$33190$36012$, 33326, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 4
}), (0, _defineProperty2.default)(_$33190$36012$, 33328, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 8
}), (0, _defineProperty2.default)(_$33190$36012$, 34836, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 16
}), (0, _defineProperty2.default)(_$33190$36012$, 35898, {
  gl2: EXT_FLOAT_WEBGL2,
  bpp: 4
}), _$33190$36012$);

exports.default = _default;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _renderbufferFormats = _interopRequireDefault(require("./renderbuffer-formats"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFormatSupported(gl, format, formats) {
  var info = formats[format];

  if (!info) {
    return false;
  }

  var value = (0, _webglUtils.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;

  if (typeof value === 'string') {
    return gl.getExtension(value);
  }

  return value;
}

var Renderbuffer = function (_Resource) {
  (0, _inherits2.default)(Renderbuffer, _Resource);
  (0, _createClass2.default)(Renderbuffer, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          format = _ref.format;

      return !format || isFormatSupported(gl, format, _renderbufferFormats.default);
    }
  }, {
    key: "getSamplesForFormat",
    value: function getSamplesForFormat(gl, _ref2) {
      var format = _ref2.format;
      return gl.getInternalformatParameter(36161, format, 32937);
    }
  }]);

  function Renderbuffer(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Renderbuffer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Renderbuffer).call(this, gl, opts));

    _this.initialize(opts);

    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(Renderbuffer, [{
    key: "initialize",
    value: function initialize(_ref3) {
      var format = _ref3.format,
          _ref3$width = _ref3.width,
          width = _ref3$width === void 0 ? 1 : _ref3$width,
          _ref3$height = _ref3.height,
          height = _ref3$height === void 0 ? 1 : _ref3$height,
          _ref3$samples = _ref3.samples,
          samples = _ref3$samples === void 0 ? 0 : _ref3$samples;
      (0, _utils.assert)(format, 'Needs format');

      this._trackDeallocatedMemory();

      this.gl.bindRenderbuffer(36161, this.handle);

      if (samples !== 0 && (0, _webglUtils.isWebGL2)(this.gl)) {
        this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
      } else {
        this.gl.renderbufferStorage(36161, format, width, height);
      }

      this.format = format;
      this.width = width;
      this.height = height;
      this.samples = samples;

      this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * _renderbufferFormats.default[this.format].bpp);

      return this;
    }
  }, {
    key: "resize",
    value: function resize(_ref4) {
      var width = _ref4.width,
          height = _ref4.height;

      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width: width,
          height: height,
          format: this.format,
          samples: this.samples
        });
      }

      return this;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createRenderbuffer();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);

      this._trackDeallocatedMemory();
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161, handle);
    }
  }, {
    key: "_syncHandle",
    value: function _syncHandle(handle) {
      this.format = this.getParameter(36164);
      this.width = this.getParameter(36162);
      this.height = this.getParameter(36163);
      this.samples = this.getParameter(36011);
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      this.gl.bindRenderbuffer(36161, this.handle);
      var value = this.gl.getRenderbufferParameter(36161, pname);
      return value;
    }
  }]);
  return Renderbuffer;
}(_resource.default);

exports.default = Renderbuffer;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./renderbuffer-formats":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.clearBuffer = clearBuffer;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GL_DEPTH_BUFFER_BIT = 0x00000100;
var GL_STENCIL_BUFFER_BIT = 0x00000400;
var GL_COLOR_BUFFER_BIT = 0x00004000;
var GL_COLOR = 0x1800;
var GL_DEPTH = 0x1801;
var GL_STENCIL = 0x1802;
var GL_DEPTH_STENCIL = 0x84f9;
var ERR_ARGUMENTS = 'clear: bad arguments';

function clear(gl) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$framebuffer = _ref.framebuffer,
      framebuffer = _ref$framebuffer === void 0 ? null : _ref$framebuffer,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? null : _ref$color,
      _ref$depth = _ref.depth,
      depth = _ref$depth === void 0 ? null : _ref$depth,
      _ref$stencil = _ref.stencil,
      stencil = _ref$stencil === void 0 ? null : _ref$stencil;

  var parameters = {};

  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }

  var clearFlags = 0;

  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;

    if (color !== true) {
      parameters.clearColor = color;
    }
  }

  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;

    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }

  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;

    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }

  (0, _utils.assert)(clearFlags !== 0, ERR_ARGUMENTS);
  (0, _context.withParameters)(gl, parameters, function () {
    gl.clear(clearFlags);
  });
}

function clearBuffer(gl) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$framebuffer = _ref2.framebuffer,
      framebuffer = _ref2$framebuffer === void 0 ? null : _ref2$framebuffer,
      _ref2$buffer = _ref2.buffer,
      buffer = _ref2$buffer === void 0 ? GL_COLOR : _ref2$buffer,
      _ref2$drawBuffer = _ref2.drawBuffer,
      drawBuffer = _ref2$drawBuffer === void 0 ? 0 : _ref2$drawBuffer,
      _ref2$value = _ref2.value,
      value = _ref2$value === void 0 ? [0, 0, 0, 0] : _ref2$value;

  (0, _webglUtils.assertWebGL2Context)(gl);
  (0, _context.withParameters)(gl, {
    framebuffer: framebuffer
  }, function () {
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;

          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;

          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }

        break;

      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;

      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;

      case GL_DEPTH_STENCIL:
        var _value = (0, _slicedToArray2.default)(value, 2),
            depth = _value[0],
            stencil = _value[1];

        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;

      default:
        (0, _utils.assert)(false, ERR_ARGUMENTS);
    }
  });
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/index.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glFormatToComponents = glFormatToComponents;
exports.glTypeToBytes = glTypeToBytes;

var _utils = require("../utils");

function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;

    case 33328:
    case 33319:
      return 2;

    case 6407:
    case 34837:
      return 3;

    case 6408:
    case 34836:
      return 4;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;

    case 33635:
    case 32819:
    case 32820:
      return 2;

    case 5126:
      return 4;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}
},{"../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readPixelsToArray = readPixelsToArray;
exports.readPixelsToBuffer = readPixelsToBuffer;
exports.copyToDataUrl = copyToDataUrl;
exports.copyToImage = copyToImage;
exports.copyToTexture = copyToTexture;
exports.blit = blit;

var _buffer = _interopRequireDefault(require("./buffer"));

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _texture = _interopRequireDefault(require("./texture"));

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _typedArrayUtils = require("../webgl-utils/typed-array-utils");

var _formatUtils = require("../webgl-utils/format-utils");

var _textureUtils = require("../webgl-utils/texture-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readPixelsToArray(source) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$sourceX = _ref.sourceX,
      sourceX = _ref$sourceX === void 0 ? 0 : _ref$sourceX,
      _ref$sourceY = _ref.sourceY,
      sourceY = _ref$sourceY === void 0 ? 0 : _ref$sourceY,
      _ref$sourceFormat = _ref.sourceFormat,
      sourceFormat = _ref$sourceFormat === void 0 ? 6408 : _ref$sourceFormat,
      _ref$sourceAttachment = _ref.sourceAttachment,
      sourceAttachment = _ref$sourceAttachment === void 0 ? 36064 : _ref$sourceAttachment,
      _ref$target = _ref.target,
      target = _ref$target === void 0 ? null : _ref$target,
      sourceWidth = _ref.sourceWidth,
      sourceHeight = _ref.sourceHeight,
      sourceType = _ref.sourceType;

  var _getFramebuffer = getFramebuffer(source),
      framebuffer = _getFramebuffer.framebuffer,
      deleteFramebuffer = _getFramebuffer.deleteFramebuffer;

  (0, _utils.assert)(framebuffer);
  var gl = framebuffer.gl,
      handle = framebuffer.handle,
      attachments = framebuffer.attachments;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;

  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }

  (0, _utils.assert)(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || (0, _typedArrayUtils.getGLTypeFromTypedArray)(target);
  var prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);

  if (deleteFramebuffer) {
    framebuffer["delete"]();
  }

  return target;
}

function readPixelsToBuffer(source, _ref2) {
  var _ref2$sourceX = _ref2.sourceX,
      sourceX = _ref2$sourceX === void 0 ? 0 : _ref2$sourceX,
      _ref2$sourceY = _ref2.sourceY,
      sourceY = _ref2$sourceY === void 0 ? 0 : _ref2$sourceY,
      _ref2$sourceFormat = _ref2.sourceFormat,
      sourceFormat = _ref2$sourceFormat === void 0 ? 6408 : _ref2$sourceFormat,
      _ref2$target = _ref2.target,
      target = _ref2$target === void 0 ? null : _ref2$target,
      _ref2$targetByteOffse = _ref2.targetByteOffset,
      targetByteOffset = _ref2$targetByteOffse === void 0 ? 0 : _ref2$targetByteOffse,
      sourceWidth = _ref2.sourceWidth,
      sourceHeight = _ref2.sourceHeight,
      sourceType = _ref2.sourceType;

  var _getFramebuffer2 = getFramebuffer(source),
      framebuffer = _getFramebuffer2.framebuffer,
      deleteFramebuffer = _getFramebuffer2.deleteFramebuffer;

  (0, _utils.assert)(framebuffer);
  var gl = framebuffer.gl;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  (0, _webglUtils.assertWebGL2Context)(gl);
  sourceType = sourceType || (target ? target.type : 5121);

  if (!target) {
    var components = (0, _formatUtils.glFormatToComponents)(sourceFormat);
    var byteCount = (0, _formatUtils.glTypeToBytes)(sourceType);
    var byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new _buffer.default(gl, {
      byteLength: byteLength,
      accessor: {
        type: sourceType,
        size: components
      }
    });
  }

  target.bind({
    target: 35051
  });
  (0, _context.withParameters)(gl, {
    framebuffer: framebuffer
  }, function () {
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
  });
  target.unbind({
    target: 35051
  });

  if (deleteFramebuffer) {
    framebuffer["delete"]();
  }

  return target;
}

function copyToDataUrl(source) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$sourceAttachmen = _ref3.sourceAttachment,
      sourceAttachment = _ref3$sourceAttachmen === void 0 ? 36064 : _ref3$sourceAttachmen,
      _ref3$targetMaxHeight = _ref3.targetMaxHeight,
      targetMaxHeight = _ref3$targetMaxHeight === void 0 ? Number.MAX_SAFE_INTEGER : _ref3$targetMaxHeight;

  var data = readPixelsToArray(source, {
    sourceAttachment: sourceAttachment
  });
  var width = source.width,
      height = source.height;

  while (height > targetMaxHeight) {
    var _scalePixels = (0, _webglUtils.scalePixels)({
      data: data,
      width: width,
      height: height
    });

    data = _scalePixels.data;
    width = _scalePixels.width;
    height = _scalePixels.height;
  }

  (0, _webglUtils.flipRows)({
    data: data,
    width: width,
    height: height
  });
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  var context = canvas.getContext('2d');
  var imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}

function copyToImage(source) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$sourceAttachmen = _ref4.sourceAttachment,
      sourceAttachment = _ref4$sourceAttachmen === void 0 ? 36064 : _ref4$sourceAttachmen,
      _ref4$targetImage = _ref4.targetImage,
      targetImage = _ref4$targetImage === void 0 ? null : _ref4$targetImage;

  var dataUrl = copyToDataUrl(source, {
    sourceAttachment: sourceAttachment
  });
  targetImage = targetImage || new Image();
  targetImage.src = dataUrl;
  return targetImage;
}

function copyToTexture(source, target) {
  var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref5$sourceX = _ref5.sourceX,
      sourceX = _ref5$sourceX === void 0 ? 0 : _ref5$sourceX,
      _ref5$sourceY = _ref5.sourceY,
      sourceY = _ref5$sourceY === void 0 ? 0 : _ref5$sourceY,
      targetX = _ref5.targetX,
      targetY = _ref5.targetY,
      targetZ = _ref5.targetZ,
      _ref5$targetMipmaplev = _ref5.targetMipmaplevel,
      targetMipmaplevel = _ref5$targetMipmaplev === void 0 ? 0 : _ref5$targetMipmaplev,
      _ref5$targetInternalF = _ref5.targetInternalFormat,
      targetInternalFormat = _ref5$targetInternalF === void 0 ? 6408 : _ref5$targetInternalF,
      width = _ref5.width,
      height = _ref5.height;

  var _getFramebuffer3 = getFramebuffer(source),
      framebuffer = _getFramebuffer3.framebuffer,
      deleteFramebuffer = _getFramebuffer3.deleteFramebuffer;

  (0, _utils.assert)(framebuffer);
  var gl = framebuffer.gl,
      handle = framebuffer.handle;
  var isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  var prevHandle = gl.bindFramebuffer(36160, handle);
  (0, _utils.assert)(target);
  var texture = null;

  if (target instanceof _texture.default) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }

  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;

      case 35866:
      case 32879:
        gl.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;

      default:
    }
  }

  if (texture) {
    texture.unbind();
  }

  gl.bindFramebuffer(36160, prevHandle || null);

  if (deleteFramebuffer) {
    framebuffer["delete"]();
  }

  return texture;
}

function blit(source, target) {
  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref6$sourceAttachmen = _ref6.sourceAttachment,
      sourceAttachment = _ref6$sourceAttachmen === void 0 ? 36064 : _ref6$sourceAttachmen,
      _ref6$sourceX = _ref6.sourceX0,
      sourceX0 = _ref6$sourceX === void 0 ? 0 : _ref6$sourceX,
      _ref6$sourceY = _ref6.sourceY0,
      sourceY0 = _ref6$sourceY === void 0 ? 0 : _ref6$sourceY,
      sourceX1 = _ref6.sourceX1,
      sourceY1 = _ref6.sourceY1,
      _ref6$targetX = _ref6.targetX0,
      targetX0 = _ref6$targetX === void 0 ? 0 : _ref6$targetX,
      _ref6$targetY = _ref6.targetY0,
      targetY0 = _ref6$targetY === void 0 ? 0 : _ref6$targetY,
      targetX1 = _ref6.targetX1,
      targetY1 = _ref6.targetY1,
      _ref6$color = _ref6.color,
      color = _ref6$color === void 0 ? true : _ref6$color,
      _ref6$depth = _ref6.depth,
      depth = _ref6$depth === void 0 ? false : _ref6$depth,
      _ref6$stencil = _ref6.stencil,
      stencil = _ref6$stencil === void 0 ? false : _ref6$stencil,
      _ref6$mask = _ref6.mask,
      mask = _ref6$mask === void 0 ? 0 : _ref6$mask,
      _ref6$filter = _ref6.filter,
      filter = _ref6$filter === void 0 ? 9728 : _ref6$filter;

  var _getFramebuffer4 = getFramebuffer(source),
      srcFramebuffer = _getFramebuffer4.framebuffer,
      deleteSrcFramebuffer = _getFramebuffer4.deleteFramebuffer;

  var _getFramebuffer5 = getFramebuffer(target),
      dstFramebuffer = _getFramebuffer5.framebuffer,
      deleteDstFramebuffer = _getFramebuffer5.deleteFramebuffer;

  (0, _utils.assert)(srcFramebuffer);
  (0, _utils.assert)(dstFramebuffer);
  var gl = dstFramebuffer.gl,
      handle = dstFramebuffer.handle,
      width = dstFramebuffer.width,
      height = dstFramebuffer.height,
      readBuffer = dstFramebuffer.readBuffer;
  (0, _webglUtils.assertWebGL2Context)(gl);

  if (!srcFramebuffer.handle && sourceAttachment === 36064) {
    sourceAttachment = 1028;
  }

  if (color) {
    mask |= 16384;
  }

  if (depth) {
    mask |= 256;
  }

  if (stencil) {
    mask |= 1024;
  }

  if (deleteSrcFramebuffer || deleteDstFramebuffer) {
    if (mask & (256 | 1024)) {
      mask = 16384;

      _utils.log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();
    }
  }

  (0, _utils.assert)(mask);
  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
  targetX1 = targetX1 === undefined ? width : targetX1;
  targetY1 = targetY1 === undefined ? height : targetY1;
  var prevDrawHandle = gl.bindFramebuffer(36009, handle);
  var prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
  gl.readBuffer(sourceAttachment);
  gl.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);
  gl.readBuffer(readBuffer);
  gl.bindFramebuffer(36008, prevReadHandle || null);
  gl.bindFramebuffer(36009, prevDrawHandle || null);

  if (deleteSrcFramebuffer) {
    srcFramebuffer["delete"]();
  }

  if (deleteDstFramebuffer) {
    dstFramebuffer["delete"]();
  }

  return dstFramebuffer;
}

function getFramebuffer(source) {
  if (!(source instanceof _framebuffer.default)) {
    return {
      framebuffer: (0, _textureUtils.toFramebuffer)(source),
      deleteFramebuffer: true
    };
  }

  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}

function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }

  type = type || 5121;
  var ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(type, {
    clamped: false
  });
  var components = (0, _formatUtils.glFormatToComponents)(format);
  return new ArrayType(width * height * components);
}
},{"./buffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./framebuffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./texture":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/index.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../webgl-utils/typed-array-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","../webgl-utils/format-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js","../webgl-utils/texture-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _$33901$3379$;

var _default = (_$33901$3379$ = {}, (0, _defineProperty2.default)(_$33901$3379$, 33902, {
  gl1: new Float32Array([1, 1])
}), (0, _defineProperty2.default)(_$33901$3379$, 33901, {
  gl1: new Float32Array([1, 1])
}), (0, _defineProperty2.default)(_$33901$3379$, 3379, {
  gl1: 64,
  gl2: 2048
}), (0, _defineProperty2.default)(_$33901$3379$, 34076, {
  gl1: 16
}), (0, _defineProperty2.default)(_$33901$3379$, 34930, {
  gl1: 8
}), (0, _defineProperty2.default)(_$33901$3379$, 35661, {
  gl1: 8
}), (0, _defineProperty2.default)(_$33901$3379$, 35660, {
  gl1: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 34024, {
  gl1: 1
}), (0, _defineProperty2.default)(_$33901$3379$, 36348, {
  gl1: 8
}), (0, _defineProperty2.default)(_$33901$3379$, 34921, {
  gl1: 8
}), (0, _defineProperty2.default)(_$33901$3379$, 36347, {
  gl1: 128
}), (0, _defineProperty2.default)(_$33901$3379$, 36349, {
  gl1: 16
}), (0, _defineProperty2.default)(_$33901$3379$, 3386, {
  gl1: new Int32Array([0, 0])
}), (0, _defineProperty2.default)(_$33901$3379$, 32883, {
  gl1: 0,
  gl2: 256
}), (0, _defineProperty2.default)(_$33901$3379$, 35071, {
  gl1: 0,
  gl2: 256
}), (0, _defineProperty2.default)(_$33901$3379$, 37447, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 36063, {
  gl1: 0,
  gl2: 4
}), (0, _defineProperty2.default)(_$33901$3379$, 35379, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35374, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35377, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 34852, {
  gl1: 0,
  gl2: 4
}), (0, _defineProperty2.default)(_$33901$3379$, 36203, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 33001, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 33000, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 37157, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35373, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35657, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 36183, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 37137, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 34045, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35978, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35979, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35968, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35376, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35375, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35659, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 37154, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35371, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35658, {
  gl1: 0,
  gl2: 0
}), (0, _defineProperty2.default)(_$33901$3379$, 35076, {
  gl1: 0,
  gl2: -8,
  negative: true
}), (0, _defineProperty2.default)(_$33901$3379$, 35077, {
  gl1: 0,
  gl2: 7
}), (0, _defineProperty2.default)(_$33901$3379$, 35380, {
  gl1: 0,
  gl2: 0
}), _$33901$3379$);

exports.default = _default;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/features/limits.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextLimits = getContextLimits;
exports.getGLContextInfo = getGLContextInfo;
exports.getContextInfo = getContextInfo;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _webglUtils = require("../webgl-utils");

var _webglLimitsTable = _interopRequireDefault(require("./webgl-limits-table"));

var _getContextDebugInfo = require("../debug/get-context-debug-info");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getContextLimits(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.limits) {
    gl.luma.limits = {};
    gl.luma.webgl1MinLimits = {};
    gl.luma.webgl2MinLimits = {};
    var isWebgl2 = (0, _webglUtils.isWebGL2)(gl);

    for (var parameter in _webglLimitsTable.default) {
      var limit = _webglLimitsTable.default[parameter];
      var webgl1MinLimit = limit.gl1;
      var webgl2MinLimit = 'gl2' in limit ? limit.gl2 : limit.gl1;
      var minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit;
      var limitNotAvailable = 'gl2' in limit && !isWebgl2 || 'extension' in limit && !gl.getExtension(limit.extension);
      var value = limitNotAvailable ? minLimit : gl.getParameter(parameter);
      gl.luma.limits[parameter] = value;
      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
    }
  }

  return gl.luma.limits;
}

function getGLContextInfo(gl) {
  gl.luma = gl.luma || {};
  var info = (0, _getContextDebugInfo.getContextDebugInfo)(gl);

  if (!gl.luma.info) {
    var _gl$luma$info;

    gl.luma.info = (_gl$luma$info = {}, (0, _defineProperty2.default)(_gl$luma$info, 37445, info.vendor), (0, _defineProperty2.default)(_gl$luma$info, 37446, info.renderer), (0, _defineProperty2.default)(_gl$luma$info, 7936, info.vendorMasked), (0, _defineProperty2.default)(_gl$luma$info, 7937, info.rendererMasked), (0, _defineProperty2.default)(_gl$luma$info, 7938, info.version), (0, _defineProperty2.default)(_gl$luma$info, 35724, info.shadingLanguageVersion), _gl$luma$info);
  }

  return gl.luma.info;
}

function getContextInfo(gl) {
  return Object.assign((0, _getContextDebugInfo.getContextDebugInfo)(gl), {
    limits: getContextLimits(gl),
    info: getGLContextInfo(gl),
    webgl1MinLimits: gl.luma.webgl1MinLimits,
    webgl2MinLimits: gl.luma.webgl2MinLimits
  });
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","./webgl-limits-table":"../../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js","../debug/get-context-debug-info":"../../../node_modules/@luma.gl/webgl/dist/esm/debug/get-context-debug-info.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FEATURES = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _webglUtils = require("../webgl-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _FEATURES$WEBGL2$FEAT;

var FEATURES = {
  WEBGL2: 'WEBGL2',
  VERTEX_ARRAY_OBJECT: 'VERTEX_ARRAY_OBJECT',
  TIMER_QUERY: 'TIMER_QUERY',
  INSTANCED_RENDERING: 'INSTANCED_RENDERING',
  MULTIPLE_RENDER_TARGETS: 'MULTIPLE_RENDER_TARGETS',
  ELEMENT_INDEX_UINT32: 'ELEMENT_INDEX_UINT32',
  BLEND_EQUATION_MINMAX: 'BLEND_EQUATION_MINMAX',
  COLOR_ENCODING_SRGB: 'COLOR_ENCODING_SRGB',
  TEXTURE_DEPTH: 'TEXTURE_DEPTH',
  TEXTURE_FLOAT: 'TEXTURE_FLOAT',
  TEXTURE_HALF_FLOAT: 'TEXTURE_HALF_FLOAT',
  TEXTURE_FILTER_LINEAR_FLOAT: 'TEXTURE_FILTER_LINEAR_FLOAT',
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: 'TEXTURE_FILTER_LINEAR_HALF_FLOAT',
  TEXTURE_FILTER_ANISOTROPIC: 'TEXTURE_FILTER_ANISOTROPIC',
  COLOR_ATTACHMENT_RGBA32F: 'COLOR_ATTACHMENT_RGBA32F',
  COLOR_ATTACHMENT_FLOAT: 'COLOR_ATTACHMENT_FLOAT',
  COLOR_ATTACHMENT_HALF_FLOAT: 'COLOR_ATTACHMENT_HALF_FLOAT',
  GLSL_FRAG_DATA: 'GLSL_FRAG_DATA',
  GLSL_FRAG_DEPTH: 'GLSL_FRAG_DEPTH',
  GLSL_DERIVATIVES: 'GLSL_DERIVATIVES',
  GLSL_TEXTURE_LOD: 'GLSL_TEXTURE_LOD'
};
exports.FEATURES = FEATURES;

var _default = (_FEATURES$WEBGL2$FEAT = {}, (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.WEBGL2, [function (gl) {
  return (0, _webglUtils.isWebGL2)(gl);
}]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.VERTEX_ARRAY_OBJECT, ['OES_vertex_array_object', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.TIMER_QUERY, ['EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2']), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.INSTANCED_RENDERING, ['ANGLE_instanced_arrays', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.MULTIPLE_RENDER_TARGETS, ['WEBGL_draw_buffers', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.ELEMENT_INDEX_UINT32, ['OES_element_index_uint', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.BLEND_EQUATION_MINMAX, ['EXT_blend_minmax', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ENCODING_SRGB, ['EXT_sRGB', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_DEPTH, ['WEBGL_depth_texture', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FLOAT, ['OES_texture_float', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_HALF_FLOAT, ['OES_texture_half_float', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_LINEAR_FLOAT, ['OES_texture_float_linear']), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT, ['OES_texture_half_float_linear']), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.TEXTURE_FILTER_ANISOTROPIC, ['EXT_texture_filter_anisotropic']), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_RGBA32F, ['WEBGL_color_buffer_float', 'EXT_color_buffer_float']), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_FLOAT, [false, 'EXT_color_buffer_float']), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.COLOR_ATTACHMENT_HALF_FLOAT, [false, 'EXT_color_buffer_half_float']), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_FRAG_DATA, ['WEBGL_draw_buffers', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_FRAG_DEPTH, ['EXT_frag_depth', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_DERIVATIVES, ['OES_standard_derivatives', true]), (0, _defineProperty2.default)(_FEATURES$WEBGL2$FEAT, FEATURES.GLSL_TEXTURE_LOD, ['EXT_shader_texture_lod', true]), _FEATURES$WEBGL2$FEAT);

exports.default = _default;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/features/features.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasFeature = hasFeature;
exports.hasFeatures = hasFeatures;
exports.getFeatures = getFeatures;

var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}

function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(function (feature) {
    return isFeatureSupported(gl, feature);
  });
}

function getFeatures(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.caps) {
    gl.luma.caps = {};
    gl.luma.caps.webgl2 = (0, _webglUtils.isWebGL2)(gl);

    for (var cap in _webglFeaturesTable.default) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }

  return gl.luma.caps;
}

function isFeatureSupported(gl, cap) {
  var feature = _webglFeaturesTable.default[cap];
  (0, _utils.assert)(feature, cap);
  var featureDefinition = (0, _webglUtils.isWebGL2)(gl) ? feature[1] || feature[0] : feature[0];
  var isSupported;

  if (typeof featureDefinition === 'function') {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = featureDefinition[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var extension = _step.value;
        isSupported = isSupported && Boolean(gl.getExtension(extension));
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (typeof featureDefinition === 'string') {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === 'boolean') {
    isSupported = featureDefinition;
  } else {
    (0, _utils.assert)(false);
  }

  return isSupported;
}
},{"./webgl-features-table":"../../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;

function isOldIE() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var navigator = typeof window !== 'undefined' && window.navigator || {};
  var userAgent = opts.userAgent || navigator.userAgent || '';
  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = canCompileGLGSExtension;

var _checkOldIe = _interopRequireDefault(require("./check-old-ie"));

var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var compiledGlslExtensions = {};

function canCompileGLGSExtension(gl, cap) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var feature = _webglFeaturesTable.default[cap];
  (0, _utils.assert)(feature, cap);

  if (!(0, _checkOldIe.default)(options)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  var extensionName = feature[0];
  var source = "#extension GL_".concat(extensionName, " : enable\nvoid main(void) {}");
  var shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
},{"./check-old-ie":"../../../node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js","./webgl-features-table":"../../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/features/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _features.hasFeatures;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _checkGlslExtension.default;
  }
});

var _limits = require("./limits");

var _webglFeaturesTable = require("./webgl-features-table");

var _features = require("./features");

var _checkGlslExtension = _interopRequireDefault(require("./check-glsl-extension"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./limits":"../../../node_modules/@luma.gl/webgl/dist/esm/features/limits.js","./webgl-features-table":"../../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","./features":"../../../node_modules/@luma.gl/webgl/dist/esm/features/features.js","./check-glsl-extension":"../../../node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _texture2d = _interopRequireDefault(require("./texture-2d"));

var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));

var _clear2 = require("./clear");

var _copyAndBlit = require("./copy-and-blit.js");

var _features = require("../features");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';

var Framebuffer = function (_Resource) {
  (0, _inherits2.default)(Framebuffer, _Resource);
  (0, _createClass2.default)(Framebuffer, [{
    key: "MAX_COLOR_ATTACHMENTS",
    get: function get() {
      return this.gl.getParameter(this.gl.MAX_COLOR_ATTACHMENTS);
    }
  }, {
    key: "MAX_DRAW_BUFFERS",
    get: function get() {
      return this.gl.getParameter(this.gl.MAX_DRAW_BUFFERS);
    }
  }], [{
    key: "isSupported",
    value: function isSupported(gl) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          colorBufferFloat = _ref.colorBufferFloat,
          colorBufferHalfFloat = _ref.colorBufferHalfFloat;

      var supported = true;
      supported = colorBufferFloat && gl.getExtension((0, _webglUtils.isWebGL2)(gl) ? 'EXT_color_buffer_float' : 'WEBGL.color_buffer_float');
      supported = colorBufferHalfFloat && gl.getExtension((0, _webglUtils.isWebGL2)(gl) ? 'EXT_color_buffer_float' : 'EXT_color_buffer_half_float');
      return supported;
    }
  }, {
    key: "getDefaultFramebuffer",
    value: function getDefaultFramebuffer(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
        id: 'default-framebuffer',
        handle: null,
        attachments: {}
      });
      return gl.luma.defaultFramebuffer;
    }
  }]);

  function Framebuffer(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Framebuffer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Framebuffer).call(this, gl, opts));
    _this.width = null;
    _this.height = null;
    _this.attachments = {};
    _this.readBuffer = 36064;
    _this.drawBuffers = [36064];

    _this.initialize(opts);

    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(Framebuffer, [{
    key: "initialize",
    value: function initialize(_ref2) {
      var _ref2$width = _ref2.width,
          width = _ref2$width === void 0 ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === void 0 ? 1 : _ref2$height,
          _ref2$attachments = _ref2.attachments,
          attachments = _ref2$attachments === void 0 ? null : _ref2$attachments,
          _ref2$color = _ref2.color,
          color = _ref2$color === void 0 ? true : _ref2$color,
          _ref2$depth = _ref2.depth,
          depth = _ref2$depth === void 0 ? true : _ref2$depth,
          _ref2$stencil = _ref2.stencil,
          stencil = _ref2$stencil === void 0 ? false : _ref2$stencil,
          _ref2$check = _ref2.check,
          check = _ref2$check === void 0 ? true : _ref2$check,
          readBuffer = _ref2.readBuffer,
          drawBuffers = _ref2.drawBuffers;
      (0, _utils.assert)(width >= 0 && height >= 0, 'Width and height need to be integers');
      this.width = width;
      this.height = height;

      if (attachments) {
        for (var attachment in attachments) {
          var target = attachments[attachment];
          var object = Array.isArray(target) ? target[0] : target;
          object.resize({
            width: width,
            height: height
          });
        }
      } else {
        attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
      }

      this.update({
        clearAttachments: true,
        attachments: attachments,
        readBuffer: readBuffer,
        drawBuffers: drawBuffers
      });

      if (attachments && check) {
        this.checkStatus();
      }
    }
  }, {
    key: "update",
    value: function update(_ref3) {
      var _ref3$attachments = _ref3.attachments,
          attachments = _ref3$attachments === void 0 ? {} : _ref3$attachments,
          readBuffer = _ref3.readBuffer,
          drawBuffers = _ref3.drawBuffers,
          _ref3$clearAttachment = _ref3.clearAttachments,
          clearAttachments = _ref3$clearAttachment === void 0 ? false : _ref3$clearAttachment,
          _ref3$resizeAttachmen = _ref3.resizeAttachments,
          resizeAttachments = _ref3$resizeAttachmen === void 0 ? true : _ref3$resizeAttachmen;
      this.attach(attachments, {
        clearAttachments: clearAttachments,
        resizeAttachments: resizeAttachments
      });
      var gl = this.gl;
      var prevHandle = gl.bindFramebuffer(36160, this.handle);

      if (readBuffer) {
        this._setReadBuffer(readBuffer);
      }

      if (drawBuffers) {
        this._setDrawBuffers(drawBuffers);
      }

      gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
  }, {
    key: "resize",
    value: function resize() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          width = _ref4.width,
          height = _ref4.height;

      if (this.handle === null) {
        (0, _utils.assert)(width === undefined && height === undefined);
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }

      if (width === undefined) {
        width = this.gl.drawingBufferWidth;
      }

      if (height === undefined) {
        height = this.gl.drawingBufferHeight;
      }

      if (width !== this.width && height !== this.height) {
        _utils.log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
      }

      for (var attachmentPoint in this.attachments) {
        this.attachments[attachmentPoint].resize({
          width: width,
          height: height
        });
      }

      this.width = width;
      this.height = height;
      return this;
    }
  }, {
    key: "attach",
    value: function attach(attachments) {
      var _this2 = this;

      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$clearAttachment = _ref5.clearAttachments,
          clearAttachments = _ref5$clearAttachment === void 0 ? false : _ref5$clearAttachment,
          _ref5$resizeAttachmen = _ref5.resizeAttachments,
          resizeAttachments = _ref5$resizeAttachmen === void 0 ? true : _ref5$resizeAttachmen;

      var newAttachments = {};

      if (clearAttachments) {
        Object.keys(this.attachments).forEach(function (key) {
          newAttachments[key] = null;
        });
      }

      Object.assign(newAttachments, attachments);
      var prevHandle = this.gl.bindFramebuffer(36160, this.handle);

      for (var key in newAttachments) {
        (0, _utils.assert)(key !== undefined, 'Misspelled framebuffer binding point?');
        var attachment = Number(key);
        var descriptor = newAttachments[attachment];
        var object = descriptor;

        if (!object) {
          this._unattach(attachment);
        } else if (object instanceof _renderbuffer.default) {
          this._attachRenderbuffer({
            attachment: attachment,
            renderbuffer: object
          });
        } else if (Array.isArray(descriptor)) {
          var _descriptor = (0, _slicedToArray2.default)(descriptor, 3),
              texture = _descriptor[0],
              _descriptor$ = _descriptor[1],
              layer = _descriptor$ === void 0 ? 0 : _descriptor$,
              _descriptor$2 = _descriptor[2],
              level = _descriptor$2 === void 0 ? 0 : _descriptor$2;

          object = texture;

          this._attachTexture({
            attachment: attachment,
            texture: texture,
            layer: layer,
            level: level
          });
        } else {
          this._attachTexture({
            attachment: attachment,
            texture: object,
            layer: 0,
            level: 0
          });
        }

        if (resizeAttachments && object) {
          object.resize({
            width: this.width,
            height: this.height
          });
        }
      }

      this.gl.bindFramebuffer(36160, prevHandle || null);
      Object.assign(this.attachments, attachments);
      Object.keys(this.attachments).filter(function (key) {
        return !_this2.attachments[key];
      }).forEach(function (key) {
        delete _this2.attachments[key];
      });
    }
  }, {
    key: "checkStatus",
    value: function checkStatus() {
      var gl = this.gl;
      var prevHandle = gl.bindFramebuffer(36160, this.handle);
      var status = gl.checkFramebufferStatus(36160);
      gl.bindFramebuffer(36160, prevHandle || null);

      if (status !== 36053) {
        throw new Error(_getFrameBufferStatus(status));
      }

      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          color = _ref6.color,
          depth = _ref6.depth,
          stencil = _ref6.stencil,
          _ref6$drawBuffers = _ref6.drawBuffers,
          drawBuffers = _ref6$drawBuffers === void 0 ? [] : _ref6$drawBuffers;

      var prevHandle = this.gl.bindFramebuffer(36160, this.handle);

      if (color || depth || stencil) {
        (0, _clear2.clear)(this.gl, {
          color: color,
          depth: depth,
          stencil: stencil
        });
      }

      drawBuffers.forEach(function (value, drawBuffer) {
        (0, _clear2.clearBuffer)({
          drawBuffer: drawBuffer,
          value: value
        });
      });
      this.gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
  }, {
    key: "readPixels",
    value: function readPixels() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)')();

      return null;
    }
  }, {
    key: "readPixelsToBuffer",
    value: function readPixelsToBuffer() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)')();

      return null;
    }
  }, {
    key: "copyToDataUrl",
    value: function copyToDataUrl() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)')();

      return null;
    }
  }, {
    key: "copyToImage",
    value: function copyToImage() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();

      return null;
    }
  }, {
    key: "copyToTexture",
    value: function copyToTexture() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})')();

      return null;
    }
  }, {
    key: "blit",
    value: function blit() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();

      return null;
    }
  }, {
    key: "invalidate",
    value: function invalidate(_ref7) {
      var _ref7$attachments = _ref7.attachments,
          attachments = _ref7$attachments === void 0 ? [] : _ref7$attachments,
          _ref7$x = _ref7.x,
          x = _ref7$x === void 0 ? 0 : _ref7$x,
          _ref7$y = _ref7.y,
          y = _ref7$y === void 0 ? 0 : _ref7$y,
          width = _ref7.width,
          height = _ref7.height;
      var gl = this.gl;
      (0, _webglUtils.assertWebGL2Context)(gl);
      var prevHandle = gl.bindFramebuffer(36008, this.handle);
      var invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;

      if (invalidateAll) {
        gl.invalidateFramebuffer(36008, attachments);
      } else {
        gl.invalidateFramebuffer(36008, attachments, x, y, width, height);
      }

      gl.bindFramebuffer(36008, prevHandle);
      return this;
    }
  }, {
    key: "getAttachmentParameter",
    value: function getAttachmentParameter(attachment, pname, keys) {
      var value = this._getAttachmentParameterFallback(pname);

      if (value === null) {
        this.gl.bindFramebuffer(36160, this.handle);
        value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
        this.gl.bindFramebuffer(36160, null);
      }

      if (keys && value > 1000) {
        value = (0, _webglUtils.getKey)(this.gl, value);
      }

      return value;
    }
  }, {
    key: "getAttachmentParameters",
    value: function getAttachmentParameters() {
      var attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 36064;
      var keys = arguments.length > 1 ? arguments[1] : undefined;
      var parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
      var values = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = parameters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pname = _step.value;
          var key = keys ? (0, _webglUtils.getKey)(this.gl, pname) : pname;
          values[key] = this.getAttachmentParameter(attachment, pname, keys);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return values;
    }
  }, {
    key: "getParameters",
    value: function getParameters() {
      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var attachments = Object.keys(this.attachments);
      var parameters = {};

      for (var _i = 0, _attachments = attachments; _i < _attachments.length; _i++) {
        var attachmentName = _attachments[_i];
        var attachment = Number(attachmentName);
        var key = keys ? (0, _webglUtils.getKey)(this.gl, attachment) : attachment;
        parameters[key] = this.getAttachmentParameters(attachment, keys);
      }

      return parameters;
    }
  }, {
    key: "show",
    value: function show() {
      if (typeof window !== 'undefined') {
        window.open((0, _copyAndBlit.copyToDataUrl)(this), 'luma-debug-texture');
      }

      return this;
    }
  }, {
    key: "log",
    value: function log() {
      var priority = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      if (priority > _utils.log.priority || typeof window === 'undefined') {
        return this;
      }

      message = message || "Framebuffer ".concat(this.id);
      var image = (0, _copyAndBlit.copyToDataUrl)(this, {
        maxHeight: 100
      });

      _utils.log.image({
        priority: priority,
        message: message,
        image: image
      }, message)();

      return this;
    }
  }, {
    key: "bind",
    value: function bind() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$target = _ref8.target,
          target = _ref8$target === void 0 ? 36160 : _ref8$target;

      this.gl.bindFramebuffer(target, this.handle);
      return this;
    }
  }, {
    key: "unbind",
    value: function unbind() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$target = _ref9.target,
          target = _ref9$target === void 0 ? 36160 : _ref9$target;

      this.gl.bindFramebuffer(target, null);
      return this;
    }
  }, {
    key: "_createDefaultAttachments",
    value: function _createDefaultAttachments(color, depth, stencil, width, height) {
      var defaultAttachments = null;

      if (color) {
        var _parameters;

        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36064] = new _texture2d.default(this.gl, {
          id: "".concat(this.id, "-color0"),
          pixels: null,
          format: 6408,
          type: 5121,
          width: width,
          height: height,
          mipmaps: false,
          parameters: (_parameters = {}, (0, _defineProperty2.default)(_parameters, 10241, 9728), (0, _defineProperty2.default)(_parameters, 10240, 9728), (0, _defineProperty2.default)(_parameters, 10242, 33071), (0, _defineProperty2.default)(_parameters, 10243, 33071), _parameters)
        });
      }

      if (depth && stencil) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[33306] = new _renderbuffer.default(this.gl, {
          id: "".concat(this.id, "-depth-stencil"),
          format: 35056,
          width: width,
          height: 111
        });
      } else if (depth) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36096] = new _renderbuffer.default(this.gl, {
          id: "".concat(this.id, "-depth"),
          format: 33189,
          width: width,
          height: height
        });
      } else if (stencil) {
        (0, _utils.assert)(false);
      }

      return defaultAttachments;
    }
  }, {
    key: "_unattach",
    value: function _unattach(attachment) {
      var oldAttachment = this.attachments[attachment];

      if (!oldAttachment) {
        return;
      }

      if (oldAttachment instanceof _renderbuffer.default) {
        this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
      } else {
        this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
      }

      delete this.attachments[attachment];
    }
  }, {
    key: "_attachRenderbuffer",
    value: function _attachRenderbuffer(_ref10) {
      var _ref10$attachment = _ref10.attachment,
          attachment = _ref10$attachment === void 0 ? 36064 : _ref10$attachment,
          renderbuffer = _ref10.renderbuffer;
      var gl = this.gl;
      gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
      this.attachments[attachment] = renderbuffer;
    }
  }, {
    key: "_attachTexture",
    value: function _attachTexture(_ref11) {
      var _ref11$attachment = _ref11.attachment,
          attachment = _ref11$attachment === void 0 ? 36064 : _ref11$attachment,
          texture = _ref11.texture,
          layer = _ref11.layer,
          level = _ref11.level;
      var gl = this.gl;
      gl.bindTexture(texture.target, texture.handle);

      switch (texture.target) {
        case 35866:
        case 32879:
          gl.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;

        case 34067:
          var face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;

        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;

        default:
          (0, _utils.assert)(false, 'Illegal texture type');
      }

      gl.bindTexture(texture.target, null);
      this.attachments[attachment] = texture;
    }
  }, {
    key: "_setReadBuffer",
    value: function _setReadBuffer(readBuffer) {
      var gl = this.gl;

      if ((0, _webglUtils.isWebGL2)(gl)) {
        gl.readBuffer(readBuffer);
      } else {
        (0, _utils.assert)(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
      }

      this.readBuffer = readBuffer;
    }
  }, {
    key: "_setDrawBuffers",
    value: function _setDrawBuffers(drawBuffers) {
      var gl = this.gl;

      if ((0, _webglUtils.isWebGL2)(gl)) {
        gl.drawBuffers(drawBuffers);
      } else {
        var ext = gl.getExtension('WEBGL.draw_buffers');

        if (ext) {
          ext.drawBuffersWEBGL(drawBuffers);
        } else {
          (0, _utils.assert)(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
        }
      }

      this.drawBuffers = drawBuffers;
    }
  }, {
    key: "_getAttachmentParameterFallback",
    value: function _getAttachmentParameterFallback(pname) {
      var caps = (0, _features.getFeatures)(this.gl);

      switch (pname) {
        case 36052:
          return !caps.webgl2 ? 0 : null;

        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
          return !caps.webgl2 ? 8 : null;

        case 33297:
          return !caps.webgl2 ? 5125 : null;

        case 33296:
          return !caps.webgl2 && !caps.EXT_sRGB ? 9729 : null;

        default:
          return null;
      }
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createFramebuffer();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle(handle) {
      return this.gl.bindFramebuffer(36160, handle);
    }
  }, {
    key: "color",
    get: function get() {
      return this.attachments[36064] || null;
    }
  }, {
    key: "texture",
    get: function get() {
      return this.attachments[36064] || null;
    }
  }, {
    key: "depth",
    get: function get() {
      return this.attachments[36096] || this.attachments[33306] || null;
    }
  }, {
    key: "stencil",
    get: function get() {
      return this.attachments[36128] || this.attachments[33306] || null;
    }
  }]);
  return Framebuffer;
}(_resource.default);

exports.default = Framebuffer;

function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}

function _getFrameBufferStatus(status) {
  var STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || "Framebuffer error ".concat(status);
}

var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./texture-2d":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","./renderbuffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./clear":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js","./copy-and-blit.js":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js","../features":"../../../node_modules/@luma.gl/webgl/dist/esm/features/index.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneTextureFrom = cloneTextureFrom;
exports.toFramebuffer = toFramebuffer;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _texture2d = _interopRequireDefault(require("../classes/texture-2d"));

var _textureCube = _interopRequireDefault(require("../classes/texture-cube"));

var _texture3d = _interopRequireDefault(require("../classes/texture-3d"));

var _framebuffer = _interopRequireDefault(require("../classes/framebuffer"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneTextureFrom(refTexture, overrides) {
  (0, _utils.assert)(refTexture instanceof _texture2d.default || refTexture instanceof _textureCube.default || refTexture instanceof _texture3d.default);
  var TextureType = refTexture.constructor;
  var gl = refTexture.gl,
      width = refTexture.width,
      height = refTexture.height,
      format = refTexture.format,
      type = refTexture.type,
      dataFormat = refTexture.dataFormat,
      border = refTexture.border,
      mipmaps = refTexture.mipmaps;
  var textureOptions = Object.assign({
    width: width,
    height: height,
    format: format,
    type: type,
    dataFormat: dataFormat,
    border: border,
    mipmaps: mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}

function toFramebuffer(texture, opts) {
  var gl = texture.gl,
      width = texture.width,
      height = texture.height,
      id = texture.id;
  var framebuffer = new _framebuffer.default(gl, Object.assign({}, opts, {
    id: "framebuffer-for-".concat(id),
    width: width,
    height: height,
    attachments: (0, _defineProperty2.default)({}, 36064, texture)
  }));
  return framebuffer;
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../classes/texture-2d":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","../classes/texture-cube":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js","../classes/texture-3d":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js","../classes/framebuffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _webglTypes.Image;
  }
});
Object.defineProperty(exports, "WebGLRenderingContext", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLRenderingContext;
  }
});
Object.defineProperty(exports, "WebGL2RenderingContext", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGL2RenderingContext;
  }
});
Object.defineProperty(exports, "WebGLProgram", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLProgram;
  }
});
Object.defineProperty(exports, "WebGLShader", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLShader;
  }
});
Object.defineProperty(exports, "WebGLBuffer", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLBuffer;
  }
});
Object.defineProperty(exports, "WebGLFramebuffer", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLFramebuffer;
  }
});
Object.defineProperty(exports, "WebGLRenderbuffer", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLRenderbuffer;
  }
});
Object.defineProperty(exports, "WebGLTexture", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLTexture;
  }
});
Object.defineProperty(exports, "WebGLUniformLocation", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLUniformLocation;
  }
});
Object.defineProperty(exports, "WebGLActiveInfo", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLActiveInfo;
  }
});
Object.defineProperty(exports, "WebGLShaderPrecisionFormat", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLShaderPrecisionFormat;
  }
});
Object.defineProperty(exports, "webGLTypesAvailable", {
  enumerable: true,
  get: function () {
    return _webglTypes.webGLTypesAvailable;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL2;
  }
});
Object.defineProperty(exports, "assertWebGLContext", {
  enumerable: true,
  get: function () {
    return _webglChecks.assertWebGLContext;
  }
});
Object.defineProperty(exports, "assertWebGL2Context", {
  enumerable: true,
  get: function () {
    return _webglChecks.assertWebGL2Context;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "cancelAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.cancelAnimationFrame;
  }
});
Object.defineProperty(exports, "getGLTypeFromTypedArray", {
  enumerable: true,
  get: function () {
    return _typedArrayUtils.getGLTypeFromTypedArray;
  }
});
Object.defineProperty(exports, "getTypedArrayFromGLType", {
  enumerable: true,
  get: function () {
    return _typedArrayUtils.getTypedArrayFromGLType;
  }
});
Object.defineProperty(exports, "flipRows", {
  enumerable: true,
  get: function () {
    return _typedArrayUtils.flipRows;
  }
});
Object.defineProperty(exports, "scalePixels", {
  enumerable: true,
  get: function () {
    return _typedArrayUtils.scalePixels;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKeyValue;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKey;
  }
});
Object.defineProperty(exports, "getKeyType", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKeyType;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _textureUtils.cloneTextureFrom;
  }
});

var _webglTypes = require("./webgl-types");

var _webglChecks = require("./webgl-checks");

var _requestAnimationFrame = require("./request-animation-frame");

var _typedArrayUtils = require("./typed-array-utils");

var _constantsToKeys = require("./constants-to-keys");

var _textureUtils = require("./texture-utils");
},{"./webgl-types":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/webgl-types.js","./webgl-checks":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/webgl-checks.js","./request-animation-frame":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js","./typed-array-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","./constants-to-keys":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","./texture-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/context/context.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWebGL = isWebGL;
exports.isWebGL2 = isWebGL2;
exports.assertWebGLContext = assertWebGLContext;
exports.assertWebGL2Context = assertWebGL2Context;
exports.setGLContextDefaults = setGLContextDefaults;
exports.createGLContext = createGLContext;
exports.instrumentGLContext = instrumentGLContext;
exports.destroyGLContext = destroyGLContext;
exports.resizeGLContext = resizeGLContext;
exports.ERR_WEBGL2 = exports.ERR_WEBGL = exports.ERR_CONTEXT = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _webglStateTracker = require("@luma.gl/webgl-state-tracker");

var _createHeadlessContext = require("./create-headless-context");

var _createCanvas = require("./create-canvas");

var _createBrowserContext = require("./create-browser-context");

var _getContextDebugInfo = require("../debug/get-context-debug-info");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var _globals = require("../utils/globals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_CONTEXT = 'Invalid WebGLRenderingContext';
exports.ERR_CONTEXT = ERR_CONTEXT;
var ERR_WEBGL = ERR_CONTEXT;
exports.ERR_WEBGL = ERR_WEBGL;
var ERR_WEBGL2 = 'Requires WebGL2';
exports.ERR_WEBGL2 = ERR_WEBGL2;

function isWebGL(gl) {
  return Boolean(gl && Number.isFinite(gl._version));
}

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function assertWebGLContext(gl) {
  (0, _utils.assert)(isWebGL(gl), ERR_CONTEXT);
}

function assertWebGL2Context(gl) {
  (0, _utils.assert)(isWebGL2(gl), ERR_WEBGL2);
}

var contextDefaults = {
  webgl2: true,
  webgl1: true,
  throwOnFailure: true,
  manageState: true,
  canvas: null,
  debug: false,
  width: 800,
  height: 600
};

function setGLContextDefaults() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  Object.assign(contextDefaults, {
    width: 1,
    height: 1
  }, options);
}

function createGLContext() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  options = Object.assign({}, contextDefaults, options);
  var _options = options,
      width = _options.width,
      height = _options.height;

  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }

    return null;
  }

  var gl;

  if (_utils.isBrowser) {
    var _options2 = options,
        canvas = _options2.canvas;
    var targetCanvas = (0, _createCanvas.getCanvas)({
      canvas: canvas,
      width: width,
      height: height,
      onError: onError
    });
    gl = (0, _createBrowserContext.createBrowserContext)(targetCanvas, options);
  } else {
    gl = (0, _createHeadlessContext.createHeadlessContext)((0, _objectSpread2.default)({}, options, {
      width: width,
      height: height,
      onError: onError
    }));
  }

  if (!gl) {
    return null;
  }

  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}

function instrumentGLContext(gl) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (gl._instrumented) {
    return gl;
  }

  gl._version = gl._version || getVersion(gl);
  options = Object.assign({}, contextDefaults, options);
  var _options3 = options,
      manageState = _options3.manageState,
      debug = _options3.debug;

  if (manageState) {
    (0, _webglStateTracker.trackContextState)(gl, {
      copyState: false,
      log: function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _utils.log.log.apply(_utils.log, [1].concat(args))();
      }
    });
  }

  if (_utils.isBrowser && debug) {
    if (!_globals.global.makeDebugContext) {
      _utils.log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = _globals.global.makeDebugContext(gl, {
        debug: debug
      });
      _utils.log.priority = Math.max(_utils.log.priority, 1);
    }
  }

  gl._instrumented = true;
  return gl;
}

function destroyGLContext(gl) {
  var ext = gl.getExtension('STACKGL_destroy_context');

  if (ext) {
    ext.destroy();
  }
}

function resizeGLContext(gl) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (gl.canvas) {
    var devicePixelRatio = options.useDevicePixels ? window.devicePixelRatio || 1 : 1;
    var width = "width" in options ? options.width : gl.canvas.clientWidth;
    var height = "height" in options ? options.height : gl.canvas.clientHeight;
    gl.canvas.width = width * devicePixelRatio;
    gl.canvas.height = height * devicePixelRatio;
    return;
  }

  var ext = gl.getExtension('STACKGL_resize_drawingbuffer');

  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}

function logInfo(gl) {
  var webGL = isWebGL2(gl) ? 'WebGL2' : 'WebGL1';
  var info = (0, _getContextDebugInfo.getContextDebugInfo)(gl);
  var driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : '';
  var debug = gl.debug ? ' debug' : '';

  _utils.log.once(1, "".concat(webGL).concat(debug, " context ").concat(driver))();
}

function getVersion(gl) {
  if (typeof _webglUtils.WebGL2RenderingContext !== 'undefined' && gl instanceof _webglUtils.WebGL2RenderingContext) {
    return 2;
  }

  return 1;
}
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@luma.gl/webgl-state-tracker":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/index.js","./create-headless-context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/create-headless-context.js","./create-canvas":"../../../node_modules/@luma.gl/webgl/dist/esm/context/create-canvas.js","./create-browser-context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/create-browser-context.js","../debug/get-context-debug-info":"../../../node_modules/@luma.gl/webgl/dist/esm/debug/get-context-debug-info.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js","../utils/globals":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/globals.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderName;

function getShaderName(shader) {
  var defaultName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unnamed';
  var SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  var match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderTypeName;
var GL_FRAGMENT_SHADER = 0x8b30;
var GL_VERTEX_SHADER = 0x8b31;

function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return 'fragment';

    case GL_VERTEX_SHADER:
      return 'vertex';

    default:
      return 'unknown type';
  }
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatGLSLCompilerError;
exports.parseGLSLCompilerError = parseGLSLCompilerError;

var _getShaderName = _interopRequireDefault(require("./get-shader-name"));

var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function formatGLSLCompilerError(errLog, src, shaderType) {
  var _parseGLSLCompilerErr = parseGLSLCompilerError(errLog, src, shaderType),
      shaderName = _parseGLSLCompilerErr.shaderName,
      errors = _parseGLSLCompilerErr.errors,
      warnings = _parseGLSLCompilerErr.warnings;

  return "GLSL compilation error in ".concat(shaderName, "\n\n").concat(errors, "\n").concat(warnings);
}

function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  var errorStrings = errLog.split(/\r?\n/);
  var errors = {};
  var warnings = {};
  var name = shaderName || (0, _getShaderName.default)(src) || '(unnamed)';
  var shaderDescription = "".concat((0, _getShaderTypeName.default)(shaderType), " shader ").concat(name);

  for (var i = 0; i < errorStrings.length; i++) {
    var errorString = errorStrings[i];

    if (errorString.length <= 1) {
      continue;
    }

    var segments = errorString.split(':');
    var type = segments[0];
    var line = parseInt(segments[2], 10);

    if (isNaN(line)) {
      throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
    }

    if (type !== 'WARNING') {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }

  var lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}

function formatErrors(errors, lines) {
  var message = '';

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];

    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }

    message += "".concat(line, "\n");

    if (errors[i + 1]) {
      var error = errors[i + 1];
      var segments = error.split(':', 3);
      var type = segments[0];
      var column = parseInt(segments[1], 10) || 0;
      var err = error.substring(segments.join(':').length + 1).trim();
      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
    }
  }

  return message;
}

function addLineNumbers(string) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';
  var lines = string.split(/\r?\n/);
  var maxDigits = String(lines.length + start - 1).length;
  return lines.map(function (line, i) {
    var lineNumber = i + start;
    var digits = String(lineNumber).length;
    var prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}

function padLeft(string, digits) {
  var result = '';

  for (var i = 0; i < digits; ++i) {
    result += ' ';
  }

  return "".concat(result).concat(string);
}
},{"./get-shader-name":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./get-shader-type-name":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderVersion;

function getShaderVersion(source) {
  var version = 100;
  var words = source.match(/[^\s]+/g);

  if (words.length >= 2 && words[0] === '#version') {
    var v = parseInt(words[1], 10);

    if (Number.isFinite(v)) {
      version = v;
    }
  }

  return version;
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "formatGLSLCompilerError", {
  enumerable: true,
  get: function () {
    return _formatGlslError.default;
  }
});
Object.defineProperty(exports, "parseGLSLCompilerError", {
  enumerable: true,
  get: function () {
    return _formatGlslError.parseGLSLCompilerError;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function () {
    return _getShaderName.default;
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function () {
    return _getShaderVersion.default;
  }
});
Object.defineProperty(exports, "getShaderTypeName", {
  enumerable: true,
  get: function () {
    return _getShaderTypeName.default;
  }
});

var _formatGlslError = _interopRequireWildcard(require("./format-glsl-error"));

var _getShaderName = _interopRequireDefault(require("./get-shader-name"));

var _getShaderVersion = _interopRequireDefault(require("./get-shader-version"));

var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }
},{"./format-glsl-error":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js","./get-shader-name":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./get-shader-version":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js","./get-shader-type-name":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FragmentShader = exports.VertexShader = exports.Shader = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _glslUtils = require("../glsl-utils");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

var _resource = _interopRequireDefault(require("./resource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';

var Shader = function (_Resource) {
  (0, _inherits2.default)(Shader, _Resource);
  (0, _createClass2.default)(Shader, null, [{
    key: "getTypeName",
    value: function getTypeName(shaderType) {
      switch (shaderType) {
        case 35633:
          return 'vertex-shader';

        case 35632:
          return 'fragment-shader';

        default:
          (0, _utils.assert)(false);
          return 'unknown';
      }
    }
  }]);

  function Shader(gl, props) {
    var _this;

    (0, _classCallCheck2.default)(this, Shader);
    (0, _webglUtils.assertWebGLContext)(gl);
    (0, _utils.assert)(typeof props.source === 'string', ERR_SOURCE);
    var id = (0, _glslUtils.getShaderName)(props.source, null) || props.id || (0, _utils.uid)("unnamed ".concat(Shader.getTypeName(props.shaderType)));
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Shader).call(this, gl, {
      id: id
    }));
    _this.shaderType = props.shaderType;
    _this.source = props.source;

    _this.initialize(props);

    return _this;
  }

  (0, _createClass2.default)(Shader, [{
    key: "initialize",
    value: function initialize(_ref) {
      var source = _ref.source;
      var shaderName = (0, _glslUtils.getShaderName)(source, null);

      if (shaderName) {
        this.id = (0, _utils.uid)(shaderName);
      }

      this._compile(source);
    }
  }, {
    key: "getParameter",
    value: function getParameter(pname) {
      return this.gl.getShaderParameter(this.handle, pname);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
    }
  }, {
    key: "getName",
    value: function getName() {
      return (0, _glslUtils.getShaderName)(this.source) || 'unnamed-shader';
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return this.gl.getShaderSource(this.handle);
    }
  }, {
    key: "getTranslatedSource",
    value: function getTranslatedSource() {
      var extension = this.gl.getExtension('WEBGL.debug_shaders');
      return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL.debug_shaders not implemented';
    }
  }, {
    key: "_compile",
    value: function _compile() {
      this.gl.shaderSource(this.handle, this.source);
      this.gl.compileShader(this.handle);
      var compileStatus = this.getParameter(35713);

      if (!compileStatus) {
        var infoLog = this.gl.getShaderInfoLog(this.handle);

        var _parseGLSLCompilerErr = (0, _glslUtils.parseGLSLCompilerError)(infoLog, this.source, this.shaderType, this.id),
            shaderName = _parseGLSLCompilerErr.shaderName,
            errors = _parseGLSLCompilerErr.errors,
            warnings = _parseGLSLCompilerErr.warnings;

        _utils.log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();

        _utils.log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();

        throw new Error("GLSL compilation errors in ".concat(shaderName));
      }
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
  }, {
    key: "_getOptsFromHandle",
    value: function _getOptsFromHandle() {
      return {
        type: this.getParameter(35663),
        source: this.getSource()
      };
    }
  }]);
  return Shader;
}(_resource.default);

exports.Shader = Shader;

var VertexShader = function (_Shader) {
  (0, _inherits2.default)(VertexShader, _Shader);

  function VertexShader(gl, props) {
    (0, _classCallCheck2.default)(this, VertexShader);

    if (typeof props === 'string') {
      props = {
        source: props
      };
    }

    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(VertexShader).call(this, gl, Object.assign({}, props, {
      shaderType: 35633
    })));
  }

  (0, _createClass2.default)(VertexShader, [{
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createShader(35633);
    }
  }]);
  return VertexShader;
}(Shader);

exports.VertexShader = VertexShader;

var FragmentShader = function (_Shader2) {
  (0, _inherits2.default)(FragmentShader, _Shader2);

  function FragmentShader(gl, props) {
    (0, _classCallCheck2.default)(this, FragmentShader);

    if (typeof props === 'string') {
      props = {
        source: props
      };
    }

    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FragmentShader).call(this, gl, Object.assign({}, props, {
      shaderType: 35632
    })));
  }

  (0, _createClass2.default)(FragmentShader, [{
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createShader(35632);
    }
  }]);
  return FragmentShader;
}(Shader);

exports.FragmentShader = FragmentShader;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../glsl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js"}],"../../../node_modules/@babel/runtime/helpers/esm/superPropBase.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _superPropBase;

var _getPrototypeOf = _interopRequireDefault(require("./getPrototypeOf"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = (0, _getPrototypeOf.default)(object);
    if (object === null) break;
  }

  return object;
}
},{"./getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"}],"../../../node_modules/@babel/runtime/helpers/esm/get.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _get;

var _getPrototypeOf = _interopRequireDefault(require("./getPrototypeOf"));

var _superPropBase = _interopRequireDefault(require("./superPropBase"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    exports.default = _get = Reflect.get;
  } else {
    exports.default = _get = function _get(target, property, receiver) {
      var base = (0, _superPropBase.default)(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}
},{"./getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","./superPropBase":"../../../node_modules/@babel/runtime/helpers/esm/superPropBase.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseUniformName = parseUniformName;
exports.getUniformSetter = getUniformSetter;
exports.checkUniformValues = checkUniformValues;
exports.areUniformsEqual = areUniformsEqual;
exports.getUniformCopy = getUniformCopy;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));

var _texture = _interopRequireDefault(require("./texture"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _UNIFORM_SETTERS;

var UNIFORM_SETTERS = (_UNIFORM_SETTERS = {}, (0, _defineProperty2.default)(_UNIFORM_SETTERS, 5126, function (gl, location, value) {
  return gl.uniform1fv(location, toFloatArray(value, 1));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35664, function (gl, location, value) {
  return gl.uniform2fv(location, toFloatArray(value, 2));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35665, function (gl, location, value) {
  return gl.uniform3fv(location, toFloatArray(value, 3));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35666, function (gl, location, value) {
  return gl.uniform4fv(location, toFloatArray(value, 4));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 5124, function (gl, location, value) {
  return gl.uniform1iv(location, toIntArray(value, 1));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35667, function (gl, location, value) {
  return gl.uniform2iv(location, toIntArray(value, 2));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35668, function (gl, location, value) {
  return gl.uniform3iv(location, toIntArray(value, 3));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35669, function (gl, location, value) {
  return gl.uniform4iv(location, toIntArray(value, 4));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35670, function (gl, location, value) {
  return gl.uniform1iv(location, toIntArray(value, 1));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35671, function (gl, location, value) {
  return gl.uniform2iv(location, toIntArray(value, 2));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35672, function (gl, location, value) {
  return gl.uniform3iv(location, toIntArray(value, 3));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35673, function (gl, location, value) {
  return gl.uniform4iv(location, toIntArray(value, 4));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35674, function (gl, location, value) {
  return gl.uniformMatrix2fv(location, false, toFloatArray(value, 4));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35675, function (gl, location, value) {
  return gl.uniformMatrix3fv(location, false, toFloatArray(value, 9));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35676, function (gl, location, value) {
  return gl.uniformMatrix4fv(location, false, toFloatArray(value, 16));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35678, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35680, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 5125, function (gl, location, value) {
  return gl.uniform1uiv(location, toUIntArray(value, 1));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36294, function (gl, location, value) {
  return gl.uniform2uiv(location, toUIntArray(value, 2));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36295, function (gl, location, value) {
  return gl.uniform3uiv(location, toUIntArray(value, 3));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36296, function (gl, location, value) {
  return gl.uniform4uiv(location, toUIntArray(value, 4));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35685, function (gl, location, value) {
  return gl.uniformMatrix2x3fv(location, false, toFloatArray(value, 6));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35686, function (gl, location, value) {
  return gl.uniformMatrix2x4fv(location, false, toFloatArray(value, 8));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35687, function (gl, location, value) {
  return gl.uniformMatrix3x2fv(location, false, toFloatArray(value, 6));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35688, function (gl, location, value) {
  return gl.uniformMatrix3x4fv(location, false, toFloatArray(value, 12));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35689, function (gl, location, value) {
  return gl.uniformMatrix4x2fv(location, false, toFloatArray(value, 8));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35690, function (gl, location, value) {
  return gl.uniformMatrix4x3fv(location, false, toFloatArray(value, 12));
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35679, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 35682, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36289, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36292, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36293, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36298, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36299, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36300, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36303, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36306, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36307, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36308, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), (0, _defineProperty2.default)(_UNIFORM_SETTERS, 36311, function (gl, location, value) {
  return gl.uniform1i(location, value);
}), _UNIFORM_SETTERS);
var FLOAT_ARRAY = {};
var INT_ARRAY = {};
var UINT_ARRAY = {};
var array1 = [0];

function toTypedArray(value, uniformLength, Type, cache) {
  if (uniformLength === 1 && typeof value === 'boolean') {
    value = value ? 1 : 0;
  }

  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }

  var length = value.length;

  if (length % uniformLength) {
    _utils.log.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
  }

  if (value instanceof Type) {
    return value;
  }

  var result = cache[length];

  if (!result) {
    result = new Type(length);
    cache[length] = result;
  }

  for (var i = 0; i < length; i++) {
    result[i] = value[i];
  }

  return result;
}

function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}

function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}

function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}

function parseUniformName(name) {
  if (name[name.length - 1] !== ']') {
    return {
      name: name,
      length: 1,
      isArray: false
    };
  }

  var UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  var matches = name.match(UNIFORM_NAME_REGEXP);

  if (!matches || matches.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }

  return {
    name: matches[1],
    length: matches[2] || 1,
    isArray: Boolean(matches[2])
  };
}

function getUniformSetter(gl, location, info) {
  var setter = UNIFORM_SETTERS[info.type];

  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }

  return setter.bind(null, gl, location);
}

function checkUniformValues(uniforms, source, uniformMap) {
  for (var uniformName in uniforms) {
    var value = uniforms[uniformName];
    var shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);

    if (shouldCheck && !checkUniformValue(value)) {
      source = source ? "".concat(source, " ") : '';
      console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
    }
  }

  return true;
}

function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }

  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof _texture.default) {
    return true;
  } else if (value instanceof _renderbuffer.default) {
    return true;
  } else if (value instanceof _framebuffer.default) {
    return Boolean(value.texture);
  }

  return false;
}

function checkUniformArray(value) {
  if (value.length === 0) {
    return false;
  }

  var checkLength = Math.min(value.length, 16);

  for (var i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }

  return true;
}

function areUniformsEqual(uniform1, uniform2) {
  if (Array.isArray(uniform1) || ArrayBuffer.isView(uniform1)) {
    if (!uniform2) {
      return false;
    }

    var len = uniform1.length;

    if (uniform2.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      if (uniform1[i] !== uniform2[i]) {
        return false;
      }
    }

    return true;
  }

  return uniform1 === uniform2;
}

function getUniformCopy(uniform) {
  if (Array.isArray(uniform) || ArrayBuffer.isView(uniform)) {
    return uniform.slice();
  }

  return uniform;
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","./framebuffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./renderbuffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./texture":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPrimitiveDrawMode = getPrimitiveDrawMode;
exports.getPrimitiveCount = getPrimitiveCount;
exports.getVertexCount = getVertexCount;
exports.decomposeCompositeGLType = decomposeCompositeGLType;
exports.getCompositeGLType = getCompositeGLType;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _COMPOSITE_GL_TYPES;

var GL_BYTE = 0x1400;
var GL_UNSIGNED_BYTE = 0x1401;
var GL_SHORT = 0x1402;
var GL_UNSIGNED_SHORT = 0x1403;
var GL_POINTS = 0x0;
var GL_LINES = 0x1;
var GL_LINE_LOOP = 0x2;
var GL_LINE_STRIP = 0x3;
var GL_TRIANGLES = 0x4;
var GL_TRIANGLE_STRIP = 0x5;
var GL_TRIANGLE_FAN = 0x6;
var GL_FLOAT = 0x1406;
var GL_FLOAT_VEC2 = 0x8b50;
var GL_FLOAT_VEC3 = 0x8b51;
var GL_FLOAT_VEC4 = 0x8b52;
var GL_INT = 0x1404;
var GL_INT_VEC2 = 0x8b53;
var GL_INT_VEC3 = 0x8b54;
var GL_INT_VEC4 = 0x8b55;
var GL_UNSIGNED_INT = 0x1405;
var GL_UNSIGNED_INT_VEC2 = 0x8dc6;
var GL_UNSIGNED_INT_VEC3 = 0x8dc7;
var GL_UNSIGNED_INT_VEC4 = 0x8dc8;
var GL_BOOL = 0x8b56;
var GL_BOOL_VEC2 = 0x8b57;
var GL_BOOL_VEC3 = 0x8b58;
var GL_BOOL_VEC4 = 0x8b59;
var GL_FLOAT_MAT2 = 0x8b5a;
var GL_FLOAT_MAT3 = 0x8b5b;
var GL_FLOAT_MAT4 = 0x8b5c;
var GL_FLOAT_MAT2x3 = 0x8b65;
var GL_FLOAT_MAT2x4 = 0x8b66;
var GL_FLOAT_MAT3x2 = 0x8b67;
var GL_FLOAT_MAT3x4 = 0x8b68;
var GL_FLOAT_MAT4x2 = 0x8b69;
var GL_FLOAT_MAT4x3 = 0x8b6a;
var COMPOSITE_GL_TYPES = (_COMPOSITE_GL_TYPES = {}, (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT, [GL_FLOAT, 1, 'float']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC2, [GL_FLOAT, 2, 'vec2']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC3, [GL_FLOAT, 3, 'vec3']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_VEC4, [GL_FLOAT, 4, 'vec4']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_INT, [GL_INT, 1, 'int']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_INT_VEC2, [GL_INT, 2, 'ivec2']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_INT_VEC3, [GL_INT, 3, 'ivec3']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_INT_VEC4, [GL_INT, 4, 'ivec4']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT, [GL_UNSIGNED_INT, 1, 'uint']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC2, [GL_UNSIGNED_INT, 2, 'uvec2']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC3, [GL_UNSIGNED_INT, 3, 'uvec3']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_UNSIGNED_INT_VEC4, [GL_UNSIGNED_INT, 4, 'uvec4']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_BOOL, [GL_FLOAT, 1, 'bool']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_BOOL_VEC2, [GL_FLOAT, 2, 'bvec2']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_BOOL_VEC3, [GL_FLOAT, 3, 'bvec3']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_BOOL_VEC4, [GL_FLOAT, 4, 'bvec4']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2, [GL_FLOAT, 8, 'mat2']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2x3, [GL_FLOAT, 8, 'mat2x3']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT2x4, [GL_FLOAT, 8, 'mat2x4']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3, [GL_FLOAT, 12, 'mat3']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3x2, [GL_FLOAT, 12, 'mat3x2']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT3x4, [GL_FLOAT, 12, 'mat3x4']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4, [GL_FLOAT, 16, 'mat4']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4x2, [GL_FLOAT, 16, 'mat4x2']), (0, _defineProperty2.default)(_COMPOSITE_GL_TYPES, GL_FLOAT_MAT4x3, [GL_FLOAT, 16, 'mat4x3']), _COMPOSITE_GL_TYPES);

function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;

    case GL_LINES:
      return GL_LINES;

    case GL_LINE_STRIP:
      return GL_LINES;

    case GL_LINE_LOOP:
      return GL_LINES;

    case GL_TRIANGLES:
      return GL_TRIANGLES;

    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;

    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

function getPrimitiveCount(_ref) {
  var drawMode = _ref.drawMode,
      vertexCount = _ref.vertexCount;

  switch (drawMode) {
    case GL_POINTS:
    case GL_LINE_LOOP:
      return vertexCount;

    case GL_LINES:
      return vertexCount / 2;

    case GL_LINE_STRIP:
      return vertexCount - 1;

    case GL_TRIANGLES:
      return vertexCount / 3;

    case GL_TRIANGLE_STRIP:
    case GL_TRIANGLE_FAN:
      return vertexCount - 2;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

function getVertexCount(_ref2) {
  var drawMode = _ref2.drawMode,
      vertexCount = _ref2.vertexCount;
  var primitiveCount = getPrimitiveCount({
    drawMode: drawMode,
    vertexCount: vertexCount
  });

  switch (getPrimitiveDrawMode(drawMode)) {
    case GL_POINTS:
      return primitiveCount;

    case GL_LINES:
      return primitiveCount * 2;

    case GL_TRIANGLES:
      return primitiveCount * 3;

    default:
      (0, _utils.assert)(false);
      return 0;
  }
}

function decomposeCompositeGLType(compositeGLType) {
  var typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];

  if (!typeAndSize) {
    return null;
  }

  var _typeAndSize = (0, _slicedToArray2.default)(typeAndSize, 2),
      type = _typeAndSize[0],
      components = _typeAndSize[1];

  return {
    type: type,
    components: components
  };
}

function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;

    default:
  }

  for (var glType in COMPOSITE_GL_TYPES) {
    var _COMPOSITE_GL_TYPES$g = (0, _slicedToArray2.default)(COMPOSITE_GL_TYPES[glType], 3),
        compType = _COMPOSITE_GL_TYPES$g[0],
        compComponents = _COMPOSITE_GL_TYPES$g[1],
        name = _COMPOSITE_GL_TYPES$g[2];

    if (compType === type && compComponents === components) {
      return {
        glType: glType,
        name: name
      };
    }
  }

  return null;
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _accessor = _interopRequireDefault(require("./accessor"));

var _webglUtils = require("../webgl-utils");

var _attributeUtils = require("../webgl-utils/attribute-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ProgramConfiguration = function () {
  function ProgramConfiguration(program) {
    (0, _classCallCheck2.default)(this, ProgramConfiguration);
    this.id = program.id;
    this.attributeInfos = [];
    this.attributeInfosByName = {};
    this.attributeInfosByLocation = [];
    this.varyingInfos = [];
    this.varyingInfosByName = {};
    Object.seal(this);

    this._readAttributesFromProgram(program);

    this._readVaryingsFromProgram(program);
  }

  (0, _createClass2.default)(ProgramConfiguration, [{
    key: "getAttributeInfo",
    value: function getAttributeInfo(locationOrName) {
      var location = Number(locationOrName);

      if (Number.isFinite(location)) {
        return this.attributeInfosByLocation[location];
      }

      return this.attributeInfosByName[locationOrName] || null;
    }
  }, {
    key: "getAttributeLocation",
    value: function getAttributeLocation(locationOrName) {
      var attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.location : -1;
    }
  }, {
    key: "getAttributeAccessor",
    value: function getAttributeAccessor(locationOrName) {
      var attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.accessor : null;
    }
  }, {
    key: "getVaryingInfo",
    value: function getVaryingInfo(locationOrName) {
      var location = Number(locationOrName);

      if (Number.isFinite(location)) {
        return this.varyingInfos[location];
      }

      return this.varyingInfosByName[locationOrName] || null;
    }
  }, {
    key: "getVaryingIndex",
    value: function getVaryingIndex(locationOrName) {
      var varying = this.getVaryingInfo();
      return varying ? varying.location : -1;
    }
  }, {
    key: "getVaryingAccessor",
    value: function getVaryingAccessor(locationOrName) {
      var varying = this.getVaryingInfo();
      return varying ? varying.accessor : null;
    }
  }, {
    key: "_readAttributesFromProgram",
    value: function _readAttributesFromProgram(program) {
      var gl = program.gl;
      var count = gl.getProgramParameter(program.handle, 35721);

      for (var index = 0; index < count; index++) {
        var _gl$getActiveAttrib = gl.getActiveAttrib(program.handle, index),
            name = _gl$getActiveAttrib.name,
            type = _gl$getActiveAttrib.type,
            size = _gl$getActiveAttrib.size;

        var location = gl.getAttribLocation(program.handle, name);

        if (location >= 0) {
          this._addAttribute(location, name, type, size);
        }
      }

      this.attributeInfos.sort(function (a, b) {
        return a.location - b.location;
      });
    }
  }, {
    key: "_readVaryingsFromProgram",
    value: function _readVaryingsFromProgram(program) {
      var gl = program.gl;

      if (!(0, _webglUtils.isWebGL2)(gl)) {
        return;
      }

      var count = gl.getProgramParameter(program.handle, 35971);

      for (var location = 0; location < count; location++) {
        var _gl$getTransformFeedb = gl.getTransformFeedbackVarying(program.handle, location),
            name = _gl$getTransformFeedb.name,
            type = _gl$getTransformFeedb.type,
            size = _gl$getTransformFeedb.size;

        this._addVarying(location, name, type, size);
      }

      this.varyingInfos.sort(function (a, b) {
        return a.location - b.location;
      });
    }
  }, {
    key: "_addAttribute",
    value: function _addAttribute(location, name, compositeType, size) {
      var _decomposeCompositeGL = (0, _attributeUtils.decomposeCompositeGLType)(compositeType),
          type = _decomposeCompositeGL.type,
          components = _decomposeCompositeGL.components;

      var accessor = {
        type: type,
        size: size * components
      };

      this._inferProperties(location, name, accessor);

      var attributeInfo = {
        location: location,
        name: name,
        accessor: new _accessor.default(accessor)
      };
      this.attributeInfos.push(attributeInfo);
      this.attributeInfosByLocation[location] = attributeInfo;
      this.attributeInfosByName[attributeInfo.name] = attributeInfo;
    }
  }, {
    key: "_inferProperties",
    value: function _inferProperties(location, name, accessor) {
      if (/instance/i.test(name)) {
        accessor.divisor = 1;
      }
    }
  }, {
    key: "_addVarying",
    value: function _addVarying(location, name, compositeType, size) {
      var _decomposeCompositeGL2 = (0, _attributeUtils.decomposeCompositeGLType)(compositeType),
          type = _decomposeCompositeGL2.type,
          components = _decomposeCompositeGL2.components;

      var accessor = new _accessor.default({
        type: type,
        size: size * components
      });
      var varying = {
        location: location,
        name: name,
        accessor: accessor
      };
      this.varyingInfos.push(varying);
      this.varyingInfosByName[varying.name] = varying;
    }
  }]);
  return ProgramConfiguration;
}();

exports.default = ProgramConfiguration;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./accessor":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../webgl-utils/attribute-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/program.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _texture = _interopRequireDefault(require("./texture"));

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _uniforms = require("./uniforms");

var _shader = require("./shader");

var _programConfiguration = _interopRequireDefault(require("./program-configuration"));

var _context = require("../context");

var _webglUtils = require("../webgl-utils");

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_PROGRAM_PERF_PRIORITY = 4;
var GL_SEPARATE_ATTRIBS = 0x8c8d;
var V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];

var Program = function (_Resource) {
  (0, _inherits2.default)(Program, _Resource);

  function Program(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Program);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Program).call(this, gl, props));

    _this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);

    _this._isCached = false;

    _this.initialize(props);

    Object.seal((0, _assertThisInitialized2.default)(_this));

    _this._setId(props.id);

    return _this;
  }

  (0, _createClass2.default)(Program, [{
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var vs = props.vs,
          fs = props.fs,
          varyings = props.varyings,
          _props$bufferMode = props.bufferMode,
          bufferMode = _props$bufferMode === void 0 ? GL_SEPARATE_ATTRIBS : _props$bufferMode;
      this.vs = typeof vs === 'string' ? new _shader.VertexShader(this.gl, {
        id: "".concat(props.id, "-vs"),
        source: vs
      }) : vs;
      this.fs = typeof fs === 'string' ? new _shader.FragmentShader(this.gl, {
        id: "".concat(props.id, "-fs"),
        source: fs
      }) : fs;
      (0, _utils.assert)(this.vs instanceof _shader.VertexShader);
      (0, _utils.assert)(this.fs instanceof _shader.FragmentShader);
      this.uniforms = {};

      if (varyings) {
        (0, _webglUtils.assertWebGL2Context)(this.gl);
        this.varyings = varyings;
        this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }

      this._compileAndLink();

      this._readUniformLocationsFromLinkedProgram();

      this.configuration = new _programConfiguration.default(this);
      return this.setProps(props);
    }
  }, {
    key: "delete",
    value: function _delete() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._isCached) {
        return this;
      }

      return (0, _get2.default)((0, _getPrototypeOf2.default)(Program.prototype), "delete", this).call(this, options);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('uniforms' in props) {
        this.setUniforms(props.uniforms);
      }

      return this;
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var _this2 = this;

      var logPriority = _ref.logPriority,
          _ref$drawMode = _ref.drawMode,
          drawMode = _ref$drawMode === void 0 ? 4 : _ref$drawMode,
          vertexCount = _ref.vertexCount,
          _ref$offset = _ref.offset,
          offset = _ref$offset === void 0 ? 0 : _ref$offset,
          start = _ref.start,
          end = _ref.end,
          _ref$isIndexed = _ref.isIndexed,
          isIndexed = _ref$isIndexed === void 0 ? false : _ref$isIndexed,
          _ref$indexType = _ref.indexType,
          indexType = _ref$indexType === void 0 ? 5123 : _ref$indexType,
          _ref$isInstanced = _ref.isInstanced,
          isInstanced = _ref$isInstanced === void 0 ? false : _ref$isInstanced,
          _ref$instanceCount = _ref.instanceCount,
          instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount,
          _ref$vertexArray = _ref.vertexArray,
          vertexArray = _ref$vertexArray === void 0 ? null : _ref$vertexArray,
          transformFeedback = _ref.transformFeedback,
          framebuffer = _ref.framebuffer,
          _ref$parameters = _ref.parameters,
          parameters = _ref$parameters === void 0 ? {} : _ref$parameters,
          uniforms = _ref.uniforms,
          samplers = _ref.samplers;

      if (uniforms || samplers) {
        _utils.log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();

        this.setUniforms(uniforms || {});
      }

      if (logPriority !== undefined) {
        var fb = framebuffer ? framebuffer.id : 'default';
        var message = "mode=".concat((0, _webglUtils.getKey)(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat((0, _webglUtils.getKey)(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);

        _utils.log.log(logPriority, message)();
      }

      (0, _utils.assert)(vertexArray);
      this.gl.useProgram(this.handle);

      if (!this._areTexturesRenderable()) {
        return false;
      }

      vertexArray.bindForDraw(vertexCount, instanceCount, function () {
        if (framebuffer !== undefined) {
          parameters = Object.assign({}, parameters, {
            framebuffer: framebuffer
          });
        }

        if (transformFeedback) {
          var primitiveMode = (0, _attributeUtils.getPrimitiveDrawMode)(drawMode);
          transformFeedback.begin(primitiveMode);
        }

        _this2._bindTextures();

        (0, _context.withParameters)(_this2.gl, parameters, function () {
          if (isIndexed && isInstanced) {
            _this2.gl.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
          } else if (isIndexed && (0, _webglUtils.isWebGL2)(_this2.gl) && !isNaN(start) && !isNaN(end)) {
            _this2.gl.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
          } else if (isIndexed) {
            _this2.gl.drawElements(drawMode, vertexCount, indexType, offset);
          } else if (isInstanced) {
            _this2.gl.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
          } else {
            _this2.gl.drawArrays(drawMode, offset, vertexCount);
          }
        });

        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      return true;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _onChangeCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

      var somethingChanged = false;
      var changedUniforms = {};

      for (var key in uniforms) {
        if (!(0, _uniforms.areUniformsEqual)(this.uniforms[key], uniforms[key])) {
          somethingChanged = true;
          changedUniforms[key] = uniforms[key];
          this.uniforms[key] = (0, _uniforms.getUniformCopy)(uniforms[key]);
        }
      }

      if (somethingChanged) {
        _onChangeCallback();

        (0, _uniforms.checkUniformValues)(changedUniforms, this.id, this._uniformSetters);

        this._setUniforms(changedUniforms);
      }

      return this;
    }
  }, {
    key: "reset",
    value: function reset() {}
  }, {
    key: "_areTexturesRenderable",
    value: function _areTexturesRenderable() {
      var texturesRenderable = true;

      for (var uniformName in this.uniforms) {
        var uniformSetter = this._uniformSetters[uniformName];

        if (uniformSetter && uniformSetter.textureIndex !== undefined) {
          var uniform = this.uniforms[uniformName];

          if (uniform instanceof _framebuffer.default) {
            var framebuffer = uniform;
            uniform = framebuffer.texture;
          }

          if (uniform instanceof _texture.default) {
            var texture = uniform;
            texturesRenderable = texturesRenderable && texture.loaded;
          }
        }
      }

      return texturesRenderable;
    }
  }, {
    key: "_bindTextures",
    value: function _bindTextures() {
      for (var uniformName in this.uniforms) {
        var uniformSetter = this._uniformSetters[uniformName];

        if (uniformSetter && uniformSetter.textureIndex !== undefined) {
          var uniform = this.uniforms[uniformName];

          if (uniform instanceof _framebuffer.default) {
            uniform = uniform.texture;
          }

          if (uniform instanceof _texture.default) {
            var texture = uniform;
            texture.bind(uniformSetter.textureIndex);
          }
        }
      }
    }
  }, {
    key: "_setUniforms",
    value: function _setUniforms(uniforms) {
      this.gl.useProgram(this.handle);

      for (var uniformName in uniforms) {
        var uniform = uniforms[uniformName];
        var uniformSetter = this._uniformSetters[uniformName];

        if (uniformSetter) {
          if (uniform instanceof _framebuffer.default) {
            uniform = uniform.texture;
          }

          if (uniform instanceof _texture.default) {
            if (uniformSetter.textureIndex === undefined) {
              uniformSetter.textureIndex = this._textureIndexCounter++;
            }

            var texture = uniform;
            var textureIndex = uniformSetter.textureIndex;
            texture.bind(textureIndex);
            uniformSetter(textureIndex);
          } else {
            uniformSetter(uniform);
          }
        }
      }

      return this;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createProgram();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
  }, {
    key: "_getOptionsFromHandle",
    value: function _getOptionsFromHandle(handle) {
      var shaderHandles = this.gl.getAttachedShaders(handle);
      var opts = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = shaderHandles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var shaderHandle = _step.value;
          var type = this.gl.getShaderParameter(this.handle, 35663);

          switch (type) {
            case 35633:
              opts.vs = new _shader.VertexShader({
                handle: shaderHandle
              });
              break;

            case 35632:
              opts.fs = new _shader.FragmentShader({
                handle: shaderHandle
              });
              break;

            default:
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return opts;
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname) {
      return this.gl.getProgramParameter(this.handle, pname);
    }
  }, {
    key: "_setId",
    value: function _setId(id) {
      if (!id) {
        var programName = this._getName();

        this.id = (0, _utils.uid)(programName);
      }
    }
  }, {
    key: "_getName",
    value: function _getName() {
      var programName = this.vs.getName() || this.fs.getName();
      programName = programName.replace(/shader/i, '');
      programName = programName ? "".concat(programName, "-program") : 'program';
      return programName;
    }
  }, {
    key: "_compileAndLink",
    value: function _compileAndLink() {
      var gl = this.gl;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);

      _utils.log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();

      gl.linkProgram(this.handle);

      _utils.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();

      if (gl.debug || _utils.log.priority > 0) {
        gl.validateProgram(this.handle);
        var linked = gl.getProgramParameter(this.handle, 35714);

        if (!linked) {
          throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
        }
      }
    }
  }, {
    key: "_readUniformLocationsFromLinkedProgram",
    value: function _readUniformLocationsFromLinkedProgram() {
      var gl = this.gl;
      this._uniformSetters = {};
      this._uniformCount = this._getParameter(35718);

      for (var i = 0; i < this._uniformCount; i++) {
        var info = this.gl.getActiveUniform(this.handle, i);

        var _parseUniformName = (0, _uniforms.parseUniformName)(info.name),
            name = _parseUniformName.name,
            isArray = _parseUniformName.isArray;

        var location = gl.getUniformLocation(this.handle, name);
        this._uniformSetters[name] = (0, _uniforms.getUniformSetter)(gl, location, info, isArray);
      }

      this._textureIndexCounter = 0;
    }
  }, {
    key: "getActiveUniforms",
    value: function getActiveUniforms(uniformIndices, pname) {
      return this.gl.getActiveUniforms(this.handle, uniformIndices, pname);
    }
  }, {
    key: "getUniformBlockIndex",
    value: function getUniformBlockIndex(blockName) {
      return this.gl.getUniformBlockIndex(this.handle, blockName);
    }
  }, {
    key: "getActiveUniformBlockParameter",
    value: function getActiveUniformBlockParameter(blockIndex, pname) {
      return this.gl.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
    }
  }, {
    key: "uniformBlockBinding",
    value: function uniformBlockBinding(blockIndex, blockBinding) {
      this.gl.uniformBlockBinding(this.handle, blockIndex, blockBinding);
    }
  }]);
  return Program;
}(_resource.default);

exports.default = Program;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./texture":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","./framebuffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./uniforms":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js","./shader":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/shader.js","./program-configuration":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js","../context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/index.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../webgl-utils/attribute-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/query.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _features = require("../features");

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GL_QUERY_RESULT = 0x8866;
var GL_QUERY_RESULT_AVAILABLE = 0x8867;
var GL_TIME_ELAPSED_EXT = 0x88bf;
var GL_GPU_DISJOINT_EXT = 0x8fbb;
var GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
var GL_ANY_SAMPLES_PASSED = 0x8c2f;
var GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;

var Query = function (_Resource) {
  (0, _inherits2.default)(Query, _Resource);
  (0, _createClass2.default)(Query, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var webgl2 = (0, _webglUtils.isWebGL2)(gl);
      var hasTimerQuery = (0, _features.hasFeatures)(gl, _features.FEATURES.TIMER_QUERY);
      var supported = webgl2 || hasTimerQuery;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = opts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          switch (key) {
            case 'queries':
              supported = supported && webgl2;
              break;

            case 'timers':
              supported = supported && hasTimerQuery;
              break;

            default:
              (0, _utils.assert)(false);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return supported;
    }
  }]);

  function Query(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Query);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Query).call(this, gl, opts));
    _this.target = null;
    _this._queryPending = false;
    _this._pollingPromise = null;
    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(Query, [{
    key: "beginTimeElapsedQuery",
    value: function beginTimeElapsedQuery() {
      return this.begin(GL_TIME_ELAPSED_EXT);
    }
  }, {
    key: "beginOcclusionQuery",
    value: function beginOcclusionQuery() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$conservative = _ref.conservative,
          conservative = _ref$conservative === void 0 ? false : _ref$conservative;

      return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
    }
  }, {
    key: "beginTransformFeedbackQuery",
    value: function beginTransformFeedbackQuery() {
      return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
    }
  }, {
    key: "begin",
    value: function begin(target) {
      if (this._queryPending) {
        return this;
      }

      this.target = target;
      this.gl.beginQuery(this.target, this.handle);
      return this;
    }
  }, {
    key: "end",
    value: function end() {
      if (this._queryPending) {
        return this;
      }

      if (this.target) {
        this.gl.endQuery(this.target);
        this.target = null;
        this._queryPending = true;
      }

      return this;
    }
  }, {
    key: "isResultAvailable",
    value: function isResultAvailable() {
      if (!this._queryPending) {
        return false;
      }

      var resultAvailable = this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);

      if (resultAvailable) {
        this._queryPending = false;
      }

      return resultAvailable;
    }
  }, {
    key: "isTimerDisjoint",
    value: function isTimerDisjoint() {
      return this.gl.getParameter(GL_GPU_DISJOINT_EXT);
    }
  }, {
    key: "getResult",
    value: function getResult() {
      return this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT);
    }
  }, {
    key: "getTimerMilliseconds",
    value: function getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
  }, {
    key: "createPoll",
    value: function createPoll() {
      var _this2 = this;

      var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;

      if (this._pollingPromise) {
        return this._pollingPromise;
      }

      var counter = 0;
      this._pollingPromise = new Promise(function (resolve, reject) {
        var poll = function poll() {
          if (_this2.isResultAvailable()) {
            resolve(_this2.getResult());
            _this2._pollingPromise = null;
          } else if (counter++ > limit) {
            reject('Timed out');
            _this2._pollingPromise = null;
          } else {
            requestAnimationFrame(poll);
          }
        };

        requestAnimationFrame(poll);
      });
      return this._pollingPromise;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return Query.isSupported(this.gl) ? this.gl.createQuery() : null;
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteQuery(this.handle);
    }
  }]);
  return Query;
}(_resource.default);

exports.default = Query;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","../features":"../../../node_modules/@luma.gl/webgl/dist/esm/features/index.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _webglUtils = require("../webgl-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TransformFeedback = function (_Resource) {
  (0, _inherits2.default)(TransformFeedback, _Resource);
  (0, _createClass2.default)(TransformFeedback, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      return (0, _webglUtils.isWebGL2)(gl);
    }
  }]);

  function TransformFeedback(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TransformFeedback);
    (0, _webglUtils.assertWebGL2Context)(gl);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TransformFeedback).call(this, gl, props));

    _this.initialize(props);

    _this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);

    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(TransformFeedback, [{
    key: "initialize",
    value: function initialize() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.buffers = {};
      this.unused = {};
      this.configuration = null;
      this.bindOnUse = true;

      if (!(0, _utils.isObjectEmpty)(this.buffers)) {
        this.bind(function () {
          return _this2._unbindBuffers();
        });
      }

      this.setProps(props);
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('program' in props) {
        this.configuration = props.program && props.program.configuration;
      }

      if ('configuration' in props) {
        this.configuration = props.configuration;
      }

      if ('bindOnUse' in props) {
        props = props.bindOnUse;
      }

      if ('buffers' in props) {
        this.setBuffers(props.buffers);
      }
    }
  }, {
    key: "setBuffers",
    value: function setBuffers() {
      var _this3 = this;

      var buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.bind(function () {
        for (var bufferName in buffers) {
          _this3.setBuffer(bufferName, buffers[bufferName]);
        }
      });
      return this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(locationOrName, bufferOrParams) {
      var _this4 = this;

      var location = this._getVaryingIndex(locationOrName);

      var _this$_getBufferParam = this._getBufferParams(bufferOrParams),
          buffer = _this$_getBufferParam.buffer,
          byteSize = _this$_getBufferParam.byteSize,
          byteOffset = _this$_getBufferParam.byteOffset;

      if (location < 0) {
        this.unused[locationOrName] = buffer;

        _utils.log.warn(function () {
          return "".concat(_this4.id, " unused varying buffer ").concat(locationOrName);
        })();

        return this;
      }

      this.buffers[location] = bufferOrParams;

      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteSize);
      }

      return this;
    }
  }, {
    key: "begin",
    value: function begin() {
      var primitiveMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.gl.bindTransformFeedback(36386, this.handle);

      this._bindBuffers();

      this.gl.beginTransformFeedback(primitiveMode);
      return this;
    }
  }, {
    key: "end",
    value: function end() {
      this.gl.endTransformFeedback();

      this._unbindBuffers();

      this.gl.bindTransformFeedback(36386, null);
      return this;
    }
  }, {
    key: "_getBufferParams",
    value: function _getBufferParams(bufferOrParams) {
      var byteOffset;
      var byteSize;
      var buffer;

      if (bufferOrParams instanceof _buffer.default === false) {
        buffer = bufferOrParams.buffer;
        byteSize = bufferOrParams.byteSize;
        byteOffset = bufferOrParams.byteOffset;
      } else {
        buffer = bufferOrParams;
      }

      if (byteOffset !== undefined || byteSize !== undefined) {
        byteOffset = byteOffset || 0;
        byteSize = byteSize || buffer.byteLength - byteOffset;
      }

      return {
        buffer: buffer,
        byteOffset: byteOffset,
        byteSize: byteSize
      };
    }
  }, {
    key: "_getVaryingInfo",
    value: function _getVaryingInfo(locationOrName) {
      return this.configuration && this.configuration.getVaryingInfo(locationOrName);
    }
  }, {
    key: "_getVaryingIndex",
    value: function _getVaryingIndex(locationOrName) {
      if (this.configuration) {
        return this.configuration.getVaryingInfo(locationOrName).location;
      }

      var location = Number(locationOrName);
      return Number.isFinite(location) ? location : -1;
    }
  }, {
    key: "_bindBuffers",
    value: function _bindBuffers() {
      if (this.bindOnUse) {
        for (var bufferIndex in this.buffers) {
          var _this$_getBufferParam2 = this._getBufferParams(this.buffers[bufferIndex]),
              buffer = _this$_getBufferParam2.buffer,
              byteSize = _this$_getBufferParam2.byteSize,
              byteOffset = _this$_getBufferParam2.byteOffset;

          this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
        }
      }
    }
  }, {
    key: "_unbindBuffers",
    value: function _unbindBuffers() {
      if (this.bindOnUse) {
        for (var bufferIndex in this.buffers) {
          this._bindBuffer(bufferIndex, null);
        }
      }
    }
  }, {
    key: "_bindBuffer",
    value: function _bindBuffer(index, buffer) {
      var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var byteSize = arguments.length > 3 ? arguments[3] : undefined;
      var handle = buffer && buffer.handle;

      if (!handle || byteSize === undefined) {
        this.gl.bindBufferBase(35982, index, handle);
      } else {
        this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
      }

      return this;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      return this.gl.createTransformFeedback();
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle() {
      this.gl.deleteTransformFeedback(this.handle);
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle(handle) {
      this.gl.bindTransformFeedback(36386, this.handle);
    }
  }]);
  return TransformFeedback;
}(_resource.default);

exports.default = TransformFeedback;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScratchArrayBuffer = getScratchArrayBuffer;
exports.getScratchArray = getScratchArray;
exports.fillArray = fillArray;
var arrayBuffer = null;

function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }

  return arrayBuffer;
}

function getScratchArray(Type, length) {
  var scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length);
}

function fillArray(_ref) {
  var target = _ref.target,
      source = _ref.source,
      _ref$start = _ref.start,
      start = _ref$start === void 0 ? 0 : _ref$start,
      _ref$count = _ref.count,
      count = _ref$count === void 0 ? 1 : _ref$count;
  var length = source.length;
  var total = count * length;
  var copied = 0;

  for (var i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}
},{}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _webglUtils = require("../webgl-utils");

var _arrayUtilsFlat = require("../utils/array-utils-flat");

var _utils = require("../utils");

var _probe = require("probe.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OES_vertex_array_object = 'OES_vertex_array_object';
var ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';

var VertexArrayObject = function (_Resource) {
  (0, _inherits2.default)(VertexArrayObject, _Resource);
  (0, _createClass2.default)(VertexArrayObject, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.constantAttributeZero) {
        return (0, _webglUtils.isWebGL2)(gl) || (0, _probe.getBrowser)() === 'Chrome';
      }

      return (0, _webglUtils.isWebGL2)(gl) || gl.getExtension(OES_vertex_array_object);
    }
  }, {
    key: "getDefaultArray",
    value: function getDefaultArray(gl) {
      gl.luma = gl.luma || {};

      if (!gl.luma.defaultVertexArray) {
        gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
          handle: null
        });
      }

      return gl.luma.defaultVertexArray;
    }
  }, {
    key: "getMaxAttributes",
    value: function getMaxAttributes(gl) {
      VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
      return VertexArrayObject.MAX_ATTRIBUTES;
    }
  }, {
    key: "setConstant",
    value: function setConstant(gl, location, array) {
      switch (array.constructor) {
        case Float32Array:
          VertexArrayObject._setConstantFloatArray(gl, location, array);

          break;

        case Int32Array:
          VertexArrayObject._setConstantIntArray(gl, location, array);

          break;

        case Uint32Array:
          VertexArrayObject._setConstantUintArray(gl, location, array);

          break;

        default:
          (0, _utils.assert)(false);
      }
    }
  }]);

  function VertexArrayObject(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, VertexArrayObject);
    var id = opts.id || opts.program && opts.program.id;
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(VertexArrayObject).call(this, gl, Object.assign({}, opts, {
      id: id
    })));
    _this.hasVertexArrays = VertexArrayObject.isSupported(gl);
    _this.buffer = null;
    _this.bufferValue = null;

    _this.initialize(opts);

    Object.seal((0, _assertThisInitialized2.default)(_this));
    return _this;
  }

  (0, _createClass2.default)(VertexArrayObject, [{
    key: "delete",
    value: function _delete() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(VertexArrayObject.prototype), "delete", this).call(this);

      if (this.buffer) {
        this.buffer["delete"]();
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setProps(props);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      return this;
    }
  }, {
    key: "setElementBuffer",
    value: function setElementBuffer() {
      var _this2 = this;

      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _utils.assert)(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
      this.bind(function () {
        _this2.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
      });
      return this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(location, buffer, accessor) {
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, accessor);
      }

      var size = accessor.size,
          type = accessor.type,
          stride = accessor.stride,
          offset = accessor.offset,
          normalized = accessor.normalized,
          integer = accessor.integer,
          divisor = accessor.divisor;
      var gl = this.gl;
      location = Number(location);
      this.bind(function () {
        gl.bindBuffer(34962, buffer.handle);

        if (integer) {
          (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));
          gl.vertexAttribIPointer(location, size, type, stride, offset);
        } else {
          gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        }

        gl.enableVertexAttribArray(location);
        gl.vertexAttribDivisor(location, divisor || 0);
      });
      return this;
    }
  }, {
    key: "enable",
    value: function enable(location) {
      var _this3 = this;

      var _enable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var disablingAttributeZero = !_enable && location === 0 && !VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      });

      if (!disablingAttributeZero) {
        location = Number(location);
        this.bind(function () {
          return _enable ? _this3.gl.enableVertexAttribArray(location) : _this3.gl.disableVertexAttribArray(location);
        });
      }

      return this;
    }
  }, {
    key: "getConstantBuffer",
    value: function getConstantBuffer(elementCount, value, accessor) {
      var constantValue = this._normalizeConstantArrayValue(value, accessor);

      var byteLength = constantValue.byteLength * elementCount;
      var length = constantValue.length * elementCount;
      var updateNeeded = !this.buffer;
      this.buffer = this.buffer || new _buffer.default(this.gl, byteLength);
      updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
      updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);

      if (updateNeeded) {
        var typedArray = (0, _arrayUtilsFlat.getScratchArray)(value.constructor, length);
        (0, _arrayUtilsFlat.fillArray)({
          target: typedArray,
          source: constantValue,
          start: 0,
          count: length
        });
        this.buffer.subData(typedArray);
        this.bufferValue = value;
      }

      return this.buffer;
    }
  }, {
    key: "_normalizeConstantArrayValue",
    value: function _normalizeConstantArrayValue(arrayValue, accessor) {
      if (Array.isArray(arrayValue)) {
        return new Float32Array(arrayValue);
      }

      return arrayValue;
    }
  }, {
    key: "_compareConstantArrayValues",
    value: function _compareConstantArrayValues(v1, v2) {
      if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
        return false;
      }

      for (var i = 0; i < v1.length; ++i) {
        if (v1[i] !== v2[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_createHandle",
    value: function _createHandle() {
      this.hasVertexArrays = VertexArrayObject.isSupported(this.gl);

      if (this.hasVertexArrays) {
        return this.gl.createVertexArray();
      }

      return null;
    }
  }, {
    key: "_deleteHandle",
    value: function _deleteHandle(handle) {
      if (this.hasVertexArrays) {
        this.gl.deleteVertexArray(handle);
      }

      return [this.elements];
    }
  }, {
    key: "_bindHandle",
    value: function _bindHandle(handle) {
      if (this.hasVertexArrays) {
        this.gl.bindVertexArray(handle);
      }
    }
  }, {
    key: "_getParameter",
    value: function _getParameter(pname, _ref) {
      var _this4 = this;

      var location = _ref.location;
      (0, _utils.assert)(Number.isFinite(location));
      return this.bind(function () {
        switch (pname) {
          case 34373:
            return _this4.gl.getVertexAttribOffset(location, pname);

          default:
            return _this4.gl.getVertexAttrib(location, pname);
        }
      });
    }
  }, {
    key: "MAX_ATTRIBUTES",
    get: function get() {
      return VertexArrayObject.getMaxAttributes(this.gl);
    }
  }], [{
    key: "_setConstantFloatArray",
    value: function _setConstantFloatArray(gl, location, array) {
      switch (array.length) {
        case 1:
          gl.vertexAttrib1fv(location, array);
          break;

        case 2:
          gl.vertexAttrib2fv(location, array);
          break;

        case 3:
          gl.vertexAttrib3fv(location, array);
          break;

        case 4:
          gl.vertexAttrib4fv(location, array);
          break;

        default:
          (0, _utils.assert)(false);
      }
    }
  }, {
    key: "_setConstantIntArray",
    value: function _setConstantIntArray(gl, location, array) {
      (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));

      switch (array.length) {
        case 1:
          gl.vertexAttribI1iv(location, array);
          break;

        case 2:
          gl.vertexAttribI2iv(location, array);
          break;

        case 3:
          gl.vertexAttribI3iv(location, array);
          break;

        case 4:
          gl.vertexAttribI4iv(location, array);
          break;

        default:
          (0, _utils.assert)(false);
      }
    }
  }, {
    key: "_setConstantUintArray",
    value: function _setConstantUintArray(gl, location, array) {
      (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));

      switch (array.length) {
        case 1:
          gl.vertexAttribI1uiv(location, array);
          break;

        case 2:
          gl.vertexAttribI2uiv(location, array);
          break;

        case 3:
          gl.vertexAttribI3uiv(location, array);
          break;

        case 4:
          gl.vertexAttribI4uiv(location, array);
          break;

        default:
          (0, _utils.assert)(false);
      }
    }
  }]);
  return VertexArrayObject;
}(_resource.default);

exports.default = VertexArrayObject;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./resource":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../utils/array-utils-flat":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js","probe.gl":"../../../node_modules/probe.gl/dist/esm/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _accessor2 = _interopRequireDefault(require("./accessor"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _vertexArrayObject = _interopRequireDefault(require("./vertex-array-object"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';
var MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
var DEPRECATIONS_V6 = ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable'];

var VertexArray = function () {
  function VertexArray(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, VertexArray);
    var id = opts.id || opts.program && opts.program.id;
    this.id = id;
    this.gl = gl;
    this.configuration = null;
    this.elements = null;
    this.elementsAccessor = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null;
    this.vertexArrayObject = _vertexArrayObject.default.isSupported(gl) ? new _vertexArrayObject.default(gl) : _vertexArrayObject.default.getDefaultArray(gl);
    (0, _utils.stubRemovedMethods)(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);
    this.initialize(opts);
    Object.seal(this);
  }

  (0, _createClass2.default)(VertexArray, [{
    key: "delete",
    value: function _delete() {
      if (this.buffer) {
        this.buffer["delete"]();
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.reset();
      this.configuration = null;
      this.bindOnUse = false;
      return this.setProps(props);
    }
  }, {
    key: "reset",
    value: function reset() {
      this.elements = null;
      this.elementsAccessor = null;
      var MAX_ATTRIBUTES = this.vertexArrayObject.MAX_ATTRIBUTES;
      this.values = new Array(MAX_ATTRIBUTES).fill(null);
      this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
      this.unused = {};
      this.drawParams = null;
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('program' in props) {
        this.configuration = props.program && props.program.configuration;
      }

      if ('configuration' in props) {
        this.configuration = props.configuration;
      }

      if ('attributes' in props) {
        this.setAttributes(props.attributes);
      }

      if ('elements' in props) {
        this.setElementBuffer(props.elements);
      }

      if ('bindOnUse' in props) {
        props = props.bindOnUse;
      }

      return this;
    }
  }, {
    key: "clearDrawParams",
    value: function clearDrawParams() {
      this.drawParams = null;
    }
  }, {
    key: "getDrawParams",
    value: function getDrawParams(appParameters) {
      this.drawParams = this.drawParams || this._updateDrawParams();
      return Object.assign({}, this.drawParams, appParameters);
    }
  }, {
    key: "setAttributes",
    value: function setAttributes(attributes) {
      var _this = this;

      this.vertexArrayObject.bind(function () {
        for (var locationOrName in attributes) {
          var value = attributes[locationOrName];

          _this._setAttribute(locationOrName, value);
        }

        _this.gl.bindBuffer(34962, null);
      });
      return this;
    }
  }, {
    key: "setElementBuffer",
    value: function setElementBuffer() {
      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.elements = elementBuffer;
      this.elementsAccessor = accessor;
      this.clearDrawParams();

      if (!this.vertexArrayObject.isDefaultArray) {
        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
      }

      return this;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(locationOrName, buffer) {
      var appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, appAccessor);
      }

      var _this$_resolveLocatio = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor),
          location = _this$_resolveLocatio.location,
          accessor = _this$_resolveLocatio.accessor;

      if (location >= 0) {
        this.values[location] = buffer;
        this.accessors[location] = accessor;
        this.clearDrawParams();

        if (!this.vertexArrayObject.isDefaultArray) {
          this.vertexArrayObject.setBuffer(location, buffer, accessor);
        }
      }

      return this;
    }
  }, {
    key: "setConstant",
    value: function setConstant(locationOrName, arrayValue) {
      var appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _this$_resolveLocatio2 = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
        size: arrayValue.length
      }, appAccessor)),
          location = _this$_resolveLocatio2.location,
          accessor = _this$_resolveLocatio2.accessor;

      if (location >= 0) {
        arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue, accessor);
        this.values[location] = arrayValue;
        this.accessors[location] = accessor;
        this.clearDrawParams();

        if (!this.vertexArrayObject.isDefaultArray) {
          this.vertexArrayObject.enable(location, false);
        }
      }

      return this;
    }
  }, {
    key: "unbindBuffers",
    value: function unbindBuffers() {
      var _this2 = this;

      this.vertexArrayObject.bind(function () {
        if (_this2.elements) {
          _this2.setElementBuffer(null);
        }

        _this2.buffer = _this2.buffer || new _buffer.default(_this2.gl, {
          accessor: {
            size: 4
          }
        });

        for (var location = 0; location < _this2.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          if (_this2.values[location] instanceof _buffer.default) {
            _this2.gl.disableVertexAttribArray(location);

            _this2.gl.bindBuffer(34962, _this2.buffer.handle);

            _this2.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
          }
        }
      });
      return this;
    }
  }, {
    key: "bindBuffers",
    value: function bindBuffers() {
      var _this3 = this;

      this.vertexArrayObject.bind(function () {
        if (_this3.elements) {
          _this3.setElementBuffer(_this3.elements);
        }

        for (var location = 0; location < _this3.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          var buffer = _this3.values[location];

          if (buffer instanceof _buffer.default) {
            _this3.setBuffer(location, buffer);
          }
        }
      });
      return this;
    }
  }, {
    key: "bindForDraw",
    value: function bindForDraw(vertexCount, instanceCount, func) {
      var _this4 = this;

      var value;
      this.vertexArrayObject.bind(function () {
        _this4._setConstantAttributes(vertexCount, instanceCount);

        if (!_this4.vertexArrayObject.hasVertexArrays) {
          _this4.bindBuffers();
        }

        value = func();

        if (!_this4.vertexArrayObject.hasVertexArrays) {
          _this4.unbindBuffers();
        }
      });
      return value;
    }
  }, {
    key: "_resolveLocationAndAccessor",
    value: function _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
      var _this5 = this;

      var _this$_getAttributeIn = this._getAttributeIndex(locationOrName),
          location = _this$_getAttributeIn.location,
          name = _this$_getAttributeIn.name;

      if (!Number.isFinite(location) || location < 0) {
        this.unused[locationOrName] = value;

        _utils.log.once(3, function () {
          return "unused value ".concat(locationOrName, " in ").concat(_this5.id);
        })();

        return this;
      }

      var accessInfo = this._getAttributeInfo(name || location);

      if (!accessInfo) {
        return {
          location: -1,
          accessor: null
        };
      }

      var accessor = _accessor2.default.resolve(accessInfo.accessor, valueAccessor, appAccessor);

      var size = accessor.size,
          type = accessor.type;
      (0, _utils.assert)(Number.isFinite(size) && Number.isFinite(type));
      return {
        location: location,
        accessor: accessor
      };
    }
  }, {
    key: "_getAttributeInfo",
    value: function _getAttributeInfo(attributeName) {
      return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
  }, {
    key: "_getAttributeIndex",
    value: function _getAttributeIndex(locationOrName) {
      var location = Number(locationOrName);

      if (Number.isFinite(location)) {
        return {
          location: location
        };
      }

      var multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
      var name = multiLocation ? multiLocation[1] : locationOrName;
      var locationOffset = multiLocation ? Number(multiLocation[2]) : 0;

      if (this.configuration) {
        return {
          location: this.configuration.getAttributeLocation(name) + locationOffset,
          name: name
        };
      }

      return {
        location: -1
      };
    }
  }, {
    key: "_setAttribute",
    value: function _setAttribute(locationOrName, value) {
      if (value instanceof _buffer.default) {
        this.setBuffer(locationOrName, value);
      } else if (Array.isArray(value) && value.length && value[0] instanceof _buffer.default) {
        var buffer = value[0];
        var accessor = value[1];
        this.setBuffer(locationOrName, buffer, accessor);
      } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
        var constant = value;
        this.setConstant(locationOrName, constant);
      } else if (value.buffer instanceof _buffer.default) {
        var _accessor = value;
        this.setBuffer(locationOrName, _accessor.buffer, _accessor);
      } else {
        throw new Error(ERR_ATTRIBUTE_TYPE);
      }
    }
  }, {
    key: "_setConstantAttributes",
    value: function _setConstantAttributes(vertexCount, instanceCount) {
      var elementCount = Math.max(vertexCount | 0, instanceCount | 0);
      var constant = this.values[0];

      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttributeZero(constant, elementCount);
      }

      for (var location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        constant = this.values[location];

        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttribute(location, constant);
        }
      }
    }
  }, {
    key: "_setConstantAttributeZero",
    value: function _setConstantAttributeZero(constant, elementCount) {
      if (_vertexArrayObject.default.isSupported(this.gl, {
        constantAttributeZero: true
      })) {
        this._setConstantAttribute(0, constant);

        return;
      }

      var buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
      this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
  }, {
    key: "_setConstantAttribute",
    value: function _setConstantAttribute(location, constant) {
      _vertexArrayObject.default.setConstant(this.gl, location, constant);

      if (this.vertexArrayObject.isDefault) {
        this.vertexArrayObject.enable(location, false);
      }
    }
  }, {
    key: "_updateDrawParams",
    value: function _updateDrawParams() {
      var drawParams = {
        isIndexed: false,
        isInstanced: false,
        indexCount: Infinity,
        vertexCount: Infinity,
        instanceCount: Infinity
      };

      for (var location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        this._updateDrawParamsForLocation(drawParams, location);
      }

      if (this.elements) {
        drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
        drawParams.isIndexed = true;
        drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
        drawParams.indexOffset = this.elementsAccessor.offset || 0;
      }

      if (drawParams.indexCount === Infinity) {
        drawParams.indexCount = 0;
      }

      if (drawParams.vertexCount === Infinity) {
        drawParams.vertexCount = 0;
      }

      if (drawParams.instanceCount === Infinity) {
        drawParams.instanceCount = 0;
      }

      return drawParams;
    }
  }, {
    key: "_updateDrawParamsForLocation",
    value: function _updateDrawParamsForLocation(drawParams, location) {
      var value = this.values[location];
      var accessor = this.accessors[location];

      if (!value) {
        return;
      }

      var divisor = accessor.divisor;
      var isInstanced = divisor > 0;
      drawParams.isInstanced = drawParams.isInstanced || isInstanced;

      if (value instanceof _buffer.default) {
        var buffer = value;

        if (isInstanced) {
          var instanceCount = buffer.getVertexCount(accessor);
          drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
        } else {
          var vertexCount = buffer.getVertexCount(accessor);
          drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
        }
      }
    }
  }, {
    key: "setElements",
    value: function setElements() {
      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _utils.log.deprecated('setElements', 'setElementBuffer')();

      return this.setElementBuffer(elementBuffer, accessor);
    }
  }]);
  return VertexArray;
}();

exports.default = VertexArray;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./accessor":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","./buffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./vertex-array-object":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_ARGUMENT = 'UniformBufferLayout illegal argument';
var GL_FLOAT = 0x1406;
var GL_INT = 0x1404;
var GL_UNSIGNED_INT = 0x1405;

var UniformBufferLayout = function () {
  function UniformBufferLayout(layout) {
    var _this$typedArray;

    (0, _classCallCheck2.default)(this, UniformBufferLayout);
    this.layout = {};
    this.size = 0;

    for (var key in layout) {
      this._addUniform(key, layout[key]);
    }

    this.size += (4 - this.size % 4) % 4;
    var data = new Float32Array(this.size);
    this.typedArray = (_this$typedArray = {}, (0, _defineProperty2.default)(_this$typedArray, GL_FLOAT, data), (0, _defineProperty2.default)(_this$typedArray, GL_INT, new Int32Array(data.buffer)), (0, _defineProperty2.default)(_this$typedArray, GL_UNSIGNED_INT, new Uint32Array(data.buffer)), _this$typedArray);
  }

  (0, _createClass2.default)(UniformBufferLayout, [{
    key: "getBytes",
    value: function getBytes() {
      return this.size * 4;
    }
  }, {
    key: "getData",
    value: function getData() {
      return this.typedArray[GL_FLOAT];
    }
  }, {
    key: "getSubData",
    value: function getSubData(index) {
      var data;
      var offset;

      if (index === undefined) {
        data = this.data;
        offset = 0;
      } else {
        var begin = this.offsets[index];
        var end = begin + this.sizes[index];
        data = this.data.subarray(begin, end);
        offset = begin * 4;
      }

      return {
        data: data,
        offset: offset
      };
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(values) {
      for (var key in values) {
        this._setValue(key, values[key]);
      }

      return this;
    }
  }, {
    key: "_setValue",
    value: function _setValue(key, value) {
      var layout = this.layout[key];
      (0, _utils.assert)(layout, 'UniformLayoutStd140 illegal argument');
      var typedArray = this.typedArray[layout.type];

      if (layout.size === 1) {
        typedArray[layout.offset] = value;
      } else {
        typedArray.set(value, layout.offset);
      }
    }
  }, {
    key: "_addUniform",
    value: function _addUniform(key, uniformType) {
      var typeAndComponents = (0, _attributeUtils.decomposeCompositeGLType)(uniformType);
      (0, _utils.assert)(typeAndComponents, ERR_ARGUMENT);
      var type = typeAndComponents.type,
          count = typeAndComponents.components;
      this.size = this._alignTo(this.size, count);
      var offset = this.size;
      this.size += count;
      this.layout[key] = {
        type: type,
        size: count,
        offset: offset
      };
    }
  }, {
    key: "_alignTo",
    value: function _alignTo(size, count) {
      switch (count) {
        case 1:
          return size;

        case 2:
          return size + size % 2;

        default:
          return size + (4 - size % 4) % 4;
      }
    }
  }]);
  return UniformBufferLayout;
}();

exports.default = UniformBufferLayout;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../webgl-utils/attribute-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForUniforms = getDebugTableForUniforms;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDebugTableForUniforms() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$header = _ref.header,
      header = _ref$header === void 0 ? 'Uniforms' : _ref$header,
      program = _ref.program,
      uniforms = _ref.uniforms,
      _ref$undefinedOnly = _ref.undefinedOnly,
      undefinedOnly = _ref$undefinedOnly === void 0 ? false : _ref$undefinedOnly;

  (0, _utils.assert)(program);
  var SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';
  var PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix';
  var uniformLocations = program._uniformSetters;
  var table = {};
  var uniformNames = Object.keys(uniformLocations).sort();
  var count = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = uniformNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _uniformName = _step.value;

      if (!_uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !_uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table: table,
          header: header,
          uniforms: uniforms,
          uniformName: _uniformName,
          undefinedOnly: undefinedOnly
        })) {
          count++;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = uniformNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _uniformName2 = _step2.value;

      if (_uniformName2.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table: table,
          header: header,
          uniforms: uniforms,
          uniformName: _uniformName2,
          undefinedOnly: undefinedOnly
        })) {
          count++;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = uniformNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _uniformName3 = _step3.value;

      if (!table[_uniformName3]) {
        if (addUniformToTable({
          table: table,
          header: header,
          uniforms: uniforms,
          uniformName: _uniformName3,
          undefinedOnly: undefinedOnly
        })) {
          count++;
        }
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  var unusedCount = 0;
  var unusedTable = {};

  if (!undefinedOnly) {
    for (var uniformName in uniforms) {
      var uniform = uniforms[uniformName];

      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = (0, _defineProperty2.default)({
          Type: "NOT USED: ".concat(uniform)
        }, header, (0, _utils.formatValue)(uniform));
      }
    }
  }

  return {
    table: table,
    count: count,
    unusedTable: unusedTable,
    unusedCount: unusedCount
  };
}

function addUniformToTable(_ref2) {
  var table = _ref2.table,
      header = _ref2.header,
      uniforms = _ref2.uniforms,
      uniformName = _ref2.uniformName,
      undefinedOnly = _ref2.undefinedOnly;
  var value = uniforms[uniformName];
  var isDefined = isUniformDefined(value);

  if (!undefinedOnly || !isDefined) {
    var _table$uniformName;

    table[uniformName] = (_table$uniformName = {}, (0, _defineProperty2.default)(_table$uniformName, header, isDefined ? (0, _utils.formatValue)(value) : 'N/A'), (0, _defineProperty2.default)(_table$uniformName, 'Uniform Type', isDefined ? value : 'NOT PROVIDED'), _table$uniformName);
    return true;
  }

  return false;
}

function isUniformDefined(value) {
  return value !== undefined && value !== null;
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForVertexArray = getDebugTableForVertexArray;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _buffer = _interopRequireDefault(require("../classes/buffer"));

var _webglUtils = require("../webgl-utils");

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDebugTableForVertexArray() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      vertexArray = _ref.vertexArray,
      _ref$header = _ref.header,
      header = _ref$header === void 0 ? 'Attributes' : _ref$header;

  if (!vertexArray.configuration) {
    return {};
  }

  var table = {};

  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }

  var attributes = vertexArray.values;

  for (var attributeLocation in attributes) {
    var info = vertexArray._getAttributeInfo(attributeLocation);

    if (info) {
      var rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
      var accessor = vertexArray.accessors[info.location];

      if (accessor) {
        rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
      }

      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }

  return table;
}

function getDebugTableRow(vertexArray, attribute, accessor, header) {
  var _ref3;

  var gl = vertexArray.gl;
  var type = 'NOT PROVIDED';
  var size = 'N/A';
  var verts = 'N/A';
  var bytes = 'N/A';
  var isInteger;
  var marker;
  var value;

  if (accessor) {
    type = accessor.type;
    size = accessor.size;
    type = String(type).replace('Array', '');
    isInteger = type.indexOf('nt') !== -1;
  }

  if (attribute instanceof _buffer.default) {
    var _ref2;

    var buffer = attribute;

    var _buffer$getDebugData = buffer.getDebugData(),
        data = _buffer$getDebugData.data,
        modified = _buffer$getDebugData.modified;

    marker = modified ? '*' : '';
    value = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;
    var format;

    if (accessor) {
      var instanced = accessor.divisor > 0;
      format = "".concat(instanced ? 'I ' : 'P ', " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat((0, _webglUtils.getKey)(gl, type), ")");
    } else {
      isInteger = true;
      format = "".concat(bytes, " bytes");
    }

    return _ref2 = {}, (0, _defineProperty2.default)(_ref2, header, "".concat(marker).concat((0, _utils.formatValue)(value, {
      size: size,
      isInteger: isInteger
    }))), (0, _defineProperty2.default)(_ref2, 'Format ', format), _ref2;
  }

  value = attribute;
  size = attribute.length;
  type = String(attribute.constructor.name).replace('Array', '');
  isInteger = type.indexOf('nt') !== -1;
  return _ref3 = {}, (0, _defineProperty2.default)(_ref3, header, "".concat((0, _utils.formatValue)(value, {
    size: size,
    isInteger: isInteger
  }), " (constant)")), (0, _defineProperty2.default)(_ref3, 'Format ', "".concat(size, "x").concat(type, " (constant)")), _ref3;
}

function getGLSLDeclaration(name, accessor) {
  var type = accessor.type,
      size = accessor.size;
  var typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);

  if (typeAndName) {
    return "".concat(name, " (").concat(typeAndName.name, ")");
  }

  return name;
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../classes/buffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../webgl-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/index.js","../webgl-utils/attribute-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForProgramConfiguration = getDebugTableForProgramConfiguration;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _attributeUtils = require("../webgl-utils/attribute-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDebugTableForProgramConfiguration(config) {
  var table = {};
  var header = "Accessors for ".concat(config.id);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = config.attributeInfos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var attributeInfo = _step.value;

      if (attributeInfo) {
        var glslDeclaration = getGLSLDeclaration(attributeInfo);
        table["in ".concat(glslDeclaration)] = (0, _defineProperty2.default)({}, header, JSON.stringify(attributeInfo.accessor));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = config.varyingInfos[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var varyingInfo = _step2.value;

      if (varyingInfo) {
        var _glslDeclaration = getGLSLDeclaration(varyingInfo);

        table["out ".concat(_glslDeclaration)] = (0, _defineProperty2.default)({}, header, JSON.stringify(varyingInfo.accessor));
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return table;
}

function getGLSLDeclaration(attributeInfo) {
  var _attributeInfo$access = attributeInfo.accessor,
      type = _attributeInfo$access.type,
      size = _attributeInfo$access.size;
  var typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);

  if (typeAndName) {
    return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
  }

  return attributeInfo.name;
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../webgl-utils/attribute-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"}],"../../../node_modules/@luma.gl/webgl/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function () {
    return _init.lumaStats;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.resetParameters;
  }
});
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.setParameter;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.setParameters;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.withParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getModifiedParameters;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _webglTypes.Image;
  }
});
Object.defineProperty(exports, "WebGLRenderingContext", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLRenderingContext;
  }
});
Object.defineProperty(exports, "WebGLProgram", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLProgram;
  }
});
Object.defineProperty(exports, "WebGLShader", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLShader;
  }
});
Object.defineProperty(exports, "WebGLBuffer", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLBuffer;
  }
});
Object.defineProperty(exports, "WebGLFramebuffer", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLFramebuffer;
  }
});
Object.defineProperty(exports, "WebGLRenderbuffer", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLRenderbuffer;
  }
});
Object.defineProperty(exports, "WebGLTexture", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLTexture;
  }
});
Object.defineProperty(exports, "WebGLUniformLocation", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLUniformLocation;
  }
});
Object.defineProperty(exports, "WebGLActiveInfo", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLActiveInfo;
  }
});
Object.defineProperty(exports, "WebGLShaderPrecisionFormat", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGLShaderPrecisionFormat;
  }
});
Object.defineProperty(exports, "WebGL2RenderingContext", {
  enumerable: true,
  get: function () {
    return _webglTypes.WebGL2RenderingContext;
  }
});
Object.defineProperty(exports, "webGLTypesAvailable", {
  enumerable: true,
  get: function () {
    return _webglTypes.webGLTypesAvailable;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _context.createGLContext;
  }
});
Object.defineProperty(exports, "destroyGLContext", {
  enumerable: true,
  get: function () {
    return _context.destroyGLContext;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function () {
    return _context.resizeGLContext;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function () {
    return _context.instrumentGLContext;
  }
});
Object.defineProperty(exports, "setGLContextDefaults", {
  enumerable: true,
  get: function () {
    return _context.setGLContextDefaults;
  }
});
Object.defineProperty(exports, "getCanvas", {
  enumerable: true,
  get: function () {
    return _createCanvas.getCanvas;
  }
});
Object.defineProperty(exports, "getPageLoadPromise", {
  enumerable: true,
  get: function () {
    return _createCanvas.getPageLoadPromise;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "cancelAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.cancelAnimationFrame;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL2;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _textureUtils.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKeyValue;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKey;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "getContextDebugInfo", {
  enumerable: true,
  get: function () {
    return _getContextDebugInfo.getContextDebugInfo;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _features.hasFeatures;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _checkGlslExtension.default;
  }
});
Object.defineProperty(exports, "Accessor", {
  enumerable: true,
  get: function () {
    return _accessor.default;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function () {
    return _buffer.default;
  }
});
Object.defineProperty(exports, "Shader", {
  enumerable: true,
  get: function () {
    return _shader.Shader;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function () {
    return _shader.VertexShader;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function () {
    return _shader.FragmentShader;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _program.default;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function () {
    return _framebuffer.default;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function () {
    return _renderbuffer.default;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function () {
    return _texture2d.default;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function () {
    return _textureCube.default;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function () {
    return _clear.clear;
  }
});
Object.defineProperty(exports, "clearBuffer", {
  enumerable: true,
  get: function () {
    return _clear.clearBuffer;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "copyToDataUrl", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToDataUrl;
  }
});
Object.defineProperty(exports, "copyToImage", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToImage;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToTexture;
  }
});
Object.defineProperty(exports, "blit", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.blit;
  }
});
Object.defineProperty(exports, "Query", {
  enumerable: true,
  get: function () {
    return _query.default;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function () {
    return _texture3d.default;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function () {
    return _transformFeedback.default;
  }
});
Object.defineProperty(exports, "VertexArrayObject", {
  enumerable: true,
  get: function () {
    return _vertexArrayObject.default;
  }
});
Object.defineProperty(exports, "VertexArray", {
  enumerable: true,
  get: function () {
    return _vertexArray.default;
  }
});
Object.defineProperty(exports, "UniformBufferLayout", {
  enumerable: true,
  get: function () {
    return _uniformBufferLayout.default;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _loadFile.setPathPrefix;
  }
});
Object.defineProperty(exports, "loadFile", {
  enumerable: true,
  get: function () {
    return _loadFile.loadFile;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _loadFile.loadImage;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function () {
    return _getShaderName.default;
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function () {
    return _getShaderVersion.default;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _utils.uid;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function () {
    return _utils.isObjectEmpty;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "parseUniformName", {
  enumerable: true,
  get: function () {
    return _uniforms.parseUniformName;
  }
});
Object.defineProperty(exports, "getUniformSetter", {
  enumerable: true,
  get: function () {
    return _uniforms.getUniformSetter;
  }
});
Object.defineProperty(exports, "getDebugTableForUniforms", {
  enumerable: true,
  get: function () {
    return _debugUniforms.getDebugTableForUniforms;
  }
});
Object.defineProperty(exports, "getDebugTableForVertexArray", {
  enumerable: true,
  get: function () {
    return _debugVertexArray.getDebugTableForVertexArray;
  }
});
Object.defineProperty(exports, "getDebugTableForProgramConfiguration", {
  enumerable: true,
  get: function () {
    return _debugProgramConfiguration.getDebugTableForProgramConfiguration;
  }
});

var _init = require("./init");

var _webglStateTracker = require("@luma.gl/webgl-state-tracker");

var _webglTypes = require("./webgl-utils/webgl-types");

var _context = require("./context/context");

var _createCanvas = require("./context/create-canvas");

var _requestAnimationFrame = require("./webgl-utils/request-animation-frame");

var _webglChecks = require("./webgl-utils/webgl-checks");

var _textureUtils = require("./webgl-utils/texture-utils");

var _constantsToKeys = require("./webgl-utils/constants-to-keys");

var _limits = require("./features/limits");

var _getContextDebugInfo = require("./debug/get-context-debug-info");

var _webglFeaturesTable = require("./features/webgl-features-table");

var _features = require("./features/features");

var _checkGlslExtension = _interopRequireDefault(require("./features/check-glsl-extension"));

var _accessor = _interopRequireDefault(require("./classes/accessor"));

var _buffer = _interopRequireDefault(require("./classes/buffer"));

var _shader = require("./classes/shader");

var _program = _interopRequireDefault(require("./classes/program"));

var _framebuffer = _interopRequireDefault(require("./classes/framebuffer"));

var _renderbuffer = _interopRequireDefault(require("./classes/renderbuffer"));

var _texture2d = _interopRequireDefault(require("./classes/texture-2d"));

var _textureCube = _interopRequireDefault(require("./classes/texture-cube"));

var _clear = require("./classes/clear");

var _copyAndBlit = require("./classes/copy-and-blit");

var _query = _interopRequireDefault(require("./classes/query"));

var _texture3d = _interopRequireDefault(require("./classes/texture-3d"));

var _transformFeedback = _interopRequireDefault(require("./classes/transform-feedback"));

var _vertexArrayObject = _interopRequireDefault(require("./classes/vertex-array-object"));

var _vertexArray = _interopRequireDefault(require("./classes/vertex-array"));

var _uniformBufferLayout = _interopRequireDefault(require("./classes/uniform-buffer-layout"));

var _loadFile = require("./utils/load-file");

var _getShaderName = _interopRequireDefault(require("./glsl-utils/get-shader-name"));

var _getShaderVersion = _interopRequireDefault(require("./glsl-utils/get-shader-version"));

var _log = _interopRequireDefault(require("./utils/log"));

var _assert = _interopRequireDefault(require("./utils/assert"));

var _utils = require("./utils/utils");

var _globals = require("./utils/globals");

var _isBrowser = _interopRequireDefault(require("./utils/is-browser"));

var _uniforms = require("./classes/uniforms");

var _debugUniforms = require("./debug/debug-uniforms");

var _debugVertexArray = require("./debug/debug-vertex-array");

var _debugProgramConfiguration = require("./debug/debug-program-configuration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./init":"../../../node_modules/@luma.gl/webgl/dist/esm/init.js","@luma.gl/webgl-state-tracker":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/index.js","./webgl-utils/webgl-types":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/webgl-types.js","./context/context":"../../../node_modules/@luma.gl/webgl/dist/esm/context/context.js","./context/create-canvas":"../../../node_modules/@luma.gl/webgl/dist/esm/context/create-canvas.js","./webgl-utils/request-animation-frame":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js","./webgl-utils/webgl-checks":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/webgl-checks.js","./webgl-utils/texture-utils":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js","./webgl-utils/constants-to-keys":"../../../node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","./features/limits":"../../../node_modules/@luma.gl/webgl/dist/esm/features/limits.js","./debug/get-context-debug-info":"../../../node_modules/@luma.gl/webgl/dist/esm/debug/get-context-debug-info.js","./features/webgl-features-table":"../../../node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","./features/features":"../../../node_modules/@luma.gl/webgl/dist/esm/features/features.js","./features/check-glsl-extension":"../../../node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js","./classes/accessor":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","./classes/buffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./classes/shader":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/shader.js","./classes/program":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/program.js","./classes/framebuffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./classes/renderbuffer":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./classes/texture-2d":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","./classes/texture-cube":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js","./classes/clear":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/clear.js","./classes/copy-and-blit":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js","./classes/query":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/query.js","./classes/texture-3d":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js","./classes/transform-feedback":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js","./classes/vertex-array-object":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js","./classes/vertex-array":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js","./classes/uniform-buffer-layout":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js","./utils/load-file":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js","./glsl-utils/get-shader-name":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./glsl-utils/get-shader-version":"../../../node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js","./utils/log":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/log.js","./utils/assert":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","./utils/utils":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","./utils/globals":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/globals.js","./utils/is-browser":"../../../node_modules/@luma.gl/webgl/dist/esm/utils/is-browser.js","./classes/uniforms":"../../../node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js","./debug/debug-uniforms":"../../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js","./debug/debug-vertex-array":"../../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js","./debug/debug-program-configuration":"../../../node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js"}],"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _webgl.assert;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _webgl.log;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _webgl.uid;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function () {
    return _webgl.isObjectEmpty;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _webgl.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _webgl.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _webgl.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _webgl.document;
  }
});

var _webgl = require("@luma.gl/webgl");
},{"@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DRAW_MODE = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DRAW_MODE = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006
};
exports.DRAW_MODE = DRAW_MODE;

var Geometry = function () {
  (0, _createClass2.default)(Geometry, null, [{
    key: "DRAW_MODE",
    get: function get() {
      return DRAW_MODE;
    }
  }]);

  function Geometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Geometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('geometry') : _props$id,
        _props$drawMode = props.drawMode,
        drawMode = _props$drawMode === void 0 ? DRAW_MODE.TRIANGLES : _props$drawMode,
        mode = props.mode,
        _props$attributes = props.attributes,
        attributes = _props$attributes === void 0 ? {} : _props$attributes,
        _props$indices = props.indices,
        indices = _props$indices === void 0 ? null : _props$indices,
        _props$vertexCount = props.vertexCount,
        vertexCount = _props$vertexCount === void 0 ? null : _props$vertexCount;
    this.id = id;
    this.drawMode = drawMode | 0 || mode | 0;
    this.attributes = {};
    this.userData = {};

    this._setAttributes(attributes, indices);

    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }

  (0, _createClass2.default)(Geometry, [{
    key: "getVertexCount",
    value: function getVertexCount() {
      return this.vertexCount;
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.indices ? (0, _objectSpread2.default)({
        indices: this.indices
      }, this.attributes) : this.attributes;
    }
  }, {
    key: "_print",
    value: function _print(attributeName) {
      return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
    }
  }, {
    key: "_setAttributes",
    value: function _setAttributes(attributes, indices) {
      if (indices) {
        this.indices = ArrayBuffer.isView(indices) ? {
          value: indices,
          size: 1
        } : indices;
      }

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        attribute = ArrayBuffer.isView(attribute) ? {
          value: attribute
        } : attribute;
        (0, _utils.assert)(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));

        if (attributeName === 'indices') {
          (0, _utils.assert)(!this.indices);
          this.indices = attribute;

          if (this.indices.isIndexed !== undefined) {
            this.indices = Object.assign({}, this.indices);
            delete this.indices.isIndexed;
          }
        } else {
          this.attributes[attributeName] = attribute;
        }
      }

      return this;
    }
  }, {
    key: "_calculateVertexCount",
    value: function _calculateVertexCount(attributes, indices) {
      if (indices) {
        return indices.value.length;
      }

      var vertexCount = Infinity;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var value = attribute.value,
            size = attribute.size,
            constant = attribute.constant;

        if (!constant && value && size >= 1) {
          vertexCount = Math.min(vertexCount, value.length / size);
        }
      }

      if (!Number.isFinite(vertexCount)) {
        var _attribute = attributes.POSITION || attributes.positions;

        if (_attribute) {
          vertexCount = _attribute.value && _attribute.value.length / (_attribute.size || 3);
        }
      }

      (0, _utils.assert)(Number.isFinite(vertexCount));
      return vertexCount;
    }
  }, {
    key: "mode",
    get: function get() {
      return this.drawMode;
    }
  }]);
  return Geometry;
}();

exports.default = Geometry;
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/materials/material.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Material = function Material() {
  (0, _classCallCheck2.default)(this, Material);
};

exports.default = Material;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js"}],"../../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _isNativeFunction;

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _wrapNativeSuper;

var _getPrototypeOf = _interopRequireDefault(require("./getPrototypeOf"));

var _setPrototypeOf = _interopRequireDefault(require("./setPrototypeOf"));

var _isNativeFunction = _interopRequireDefault(require("./isNativeFunction"));

var _construct = _interopRequireDefault(require("./construct"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  exports.default = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !(0, _isNativeFunction.default)(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return (0, _construct.default)(Class, arguments, (0, _getPrototypeOf.default)(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return (0, _setPrototypeOf.default)(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}
},{"./getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","./setPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","./isNativeFunction":"../../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","./construct":"../../../node_modules/@babel/runtime/helpers/esm/construct.js"}],"../../../node_modules/math.gl/dist/esm/lib/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configure = configure;
exports.checkNumber = checkNumber;
exports.formatValue = formatValue;
exports.formatAngle = formatAngle;
exports.isArray = isArray;
exports.clone = clone;
exports.radians = radians;
exports.degrees = degrees;
exports.sin = sin;
exports.cos = cos;
exports.tan = tan;
exports.asin = asin;
exports.acos = acos;
exports.atan = atan;
exports.clamp = clamp;
exports.lerp = lerp;
exports.equals = equals;
exports.config = void 0;
var config = {};
exports.config = config;
config.EPSILON = 1e-12;
config.debug = true;
config.precision = 4;
config.printTypes = false;
config.printDegrees = false;
config.printRowMajor = true;

function configure(options) {
  if ('epsilon' in options) {
    config.EPSILON = options.epsilon;
  }

  if ('debug' in options) {
    config.debug = options.debug;
  }
}

function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }

  return value;
}

function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

function formatValue(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$precision = _ref.precision,
      precision = _ref$precision === void 0 ? config.precision || 4 : _ref$precision;

  value = round(value);
  return parseFloat(value.toPrecision(precision));
}

function formatAngle(value) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$precision = _ref2.precision,
      precision = _ref2$precision === void 0 ? config.precision || 4 : _ref2$precision,
      _ref2$printDegrees = _ref2.printDegrees,
      printDegrees = _ref2$printDegrees === void 0 ? config.printAngles : _ref2$printDegrees;

  value = printDegrees ? degrees(value) : value;
  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision))).concat(printDegrees ? '°' : '');
}

function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && value.length !== undefined;
}

function clone(array) {
  return array.clone ? array.clone() : new Array(array);
}

function map(value, func) {
  if (isArray(value)) {
    var result = clone(value);

    for (var i = 0; i < result.length; ++i) {
      result[i] = func(result[i], i, result);
    }

    return result;
  }

  return func(value);
}

function radians(degrees) {
  return map(degrees, function (degrees) {
    return degrees / 180 * Math.PI;
  });
}

function degrees(radians) {
  return map(radians, function (radians) {
    return radians * 180 / Math.PI;
  });
}

function sin(radians) {
  return map(radians, function (angle) {
    return Math.sin(angle);
  });
}

function cos(radians) {
  return map(radians, function (angle) {
    return Math.cos(angle);
  });
}

function tan(radians) {
  return map(radians, function (angle) {
    return Math.tan(angle);
  });
}

function asin(radians) {
  return map(radians, function (angle) {
    return Math.asin(angle);
  });
}

function acos(radians) {
  return map(radians, function (angle) {
    return Math.acos(angle);
  });
}

function atan(radians) {
  return map(radians, function (angle) {
    return Math.atan(angle);
  });
}

function clamp(value, min, max) {
  return map(value, function (value) {
    return Math.max(min, Math.min(max, value));
  });
}

function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map(function (ai, i) {
      return lerp(ai, b[i], t);
    });
  }

  return t * b + (1 - t) * a;
}

function equals(a, b) {
  if (isArray(a) && isArray(b)) {
    if (a === b) {
      return true;
    }

    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; ++i) {
      if (!equals(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }

  return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
},{}],"../../../node_modules/math.gl/dist/esm/lib/math-array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/wrapNativeSuper"));

var _common = require("./common");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MathArray = function (_Array) {
  (0, _inherits2.default)(MathArray, _Array);

  function MathArray() {
    (0, _classCallCheck2.default)(this, MathArray);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MathArray).apply(this, arguments));
  }

  (0, _createClass2.default)(MathArray, [{
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this).check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i];
      }

      return this.check();
    }
  }, {
    key: "set",
    value: function set() {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = (i < 0 || arguments.length <= i ? undefined : arguments[i]) || 0;
      }

      return this.check();
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i + offset];
      }

      return this.check();
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.formatString(_common.config);
    }
  }, {
    key: "formatString",
    value: function formatString(opts) {
      var string = '';

      for (var i = 0; i < this.ELEMENTS; ++i) {
        string += (i > 0 ? ', ' : '') + (0, _common.formatValue)(this[i], opts);
      }

      return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        array[offset + i] = this[i];
      }

      return array;
    }
  }, {
    key: "toFloat32Array",
    value: function toFloat32Array() {
      return new Float32Array(this);
    }
  }, {
    key: "equals",
    value: function equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (!(0, _common.equals)(this[i], array[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "negate",
    value: function negate() {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = -this[i];
      }

      return this.check();
    }
  }, {
    key: "inverse",
    value: function inverse() {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = 1 / this[i];
      }

      return this.check();
    }
  }, {
    key: "lerp",
    value: function lerp(a, b, t) {
      if (t === undefined) {
        t = b;
        b = a;
        a = this;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        var ai = a[i];
        this[i] = ai + t * (b[i] - ai);
      }

      return this.check();
    }
  }, {
    key: "min",
    value: function min(vector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(vector[i], this[i]);
      }

      return this.check();
    }
  }, {
    key: "max",
    value: function max(vector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.max(vector[i], this[i]);
      }

      return this.check();
    }
  }, {
    key: "clamp",
    value: function clamp(minVector, maxVector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
      }

      return this.check();
    }
  }, {
    key: "validate",
    value: function validate() {
      var valid = this.length === this.ELEMENTS;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(this[i]);
      }

      return valid;
    }
  }, {
    key: "check",
    value: function check() {
      if (_common.config.debug && !this.validate(this)) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }

      return this;
    }
  }, {
    key: "sub",
    value: function sub(a) {
      return this.subtract(a);
    }
  }, {
    key: "setScalar",
    value: function setScalar(a) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = a;
      }

      return this.check();
    }
  }, {
    key: "addScalar",
    value: function addScalar(a) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] += a;
      }

      return this.check();
    }
  }, {
    key: "subScalar",
    value: function subScalar(a) {
      return this.addScalar(-a);
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(a) {
      return this.scale(a);
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(a) {
      return this.scale(1 / a);
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(min, max) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], min), max);
      }

      return this.check();
    }
  }]);
  return MathArray;
}((0, _wrapNativeSuper2.default)(Array));

exports.default = MathArray;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@babel/runtime/helpers/esm/wrapNativeSuper":"../../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","./common":"../../../node_modules/math.gl/dist/esm/lib/common.js"}],"../../../node_modules/math.gl/dist/esm/lib/vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _mathArray = _interopRequireDefault(require("./math-array"));

var _common = require("./common");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assert = function assert(x, m) {
  if (!x) {
    throw new Error(m);
  }
};

var Vector = function (_MathArray) {
  (0, _inherits2.default)(Vector, _MathArray);

  function Vector() {
    (0, _classCallCheck2.default)(this, Vector);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Vector).apply(this, arguments));
  }

  (0, _createClass2.default)(Vector, [{
    key: "len",
    value: function len() {
      return Math.sqrt(this.lengthSquared());
    }
  }, {
    key: "magnitude",
    value: function magnitude() {
      return Math.sqrt(this.lengthSquared());
    }
  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      var length = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        length += this[i] * this[i];
      }

      return length;
    }
  }, {
    key: "distance",
    value: function distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
  }, {
    key: "distanceSquared",
    value: function distanceSquared(mathArray) {
      var length = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        var dist = this[i] - mathArray[i];
        length += dist * dist;
      }

      return (0, _common.checkNumber)(length);
    }
  }, {
    key: "dot",
    value: function dot(mathArray) {
      var product = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        product += this[i] * mathArray[i];
      }

      return (0, _common.checkNumber)(product);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var length = this.magnitude();

      if (length !== 0) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= length;
        }
      }

      return this.check();
    }
  }, {
    key: "add",
    value: function add() {
      for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      for (var _i = 0; _i < vectors.length; _i++) {
        var vector = vectors[_i];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] += vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "subtract",
    value: function subtract() {
      for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        vectors[_key2] = arguments[_key2];
      }

      for (var _i2 = 0; _i2 < vectors.length; _i2++) {
        var vector = vectors[_i2];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] -= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "multiply",
    value: function multiply() {
      for (var _len3 = arguments.length, vectors = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        vectors[_key3] = arguments[_key3];
      }

      for (var _i3 = 0; _i3 < vectors.length; _i3++) {
        var vector = vectors[_i3];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "divide",
    value: function divide() {
      for (var _len4 = arguments.length, vectors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        vectors[_key4] = arguments[_key4];
      }

      for (var _i4 = 0; _i4 < vectors.length; _i4++) {
        var vector = vectors[_i4];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(_scale) {
      if (Array.isArray(_scale)) {
        return this.multiply(_scale);
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= _scale;
      }

      return this.check();
    }
  }, {
    key: "scaleAndAdd",
    value: function scaleAndAdd(vector, scale) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = this[i] * scale + vector[i];
      }

      return this.check();
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.lengthSquared();
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(vector) {
      return this.distance(vector);
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
  }, {
    key: "getComponent",
    value: function getComponent(i) {
      assert(i >= 0 && i < this.ELEMENTS, 'index is out of range');
      return (0, _common.checkNumber)(this[i]);
    }
  }, {
    key: "setComponent",
    value: function setComponent(i, value) {
      assert(i >= 0 && i < this.ELEMENTS, 'index is out of range');
      this[i] = value;
      return this.check();
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      return this.copy(a).add(b);
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      return this.copy(a).subtract(b);
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(a, b) {
      return this.copy(a).multiply(b);
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(a, b) {
      return this.add(new this.constructor(a).multiplyScalar(b));
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }]);
  return Vector;
}(_mathArray.default);

exports.default = Vector;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./math-array":"../../../node_modules/math.gl/dist/esm/lib/math-array.js","./common":"../../../node_modules/math.gl/dist/esm/lib/common.js"}],"../../../node_modules/gl-matrix/esm/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
},{}],"../../../node_modules/gl-matrix/esm/vec2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.rotate = rotate;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */


function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"../../../node_modules/gl-matrix/esm/common.js"}],"../../../node_modules/math.gl/dist/esm/vector2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _vector = _interopRequireDefault(require("./lib/vector"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Vector2 = function (_Vector) {
  (0, _inherits2.default)(Vector2, _Vector);

  function Vector2() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, Vector2);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Vector2).call(this, 2));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y);
    }

    return _this;
  }

  (0, _createClass2.default)(Vector2, [{
    key: "cross",
    value: function cross(vector) {
      vec2.cross(this, this, vector);
      return this.check();
    }
  }, {
    key: "horizontalAngle",
    value: function horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
  }, {
    key: "verticalAngle",
    value: function verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
  }, {
    key: "operation",
    value: function operation(_operation) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      _operation.apply(void 0, [this, this].concat(args));

      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 2;
    }
  }]);
  return Vector2;
}(_vector.default);

exports.default = Vector2;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./lib/vector":"../../../node_modules/math.gl/dist/esm/lib/vector.js","gl-matrix/vec2":"../../../node_modules/gl-matrix/esm/vec2.js"}],"../../../node_modules/gl-matrix/esm/vec3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */


function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"../../../node_modules/gl-matrix/esm/common.js"}],"../../../node_modules/math.gl/dist/esm/vector3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _vector = _interopRequireDefault(require("./lib/vector"));

var _common = require("./lib/common");

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ORIGIN = [0, 0, 0];

var Vector3 = function (_Vector) {
  (0, _inherits2.default)(Vector3, _Vector);

  function Vector3() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    (0, _classCallCheck2.default)(this, Vector3);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Vector3).call(this, 3));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z);
    }

    return _this;
  }

  (0, _createClass2.default)(Vector3, [{
    key: "angle",
    value: function angle(vector) {
      return vec3.angle(this, vector);
    }
  }, {
    key: "cross",
    value: function cross(vector) {
      vec3.cross(this, this, vector);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(_ref) {
      var radians = _ref.radians,
          _ref$origin = _ref.origin,
          origin = _ref$origin === void 0 ? ORIGIN : _ref$origin;
      vec3.rotateX(this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(_ref2) {
      var radians = _ref2.radians,
          _ref2$origin = _ref2.origin,
          origin = _ref2$origin === void 0 ? ORIGIN : _ref2$origin;
      vec3.rotateY(this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(_ref3) {
      var radians = _ref3.radians,
          _ref3$origin = _ref3.origin,
          origin = _ref3$origin === void 0 ? ORIGIN : _ref3$origin;
      vec3.rotateZ(this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "operation",
    value: function operation(_operation) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      _operation.apply(void 0, [this, this].concat(args));

      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 3;
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }]);
  return Vector3;
}(_vector.default);

exports.default = Vector3;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./lib/vector":"../../../node_modules/math.gl/dist/esm/lib/vector.js","./lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js","gl-matrix/vec3":"../../../node_modules/gl-matrix/esm/vec3.js"}],"../../../node_modules/math.gl/dist/esm/vector4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _vector = _interopRequireDefault(require("./lib/vector"));

var _common = require("./lib/common");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Vector4 = function (_Vector) {
  (0, _inherits2.default)(Vector4, _Vector);

  function Vector4() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    (0, _classCallCheck2.default)(this, Vector4);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Vector4).call(this, 4));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z, w);
    }

    return _this;
  }

  (0, _createClass2.default)(Vector4, [{
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      m.transformVector(this, this);
      return this;
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "w",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = (0, _common.checkNumber)(value);
    }
  }]);
  return Vector4;
}(_vector.default);

exports.default = Vector4;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./lib/vector":"../../../node_modules/math.gl/dist/esm/lib/vector.js","./lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js"}],"../../../node_modules/math.gl/dist/esm/lib/validators.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateVector = validateVector;

function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }

  return v.every(Number.isFinite);
}
},{}],"../../../node_modules/gl-matrix/esm/mat3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}

;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"../../../node_modules/gl-matrix/esm/common.js"}],"../../../node_modules/math.gl/dist/esm/matrix3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateMatrix3 = validateMatrix3;
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _mathArray = _interopRequireDefault(require("./lib/math-array"));

var _validators = require("./lib/validators");

var _common = require("./lib/common");

var _vector = _interopRequireDefault(require("./vector2"));

var _vector2 = _interopRequireDefault(require("./vector3"));

var mat3 = _interopRequireWildcard(require("gl-matrix/mat3"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IDENTITY = [1, 0, 0, 0, 1, 0, 0, 0, 1];

function validateMatrix3(m) {
  return m.length === 9 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]) && Number.isFinite(m[4]) && Number.isFinite(m[5]) && Number.isFinite(m[6]) && Number.isFinite(m[7]) && Number.isFinite(m[8]);
}

var Matrix3 = function (_MathArray) {
  (0, _inherits2.default)(Matrix3, _MathArray);

  function Matrix3() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _classCallCheck2.default)(this, Matrix3);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Matrix3).call(this, 9));

    if (Array.isArray(args[0]) && arguments.length === 1) {
      _this.copy(args[0]);
    } else {
      _this.identity();
    }

    return _this;
  }

  (0, _createClass2.default)(Matrix3, [{
    key: "setRowMajor",
    value: function setRowMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m01 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m02 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m10 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m11 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      var m12 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var m20 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m21 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m22 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
  }, {
    key: "setColumnMajor",
    value: function setColumnMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m01 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m11 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      var m21 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var m02 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m12 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m22 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      return this.setColumnMajor.apply(this, (0, _toConsumableArray2.default)(array));
    }
  }, {
    key: "set",
    value: function set() {
      return this.setColumnMajor.apply(this, arguments);
    }
  }, {
    key: "getElement",
    value: function getElement(i, j) {
      var columnMajor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return columnMajor ? this[i * 3 + j] : this[j * 3 + i];
    }
  }, {
    key: "setElement",
    value: function setElement(i, j, value) {
      var columnMajor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (columnMajor) {
        this[i * 3 + j] = (0, _common.checkNumber)(value);
      } else {
        this[j * 3 + i] = (0, _common.checkNumber)(value);
      }

      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      return mat3.determinant(this);
    }
  }, {
    key: "identity",
    value: function identity() {
      for (var i = 0; i < IDENTITY.length; ++i) {
        this[i] = IDENTITY[i];
      }

      return this.check();
    }
  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(q) {
      mat3.fromQuat(this, q);
      return this.check();
    }
  }, {
    key: "transpose",
    value: function transpose() {
      mat3.transpose(this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      mat3.invert(this, this);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a) {
      mat3.multiply(this, a, this);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a) {
      mat3.multiply(this, this, a);
      return this.check();
    }
  }, {
    key: "rotate",
    value: function rotate(radians) {
      mat3.rotate(this, this, radians);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (Array.isArray(factor)) {
        mat3.scale(this, this, factor);
      } else {
        mat3.scale(this, this, [factor, factor, factor]);
      }

      return this.check();
    }
  }, {
    key: "translate",
    value: function translate(vec) {
      mat3.translate(this, this, vec);
      return this.check();
    }
  }, {
    key: "transformVector2",
    value: function transformVector2(vector, out) {
      out = out || new _vector.default();
      vec2.transformMat3(out, vector, this);
      (0, _validators.validateVector)(out, 2);
      return out;
    }
  }, {
    key: "transformVector3",
    value: function transformVector3(vector, out) {
      out = out || new _vector2.default();
      vec3.transformMat3(out, vector, this);
      (0, _validators.validateVector)(out, 3);
      return out;
    }
  }, {
    key: "transformVector",
    value: function transformVector(vector, out) {
      switch (vector.length) {
        case 2:
          return this.transformVector2(vector, out);

        case 3:
          return this.transformVector3(vector, out);

        default:
          throw new Error('Illegal vector');
      }
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 9;
    }
  }]);
  return Matrix3;
}(_mathArray.default);

exports.default = Matrix3;
},{"@babel/runtime/helpers/esm/toConsumableArray":"../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./lib/math-array":"../../../node_modules/math.gl/dist/esm/lib/math-array.js","./lib/validators":"../../../node_modules/math.gl/dist/esm/lib/validators.js","./lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js","./vector2":"../../../node_modules/math.gl/dist/esm/vector2.js","./vector3":"../../../node_modules/math.gl/dist/esm/vector3.js","gl-matrix/mat3":"../../../node_modules/gl-matrix/esm/mat3.js","gl-matrix/vec2":"../../../node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"../../../node_modules/gl-matrix/esm/vec3.js"}],"../../../node_modules/gl-matrix/esm/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromQuat2 = fromQuat2;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}

;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"../../../node_modules/gl-matrix/esm/common.js"}],"../../../node_modules/gl-matrix/esm/vec4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}

;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"../../../node_modules/gl-matrix/esm/common.js"}],"../../../node_modules/math.gl/dist/esm/matrix4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateMatrix4 = validateMatrix4;
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _mathArray = _interopRequireDefault(require("./lib/math-array"));

var _common = require("./lib/common");

var _validators = require("./lib/validators");

var _vector = _interopRequireDefault(require("./vector2"));

var _vector2 = _interopRequireDefault(require("./vector3"));

var _vector3 = _interopRequireDefault(require("./vector4"));

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

function validateMatrix4(m) {
  return m.length === 16 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]) && Number.isFinite(m[4]) && Number.isFinite(m[5]) && Number.isFinite(m[6]) && Number.isFinite(m[7]) && Number.isFinite(m[8]) && Number.isFinite(m[9]) && Number.isFinite(m[10]) && Number.isFinite(m[11]) && Number.isFinite(m[12]) && Number.isFinite(m[13]) && Number.isFinite(m[14]) && Number.isFinite(m[15]);
}

var Matrix4 = function (_MathArray) {
  (0, _inherits2.default)(Matrix4, _MathArray);

  function Matrix4() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _classCallCheck2.default)(this, Matrix4);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Matrix4).call(this, 16));

    if (Array.isArray(args[0]) && arguments.length === 1) {
      _this.copy(args[0]);
    } else {
      _this.identity();
    }

    return _this;
  }

  (0, _createClass2.default)(Matrix4, [{
    key: "setRowMajor",
    value: function setRowMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m01 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m02 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m03 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m10 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var m11 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var m12 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m13 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m20 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var m21 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var m22 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
      var m23 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
      var m30 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
      var m31 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      var m32 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
      var m33 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
  }, {
    key: "setColumnMajor",
    value: function setColumnMajor() {
      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var m10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var m20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var m30 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var m01 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var m11 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var m21 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var m31 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var m02 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
      var m12 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var m22 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
      var m32 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
      var m03 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
      var m13 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
      var m23 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
      var m33 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
  }, {
    key: "set",
    value: function set() {
      return this.setColumnMajor.apply(this, arguments);
    }
  }, {
    key: "getElement",
    value: function getElement(i, j) {
      var columnMajor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return columnMajor ? this[i][j] : this[j][i];
    }
  }, {
    key: "setElement",
    value: function setElement(i, j, value) {
      var columnMajor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (columnMajor) {
        this[i][j] = (0, _common.checkNumber)(value);
      } else {
        this[j][i] = (0, _common.checkNumber)(value);
      }

      return this;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      return mat4.determinant(this);
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.copy(IDENTITY);
    }
  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(q) {
      mat4.fromQuat(this, q);
      return this.check();
    }
  }, {
    key: "frustum",
    value: function frustum(_ref) {
      var left = _ref.left,
          right = _ref.right,
          bottom = _ref.bottom,
          top = _ref.top,
          near = _ref.near,
          far = _ref.far;
      mat4.frustum(this, left, right, bottom, top, near, far);
      return this.check();
    }
  }, {
    key: "lookAt",
    value: function lookAt(_ref2) {
      var eye = _ref2.eye,
          _ref2$center = _ref2.center,
          center = _ref2$center === void 0 ? [0, 0, 0] : _ref2$center,
          _ref2$up = _ref2.up,
          up = _ref2$up === void 0 ? [0, 1, 0] : _ref2$up;
      mat4.lookAt(this, eye, center, up);
      return this.check();
    }
  }, {
    key: "ortho",
    value: function ortho(_ref3) {
      var left = _ref3.left,
          right = _ref3.right,
          bottom = _ref3.bottom,
          top = _ref3.top,
          _ref3$near = _ref3.near,
          near = _ref3$near === void 0 ? 0.1 : _ref3$near,
          _ref3$far = _ref3.far,
          far = _ref3$far === void 0 ? 500 : _ref3$far;
      mat4.ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
  }, {
    key: "orthographic",
    value: function orthographic(_ref4) {
      var _ref4$fovy = _ref4.fovy,
          fovy = _ref4$fovy === void 0 ? 45 * Math.PI / 180 : _ref4$fovy,
          _ref4$aspect = _ref4.aspect,
          aspect = _ref4$aspect === void 0 ? 1 : _ref4$aspect,
          _ref4$focalDistance = _ref4.focalDistance,
          focalDistance = _ref4$focalDistance === void 0 ? 1 : _ref4$focalDistance,
          _ref4$near = _ref4.near,
          near = _ref4$near === void 0 ? 0.1 : _ref4$near,
          _ref4$far = _ref4.far,
          far = _ref4$far === void 0 ? 500 : _ref4$far;

      if (fovy > Math.PI * 2) {
        throw Error('radians');
      }

      var halfY = fovy / 2;
      var top = focalDistance * Math.tan(halfY);
      var right = top * aspect;
      return new Matrix4().ortho({
        left: -right,
        right: right,
        bottom: -top,
        top: top,
        near: near,
        far: far
      });
    }
  }, {
    key: "perspective",
    value: function perspective() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          fovy = _ref5.fovy,
          _ref5$fov = _ref5.fov,
          fov = _ref5$fov === void 0 ? 45 * Math.PI / 180 : _ref5$fov,
          _ref5$aspect = _ref5.aspect,
          aspect = _ref5$aspect === void 0 ? 1 : _ref5$aspect,
          _ref5$near = _ref5.near,
          near = _ref5$near === void 0 ? 0.1 : _ref5$near,
          _ref5$far = _ref5.far,
          far = _ref5$far === void 0 ? 500 : _ref5$far;

      fovy = fovy || fov;

      if (fovy > Math.PI * 2) {
        throw Error('radians');
      }

      mat4.perspective(this, fovy, aspect, near, far);
      return this.check();
    }
  }, {
    key: "transpose",
    value: function transpose() {
      mat4.transpose(this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      mat4.invert(this, this);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a) {
      mat4.multiply(this, a, this);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a) {
      mat4.multiply(this, this, a);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(radians) {
      mat4.rotateX(this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(radians) {
      mat4.rotateY(this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(radians) {
      mat4.rotateZ(this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateXYZ",
    value: function rotateXYZ(_ref6) {
      var _ref7 = (0, _slicedToArray2.default)(_ref6, 3),
          rx = _ref7[0],
          ry = _ref7[1],
          rz = _ref7[2];

      return this.rotateX(rx).rotateY(ry).rotateZ(rz);
    }
  }, {
    key: "rotateAxis",
    value: function rotateAxis(radians, axis) {
      mat4.rotate(this, this, radians, axis);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (Array.isArray(factor)) {
        mat4.scale(this, this, factor);
      } else {
        mat4.scale(this, this, [factor, factor, factor]);
      }

      return this.check();
    }
  }, {
    key: "translate",
    value: function translate(vec) {
      mat4.translate(this, this, vec);
      return this.check();
    }
  }, {
    key: "transformVector2",
    value: function transformVector2(vector, out) {
      out = out || new _vector.default();
      vec2.transformMat4(out, vector, this);
      (0, _validators.validateVector)(out, 2);
      return out;
    }
  }, {
    key: "transformVector3",
    value: function transformVector3(vector, out) {
      out = out || new _vector2.default();
      vec3.transformMat4(out, vector, this);
      (0, _validators.validateVector)(out, 3);
      return out;
    }
  }, {
    key: "transformVector4",
    value: function transformVector4(vector, out) {
      out = out || new _vector3.default();
      vec4.transformMat4(out, vector, this);
      (0, _validators.validateVector)(out, 4);
      return out.check();
    }
  }, {
    key: "transformVector",
    value: function transformVector(vector, out) {
      switch (vector.length) {
        case 2:
          return this.transformVector2(vector, out);

        case 3:
          return this.transformVector3(vector, out);

        case 4:
          return this.transformVector4(vector, out);

        default:
          throw new Error('Illegal vector');
      }
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(vector, out) {
      return this._transformVector(vector, out, 0);
    }
  }, {
    key: "transformPoint",
    value: function transformPoint(vector, out) {
      return this._transformVector(vector, out, 1);
    }
  }, {
    key: "_transformVector",
    value: function _transformVector(vector, out, w) {
      switch (vector.length) {
        case 2:
          out = out || new _vector.default();
          vec4.transformMat4(out, [vector[0], vector[1], 0, w], this);
          out.length = 2;
          (0, _validators.validateVector)(out, 2);
          break;

        case 3:
          out = out || new _vector2.default();
          vec4.transformMat4(out, [vector[0], vector[1], vector[2], w], this);
          out.length = 3;
          (0, _validators.validateVector)(out, 3);
          break;

        case 4:
          if (Boolean(w) !== Boolean(vector[3])) {
            throw new Error('math.gl: Matrix4.transformPoint - invalid vector');
          }

          out = out || new _vector3.default();
          vec4.transformMat4(out, vector, this);
          (0, _validators.validateVector)(out, 4);
          break;

        default:
          throw new Error('Illegal vector');
      }

      return out;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(radians) {
      return this.identity().rotateX(radians);
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 16;
    }
  }]);
  return Matrix4;
}(_mathArray.default);

exports.default = Matrix4;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./lib/math-array":"../../../node_modules/math.gl/dist/esm/lib/math-array.js","./lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js","./lib/validators":"../../../node_modules/math.gl/dist/esm/lib/validators.js","./vector2":"../../../node_modules/math.gl/dist/esm/vector2.js","./vector3":"../../../node_modules/math.gl/dist/esm/vector3.js","./vector4":"../../../node_modules/math.gl/dist/esm/vector4.js","gl-matrix/mat4":"../../../node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"../../../node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"../../../node_modules/gl-matrix/esm/vec3.js","gl-matrix/vec4":"../../../node_modules/gl-matrix/esm/vec4.js"}],"../../../node_modules/gl-matrix/esm/quat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.slerp = slerp;
exports.random = random;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = void 0;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var mat3 = _interopRequireWildcard(require("./mat3.js"));

var vec3 = _interopRequireWildcard(require("./vec3.js"));

var vec4 = _interopRequireWildcard(require("./vec4.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */


function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */


function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */


function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */


function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */


function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

exports.equals = equals;

var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);

    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


exports.rotationTo = rotationTo;

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */


exports.sqlerp = sqlerp;

var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

exports.setAxes = setAxes;
},{"./common.js":"../../../node_modules/gl-matrix/esm/common.js","./mat3.js":"../../../node_modules/gl-matrix/esm/mat3.js","./vec3.js":"../../../node_modules/gl-matrix/esm/vec3.js","./vec4.js":"../../../node_modules/gl-matrix/esm/vec4.js"}],"../../../node_modules/math.gl/dist/esm/quaternion.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateQuaternion = validateQuaternion;
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _mathArray = _interopRequireDefault(require("./lib/math-array"));

var _common = require("./lib/common");

var quat = _interopRequireWildcard(require("gl-matrix/quat"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IDENTITY_QUATERNION = [0, 0, 0, 1];

function validateQuaternion(q) {
  return q.length === 4 && Number.isFinite(q[0]) && Number.isFinite(q[1]) && Number.isFinite(q[2]) && Number.isFinite(q[3]);
}

var Quaternion = function (_MathArray) {
  (0, _inherits2.default)(Quaternion, _MathArray);

  function Quaternion() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    (0, _classCallCheck2.default)(this, Quaternion);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Quaternion).call(this, 4));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z, w);
    }

    return _this;
  }

  (0, _createClass2.default)(Quaternion, [{
    key: "fromMatrix3",
    value: function fromMatrix3(m) {
      quat.fromMat3(this, m);
      return this.check();
    }
  }, {
    key: "fromValues",
    value: function fromValues(x, y, z, w) {
      return this.set(x, y, z, w);
    }
  }, {
    key: "identity",
    value: function identity() {
      quat.identity(this);
      return this.check();
    }
  }, {
    key: "length",
    value: function length() {
      return quat.length(this);
    }
  }, {
    key: "squaredLength",
    value: function squaredLength(a) {
      return quat.squaredLength(this);
    }
  }, {
    key: "dot",
    value: function dot(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.dot only takes one argument');
      }

      return quat.dot(this, a);
    }
  }, {
    key: "rotationTo",
    value: function rotationTo(vectorA, vectorB) {
      quat.rotationTo(this, vectorA, vectorB);
      return this.check();
    }
  }, {
    key: "add",
    value: function add(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.add only takes one argument');
      }

      quat.add(this, a);
      return this.check();
    }
  }, {
    key: "calculateW",
    value: function calculateW() {
      quat.calculateW(this, this);
      return this.check();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      quat.conjugate(this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      quat.invert(this, this);
      return this.check();
    }
  }, {
    key: "lerp",
    value: function lerp(a, b, t) {
      quat.lerp(this, a, b, t);
      return this.check();
    }
  }, {
    key: "multiply",
    value: function multiply(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.multiply only takes one argument');
      }

      quat.multiply(this, this, a);
      return this.check();
    }
  }, {
    key: "normalize",
    value: function normalize() {
      quat.normalize(this, this);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(rad) {
      quat.rotateX(this, this, rad);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(rad) {
      quat.rotateY(this, this, rad);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(rad) {
      quat.rotateZ(this, this, rad);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(b) {
      quat.scale(this, this, b);
      return this.check();
    }
  }, {
    key: "set",
    value: function set(i, j, k, l) {
      quat.set(this, i, j, k, l);
      return this.check();
    }
  }, {
    key: "setAxisAngle",
    value: function setAxisAngle(axis, rad) {
      quat.setAxisAngle(this, axis, rad);
      return this.check();
    }
  }, {
    key: "slerp",
    value: function slerp(_ref) {
      var _ref$start = _ref.start,
          start = _ref$start === void 0 ? IDENTITY_QUATERNION : _ref$start,
          target = _ref.target,
          ratio = _ref.ratio;
      quat.slerp(this, start, target, ratio);
      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "w",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = (0, _common.checkNumber)(value);
    }
  }]);
  return Quaternion;
}(_mathArray.default);

exports.default = Quaternion;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./lib/math-array":"../../../node_modules/math.gl/dist/esm/lib/math-array.js","./lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js","gl-matrix/quat":"../../../node_modules/gl-matrix/esm/quat.js"}],"../../../node_modules/math.gl/dist/esm/spherical-coordinates.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _common = require("./lib/common");

var _vector = _interopRequireDefault(require("./vector3"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EPSILON = 0.000001;
var EARTH_RADIUS_METERS = 6.371e6;

var SphericalCoordinates = function () {
  function SphericalCoordinates() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        phi = _ref.phi,
        theta = _ref.theta,
        radius = _ref.radius,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        altitude = _ref.altitude,
        _ref$radiusScale = _ref.radiusScale,
        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;

    (0, _classCallCheck2.default)(this, SphericalCoordinates);

    if (arguments.length === 0) {
      this.phi = 0;
      this.theta = 0;
      this.radius = 1;
    } else if (Number.isFinite(phi) || Number.isFinite(theta)) {
      this.phi = phi || 0;
      this.theta = theta || 0;
    } else if (Number.isFinite(bearing) || Number.isFinite(pitch)) {
      this.bearing = bearing || 0;
      this.pitch = pitch || 0;
    }

    this.radius = radius || 1;
    this.radiusScale = radiusScale || 1;
    this.check();
  }

  (0, _createClass2.default)(SphericalCoordinates, [{
    key: "toString",
    value: function toString() {
      return this.formatString(_common.config);
    }
  }, {
    key: "formatString",
    value: function formatString(_ref2) {
      var printTypes = _ref2.printTypes,
          printDegrees = _ref2.printDegrees;
      var f = _common.formatValue;
      return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return (0, _common.equals)(this.radius, other.radius) && (0, _common.equals)(this.theta, other.theta) && (0, _common.equals)(this.phi, other.phi);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(other) {
      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
    }
  }, {
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this.check();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this.check();
    }
  }, {
    key: "fromLngLatZ",
    value: function fromLngLatZ(_ref3) {
      var _ref4 = (0, _slicedToArray2.default)(_ref3, 3),
          lng = _ref4[0],
          lat = _ref4[1],
          z = _ref4[2];

      this.radius = 1 + z / this.radiusScale;
      this.phi = (0, _common.radians)(lat);
      this.theta = (0, _common.radians)(lng);
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v) {
      this.radius = vec3.length(v);

      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(v[0], v[1]);
        this.phi = Math.acos((0, _common.clamp)(v[2] / this.radius, -1, 1));
      }

      return this.check();
    }
  }, {
    key: "toVector3",
    value: function toVector3() {
      return new _vector.default(0, 0, this.radius).rotateX({
        radians: this.theta
      }).rotateZ({
        radians: this.phi
      });
    }
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    }
  }, {
    key: "check",
    value: function check() {
      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
        throw new Error('SphericalCoordinates: some fields set to invalid numbers');
      }

      return this;
    }
  }, {
    key: "bearing",
    get: function get() {
      return 180 - (0, _common.degrees)(this.phi);
    },
    set: function set(v) {
      this.phi = Math.PI - (0, _common.radians)(v);
    }
  }, {
    key: "pitch",
    get: function get() {
      return (0, _common.degrees)(this.theta);
    },
    set: function set(v) {
      this.theta = (0, _common.radians)(v);
    }
  }, {
    key: "longitude",
    get: function get() {
      return (0, _common.degrees)(this.phi);
    }
  }, {
    key: "latitude",
    get: function get() {
      return (0, _common.degrees)(this.theta);
    }
  }, {
    key: "lng",
    get: function get() {
      return (0, _common.degrees)(this.phi);
    }
  }, {
    key: "lat",
    get: function get() {
      return (0, _common.degrees)(this.theta);
    }
  }, {
    key: "z",
    get: function get() {
      return (this.radius - 1) * this.radiusScale;
    }
  }]);
  return SphericalCoordinates;
}();

exports.default = SphericalCoordinates;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js","./vector3":"../../../node_modules/math.gl/dist/esm/vector3.js","gl-matrix/vec3":"../../../node_modules/gl-matrix/esm/vec3.js"}],"../../../node_modules/math.gl/dist/esm/euler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _mathArray = _interopRequireDefault(require("./lib/math-array"));

var _common = require("./lib/common");

var _matrix = _interopRequireDefault(require("./matrix4"));

var _quaternion2 = _interopRequireDefault(require("./quaternion"));

var _vector = _interopRequireDefault(require("./vector3"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
var ALMOST_ONE = 0.99999;

function validateOrder(value) {
  return value >= 0 && value < 6;
}

function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }

  return value;
}

var Euler = function (_MathArray) {
  (0, _inherits2.default)(Euler, _MathArray);
  (0, _createClass2.default)(Euler, [{
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }], [{
    key: "rotationOrder",
    value: function rotationOrder(order) {
      return Euler.RotationOrders[order];
    }
  }, {
    key: "ZYX",
    get: function get() {
      return 0;
    }
  }, {
    key: "YXZ",
    get: function get() {
      return 1;
    }
  }, {
    key: "XZY",
    get: function get() {
      return 2;
    }
  }, {
    key: "ZXY",
    get: function get() {
      return 3;
    }
  }, {
    key: "YZX",
    get: function get() {
      return 4;
    }
  }, {
    key: "XYZ",
    get: function get() {
      return 5;
    }
  }, {
    key: "RollPitchYaw",
    get: function get() {
      return 0;
    }
  }, {
    key: "DefaultOrder",
    get: function get() {
      return Euler.ZYX;
    }
  }, {
    key: "RotationOrders",
    get: function get() {
      return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];
    }
  }]);

  function Euler() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DefaultOrder;
    (0, _classCallCheck2.default)(this, Euler);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Euler).call(this, 4));

    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      var _this2;

      (_this2 = _this).fromVector3.apply(_this2, arguments);
    } else {
      _this.set(x, y, z, order);
    }

    return _this;
  }

  (0, _createClass2.default)(Euler, [{
    key: "fromQuaternion",
    value: function fromQuaternion(quaternion) {
      var _quaternion = (0, _slicedToArray2.default)(quaternion, 4),
          x = _quaternion[0],
          y = _quaternion[1],
          z = _quaternion[2],
          w = _quaternion[3];

      var ysqr = y * y;
      var t0 = -2.0 * (ysqr + z * z) + 1.0;
      var t1 = +2.0 * (x * y + w * z);
      var t2 = -2.0 * (x * z - w * y);
      var t3 = +2.0 * (y * z + w * x);
      var t4 = -2.0 * (x * x + ysqr) + 1.0;
      t2 = t2 > 1.0 ? 1.0 : t2;
      t2 = t2 < -1.0 ? -1.0 : t2;
      var roll = Math.atan2(t3, t4);
      var pitch = Math.asin(t2);
      var yaw = Math.atan2(t1, t0);
      return new Euler(roll, pitch, yaw, Euler.RollPitchYaw);
    }
  }, {
    key: "copy",
    value: function copy(array) {
      for (var i = 0; i < 3; ++i) {
        this[i] = array[i];
      }

      this[3] = Number.isFinite(array[3]) || this.order;
      return this.check();
    }
  }, {
    key: "set",
    value: function set() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var order = arguments.length > 3 ? arguments[3] : undefined;
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = Number.isFinite(order) ? order : this[3];
      return this.check();
    }
  }, {
    key: "validate",
    value: function validate() {
      return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      return array;
    }
  }, {
    key: "toArray4",
    value: function toArray4() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      array[offset + 3] = this[3];
      return array;
    }
  }, {
    key: "toVector3",
    value: function toVector3(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this[0], this[1], this[2]);
      }

      return new _vector.default(this[0], this[1], this[2]);
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v, order) {
      return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this[0] = array[0 + offset];
      this[1] = array[1 + offset];
      this[2] = array[2 + offset];

      if (array[3] !== undefined) {
        this[3] = array[3];
      }

      return this.check();
    }
  }, {
    key: "fromRollPitchYaw",
    value: function fromRollPitchYaw(roll, pitch, yaw) {
      return this.set(roll, pitch, yaw, Euler.ZYX);
    }
  }, {
    key: "fromRotationMatrix",
    value: function fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;

      this._fromRotationMatrix(m, order);

      return this.check();
    }
  }, {
    key: "getRotationMatrix",
    value: function getRotationMatrix() {
      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _matrix.default();

      this._getRotationMatrix(m);

      return m;
    }
  }, {
    key: "getQuaternion",
    value: function getQuaternion() {
      var q = new _quaternion2.default();

      switch (this[4]) {
        case Euler.XYZ:
          return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);

        case Euler.YXZ:
          return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);

        case Euler.ZXY:
          return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);

        case Euler.ZYX:
          return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);

        case Euler.YZX:
          return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);

        case Euler.XZY:
          return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }
    }
  }, {
    key: "_fromRotationMatrix",
    value: function _fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;
      var te = m.elements;
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
      var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
      var m31 = te[2],
          m32 = te[6],
          m33 = te[10];
      order = order || this[3];

      switch (order) {
        case Euler.XYZ:
          this[1] = Math.asin((0, _common.clamp)(m13, -1, 1));

          if (Math.abs(m13) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m33);
            this[2] = Math.atan2(-m12, m11);
          } else {
            this[0] = Math.atan2(m32, m22);
            this[2] = 0;
          }

          break;

        case Euler.YXZ:
          this[0] = Math.asin(-(0, _common.clamp)(m23, -1, 1));

          if (Math.abs(m23) < ALMOST_ONE) {
            this[1] = Math.atan2(m13, m33);
            this[2] = Math.atan2(m21, m22);
          } else {
            this[1] = Math.atan2(-m31, m11);
            this[2] = 0;
          }

          break;

        case Euler.ZXY:
          this[0] = Math.asin((0, _common.clamp)(m32, -1, 1));

          if (Math.abs(m32) < ALMOST_ONE) {
            this[1] = Math.atan2(-m31, m33);
            this[2] = Math.atan2(-m12, m22);
          } else {
            this[1] = 0;
            this[2] = Math.atan2(m21, m11);
          }

          break;

        case Euler.ZYX:
          this[1] = Math.asin(-(0, _common.clamp)(m31, -1, 1));

          if (Math.abs(m31) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m33);
            this[2] = Math.atan2(m21, m11);
          } else {
            this[0] = 0;
            this[2] = Math.atan2(-m12, m22);
          }

          break;

        case Euler.YZX:
          this[2] = Math.asin((0, _common.clamp)(m21, -1, 1));

          if (Math.abs(m21) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m22);
            this[1] = Math.atan2(-m31, m11);
          } else {
            this[0] = 0;
            this[1] = Math.atan2(m13, m33);
          }

          break;

        case Euler.XZY:
          this[2] = Math.asin(-(0, _common.clamp)(m12, -1, 1));

          if (Math.abs(m12) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m22);
            this[1] = Math.atan2(m13, m11);
          } else {
            this[0] = Math.atan2(-m23, m33);
            this[1] = 0;
          }

          break;

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      this[3] = order;
      return this;
    }
  }, {
    key: "_getRotationMatrix",
    value: function _getRotationMatrix() {
      var te = new _matrix.default();
      var x = this.x,
          y = this.y,
          z = this.z;
      var a = Math.cos(x);
      var c = Math.cos(y);
      var e = Math.cos(z);
      var b = Math.sin(x);
      var d = Math.sin(y);
      var f = Math.sin(z);

      switch (this[3]) {
        case Euler.XYZ:
          {
            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
            break;
          }

        case Euler.YXZ:
          {
            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
            break;
          }

        case Euler.ZXY:
          {
            var _ce = c * e,
                _cf = c * f,
                _de = d * e,
                _df = d * f;

            te[0] = _ce - _df * b;
            te[4] = -a * f;
            te[8] = _de + _cf * b;
            te[1] = _cf + _de * b;
            te[5] = a * e;
            te[9] = _df - _ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
            break;
          }

        case Euler.ZYX:
          {
            var _ae = a * e,
                _af = a * f,
                _be = b * e,
                _bf = b * f;

            te[0] = c * e;
            te[4] = _be * d - _af;
            te[8] = _ae * d + _bf;
            te[1] = c * f;
            te[5] = _bf * d + _ae;
            te[9] = _af * d - _be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
            break;
          }

        case Euler.YZX:
          {
            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
            break;
          }

        case Euler.XZY:
          {
            var _ac = a * c,
                _ad = a * d,
                _bc = b * c,
                _bd = b * d;

            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = _ac * f + _bd;
            te[5] = a * e;
            te[9] = _ad * f - _bc;
            te[2] = _bc * f - _ad;
            te[6] = b * e;
            te[10] = _bd * f + _ac;
            break;
          }

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    }
  }, {
    key: "toQuaternion",
    value: function toQuaternion() {
      var cy = Math.cos(this.yaw * 0.5);
      var sy = Math.sin(this.yaw * 0.5);
      var cr = Math.cos(this.roll * 0.5);
      var sr = Math.sin(this.roll * 0.5);
      var cp = Math.cos(this.pitch * 0.5);
      var sp = Math.sin(this.pitch * 0.5);
      var w = cy * cr * cp + sy * sr * sp;
      var x = cy * sr * cp - sy * cr * sp;
      var y = cy * cr * sp + sy * sr * cp;
      var z = sy * cr * cp - cy * sr * sp;
      return new _quaternion2.default(x, y, z, w);
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "alpha",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "beta",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "gamma",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "phi",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "theta",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "psi",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "roll",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "pitch",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "yaw",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = (0, _common.checkNumber)(value);
    }
  }, {
    key: "order",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = checkOrder(value);
    }
  }]);
  return Euler;
}(_mathArray.default);

exports.default = Euler;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./lib/math-array":"../../../node_modules/math.gl/dist/esm/lib/math-array.js","./lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js","./matrix4":"../../../node_modules/math.gl/dist/esm/matrix4.js","./quaternion":"../../../node_modules/math.gl/dist/esm/quaternion.js","./vector3":"../../../node_modules/math.gl/dist/esm/vector3.js"}],"../../../node_modules/math.gl/dist/esm/pose.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _matrix = _interopRequireDefault(require("./matrix4"));

var _vector = _interopRequireDefault(require("./vector3"));

var _euler = _interopRequireDefault(require("./euler"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Pose = function () {
  function Pose(_ref) {
    var _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$z = _ref.z,
        z = _ref$z === void 0 ? 0 : _ref$z,
        _ref$roll = _ref.roll,
        roll = _ref$roll === void 0 ? 0 : _ref$roll,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
        _ref$yaw = _ref.yaw,
        yaw = _ref$yaw === void 0 ? 0 : _ref$yaw,
        position = _ref.position,
        orientation = _ref.orientation;
    (0, _classCallCheck2.default)(this, Pose);

    if (Array.isArray(position) && position.length === 3) {
      this.position = new _vector.default(position);
    } else {
      this.position = new _vector.default(x, y, z);
    }

    if (Array.isArray(orientation) && orientation.length === 4) {
      this.orientation = new _euler.default(orientation, orientation[3]);
    } else {
      this.orientation = new _euler.default(roll, pitch, yaw, _euler.default.RollPitchYaw);
    }
  }

  (0, _createClass2.default)(Pose, [{
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
  }, {
    key: "getOrientation",
    value: function getOrientation() {
      return this.orientation;
    }
  }, {
    key: "equals",
    value: function equals(pose) {
      if (!pose) {
        return false;
      }

      return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(pose) {
      if (!pose) {
        return false;
      }

      return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
    }
  }, {
    key: "getTransformationMatrix",
    value: function getTransformationMatrix() {
      var sr = Math.sin(this.roll);
      var sp = Math.sin(this.pitch);
      var sw = Math.sin(this.yaw);
      var cr = Math.cos(this.roll);
      var cp = Math.cos(this.pitch);
      var cw = Math.cos(this.yaw);
      var matrix = new _matrix.default().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
      return matrix;
    }
  }, {
    key: "getTransformationMatrixFromPose",
    value: function getTransformationMatrixFromPose(pose) {
      return new _matrix.default().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
    }
  }, {
    key: "getTransformationMatrixToPose",
    value: function getTransformationMatrixToPose(pose) {
      return new _matrix.default().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
    }
  }, {
    key: "x",
    get: function get() {
      return this.position.x;
    },
    set: function set(value) {
      return this.position.x = value;
    }
  }, {
    key: "y",
    get: function get() {
      return this.position.y;
    },
    set: function set(value) {
      return this.position.y = value;
    }
  }, {
    key: "z",
    get: function get() {
      return this.position.z;
    },
    set: function set(value) {
      return this.position.z = value;
    }
  }, {
    key: "roll",
    get: function get() {
      return this.orientation.roll;
    },
    set: function set(value) {
      return this.orientation.roll = value;
    }
  }, {
    key: "pitch",
    get: function get() {
      return this.orientation.pitch;
    },
    set: function set(value) {
      return this.orientation.pitch = value;
    }
  }, {
    key: "yaw",
    get: function get() {
      return this.orientation.yaw;
    },
    set: function set(value) {
      return this.orientation.yaw = value;
    }
  }]);
  return Pose;
}();

exports.default = Pose;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./matrix4":"../../../node_modules/math.gl/dist/esm/matrix4.js","./vector3":"../../../node_modules/math.gl/dist/esm/vector3.js","./euler":"../../../node_modules/math.gl/dist/esm/euler.js"}],"../../../node_modules/math.gl/dist/esm/addons/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _common = require("../lib/common");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Polygon = function () {
  function Polygon(points) {
    (0, _classCallCheck2.default)(this, Polygon);
    this.points = points;
    this.isClosed = (0, _common.equals)(this.points[this.points.length - 1], this.points[0]);
    Object.freeze(this);
  }

  (0, _createClass2.default)(Polygon, [{
    key: "getSignedArea",
    value: function getSignedArea() {
      var area = 0;
      this.forEachSegment(function (p1, p2) {
        area += (p1[0] + p2[0]) * (p1[1] - p2[1]);
      });
      return area / 2;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      return Math.abs(this.getSignedArea());
    }
  }, {
    key: "getWindingDirection",
    value: function getWindingDirection() {
      return Math.sign(this.getSignedArea());
    }
  }, {
    key: "forEachSegment",
    value: function forEachSegment(visitor) {
      var length = this.points.length;

      for (var i = 0; i < length - 1; i++) {
        visitor(this.points[i], this.points[i + 1], i, i + 1);
      }

      if (this.isPolygon && !this.isClosed()) {
        visitor(this.points[length - 1], this.points[0], length - 1, 0);
      }
    }
  }]);
  return Polygon;
}();

exports.default = Polygon;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js"}],"../../../node_modules/math.gl/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Vector2", {
  enumerable: true,
  get: function () {
    return _vector.default;
  }
});
Object.defineProperty(exports, "Vector3", {
  enumerable: true,
  get: function () {
    return _vector2.default;
  }
});
Object.defineProperty(exports, "Vector4", {
  enumerable: true,
  get: function () {
    return _vector3.default;
  }
});
Object.defineProperty(exports, "Matrix3", {
  enumerable: true,
  get: function () {
    return _matrix.default;
  }
});
Object.defineProperty(exports, "Matrix4", {
  enumerable: true,
  get: function () {
    return _matrix2.default;
  }
});
Object.defineProperty(exports, "Quaternion", {
  enumerable: true,
  get: function () {
    return _quaternion.default;
  }
});
Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function () {
    return _common.config;
  }
});
Object.defineProperty(exports, "checkNumber", {
  enumerable: true,
  get: function () {
    return _common.checkNumber;
  }
});
Object.defineProperty(exports, "configure", {
  enumerable: true,
  get: function () {
    return _common.configure;
  }
});
Object.defineProperty(exports, "formatValue", {
  enumerable: true,
  get: function () {
    return _common.formatValue;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function () {
    return _common.isArray;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function () {
    return _common.clone;
  }
});
Object.defineProperty(exports, "radians", {
  enumerable: true,
  get: function () {
    return _common.radians;
  }
});
Object.defineProperty(exports, "degrees", {
  enumerable: true,
  get: function () {
    return _common.degrees;
  }
});
Object.defineProperty(exports, "sin", {
  enumerable: true,
  get: function () {
    return _common.sin;
  }
});
Object.defineProperty(exports, "cos", {
  enumerable: true,
  get: function () {
    return _common.cos;
  }
});
Object.defineProperty(exports, "tan", {
  enumerable: true,
  get: function () {
    return _common.tan;
  }
});
Object.defineProperty(exports, "asin", {
  enumerable: true,
  get: function () {
    return _common.asin;
  }
});
Object.defineProperty(exports, "acos", {
  enumerable: true,
  get: function () {
    return _common.acos;
  }
});
Object.defineProperty(exports, "atan", {
  enumerable: true,
  get: function () {
    return _common.atan;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function () {
    return _common.clamp;
  }
});
Object.defineProperty(exports, "lerp", {
  enumerable: true,
  get: function () {
    return _common.lerp;
  }
});
Object.defineProperty(exports, "equals", {
  enumerable: true,
  get: function () {
    return _common.equals;
  }
});
Object.defineProperty(exports, "_SphericalCoordinates", {
  enumerable: true,
  get: function () {
    return _sphericalCoordinates.default;
  }
});
Object.defineProperty(exports, "_Pose", {
  enumerable: true,
  get: function () {
    return _pose.default;
  }
});
Object.defineProperty(exports, "_Euler", {
  enumerable: true,
  get: function () {
    return _euler.default;
  }
});
Object.defineProperty(exports, "_Polygon", {
  enumerable: true,
  get: function () {
    return _polygon.default;
  }
});

var _vector = _interopRequireDefault(require("./vector2"));

var _vector2 = _interopRequireDefault(require("./vector3"));

var _vector3 = _interopRequireDefault(require("./vector4"));

var _matrix = _interopRequireDefault(require("./matrix3"));

var _matrix2 = _interopRequireDefault(require("./matrix4"));

var _quaternion = _interopRequireDefault(require("./quaternion"));

var _common = require("./lib/common");

var _sphericalCoordinates = _interopRequireDefault(require("./spherical-coordinates"));

var _pose = _interopRequireDefault(require("./pose"));

var _euler = _interopRequireDefault(require("./euler"));

var _polygon = _interopRequireDefault(require("./addons/polygon"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./vector2":"../../../node_modules/math.gl/dist/esm/vector2.js","./vector3":"../../../node_modules/math.gl/dist/esm/vector3.js","./vector4":"../../../node_modules/math.gl/dist/esm/vector4.js","./matrix3":"../../../node_modules/math.gl/dist/esm/matrix3.js","./matrix4":"../../../node_modules/math.gl/dist/esm/matrix4.js","./quaternion":"../../../node_modules/math.gl/dist/esm/quaternion.js","./lib/common":"../../../node_modules/math.gl/dist/esm/lib/common.js","./spherical-coordinates":"../../../node_modules/math.gl/dist/esm/spherical-coordinates.js","./pose":"../../../node_modules/math.gl/dist/esm/pose.js","./euler":"../../../node_modules/math.gl/dist/esm/euler.js","./addons/polygon":"../../../node_modules/math.gl/dist/esm/addons/polygon.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lighting/light-source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointLight = exports.DirectionalLight = exports.AmbientLight = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _math = require("math.gl");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_LIGHT_COLOR = [255, 255, 255];
var DEFAULT_LIGHT_INTENSITY = 1.0;
var DEFAULT_ATTENUATION = [0, 0, 1];
var DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];
var DEFAULT_LIGHT_POSITION = [0.0, 0.0, 1.0];

var Light = function Light() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  (0, _classCallCheck2.default)(this, Light);
  this.id = props.id || (0, _utils.uid)('light');
  var _props$color = props.color,
      color = _props$color === void 0 ? DEFAULT_LIGHT_COLOR : _props$color;
  this.color = color;
  var _props$intensity = props.intensity,
      intensity = _props$intensity === void 0 ? DEFAULT_LIGHT_INTENSITY : _props$intensity;
  this.intensity = intensity;
};

var AmbientLight = function (_Light) {
  (0, _inherits2.default)(AmbientLight, _Light);

  function AmbientLight() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, AmbientLight);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(AmbientLight).call(this, props));
    _this.type = 'ambient';
    return _this;
  }

  return AmbientLight;
}(Light);

exports.AmbientLight = AmbientLight;

var DirectionalLight = function (_Light2) {
  (0, _inherits2.default)(DirectionalLight, _Light2);

  function DirectionalLight() {
    var _this2;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, DirectionalLight);
    _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(DirectionalLight).call(this, props));
    _this2.type = 'directional';
    var _props$direction = props.direction,
        direction = _props$direction === void 0 ? DEFAULT_LIGHT_DIRECTION : _props$direction;
    _this2.direction = new _math.Vector3(direction).normalize().toArray();
    return _this2;
  }

  return DirectionalLight;
}(Light);

exports.DirectionalLight = DirectionalLight;

var PointLight = function (_Light3) {
  (0, _inherits2.default)(PointLight, _Light3);

  function PointLight() {
    var _this3;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, PointLight);
    _this3 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PointLight).call(this, props));
    _this3.type = 'point';
    var _props$position = props.position,
        position = _props$position === void 0 ? DEFAULT_LIGHT_POSITION : _props$position;
    _this3.position = position;
    _this3.attenuation = _this3._getAttenuation(props);
    return _this3;
  }

  (0, _createClass2.default)(PointLight, [{
    key: "_getAttenuation",
    value: function _getAttenuation(props) {
      if ('attenuation' in props) {
        return props.attenuation;
      }

      if ('intensity' in props) {
        return [0, 0, props.intensity];
      }

      return DEFAULT_ATTENUATION;
    }
  }]);
  return PointLight;
}(Light);

exports.PointLight = PointLight;
},{"@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/animation-loop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var statIdCounter = 0;

var AnimationLoop = function () {
  function AnimationLoop() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, AnimationLoop);
    var _props$onCreateContex = props.onCreateContext,
        onCreateContext = _props$onCreateContex === void 0 ? function (opts) {
      return (0, _webgl.createGLContext)(opts);
    } : _props$onCreateContex,
        _props$onAddHTML = props.onAddHTML,
        onAddHTML = _props$onAddHTML === void 0 ? null : _props$onAddHTML,
        _props$onInitialize = props.onInitialize,
        onInitialize = _props$onInitialize === void 0 ? function () {} : _props$onInitialize,
        _props$onRender = props.onRender,
        onRender = _props$onRender === void 0 ? function () {} : _props$onRender,
        _props$onFinalize = props.onFinalize,
        onFinalize = _props$onFinalize === void 0 ? function () {} : _props$onFinalize,
        _props$gl = props.gl,
        gl = _props$gl === void 0 ? null : _props$gl,
        _props$glOptions = props.glOptions,
        glOptions = _props$glOptions === void 0 ? {} : _props$glOptions,
        _props$debug = props.debug,
        debug = _props$debug === void 0 ? false : _props$debug,
        _props$createFramebuf = props.createFramebuffer,
        createFramebuffer = _props$createFramebuf === void 0 ? false : _props$createFramebuf,
        _props$autoResizeView = props.autoResizeViewport,
        autoResizeViewport = _props$autoResizeView === void 0 ? true : _props$autoResizeView,
        _props$autoResizeDraw = props.autoResizeDrawingBuffer,
        autoResizeDrawingBuffer = _props$autoResizeDraw === void 0 ? true : _props$autoResizeDraw,
        _props$stats = props.stats,
        stats = _props$stats === void 0 ? _webgl.lumaStats.get("animation-loop-".concat(statIdCounter++)) : _props$stats;
    var _props$useDevicePixel = props.useDevicePixels,
        useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel;

    if ('useDevicePixelRatio' in props) {
      _utils.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();

      useDevicePixels = props.useDevicePixelRatio;
    }

    this.props = {
      onCreateContext: onCreateContext,
      onAddHTML: onAddHTML,
      onInitialize: onInitialize,
      onRender: onRender,
      onFinalize: onFinalize,
      gl: gl,
      glOptions: glOptions,
      debug: debug,
      createFramebuffer: createFramebuffer
    };
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.setProps({
      autoResizeViewport: autoResizeViewport,
      autoResizeDrawingBuffer: autoResizeDrawingBuffer,
      useDevicePixels: useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }

  (0, _createClass2.default)(AnimationLoop, [{
    key: "delete",
    value: function _delete() {
      this.stop();

      this._setDisplay(null);
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw(reason) {
      (0, _utils.assert)(typeof reason === 'string');
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('autoResizeViewport' in props) {
        this.autoResizeViewport = props.autoResizeViewport;
      }

      if ('autoResizeDrawingBuffer' in props) {
        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      }

      if ('useDevicePixels' in props) {
        this.useDevicePixels = props.useDevicePixels;
      }

      return this;
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._running) {
        return this;
      }

      this._running = true;
      (0, _webgl.getPageLoadPromise)().then(function () {
        if (!_this._running || _this._initialized) {
          return null;
        }

        _this._createWebGLContext(opts);

        _this._createFramebuffer();

        _this._startEventHandling();

        _this._initializeCallbackData();

        _this._updateCallbackData();

        _this._resizeCanvasDrawingBuffer();

        _this._resizeViewport();

        _this._gpuTimeQuery = _webgl.Query.isSupported(_this.gl, ['timers']) ? new _webgl.Query(_this.gl) : null;
        _this._initialized = true;
        return _this.onInitialize(_this.animationProps);
      }).then(function (appContext) {
        if (_this._running) {
          _this._addCallbackData(appContext || {});

          if (appContext !== false) {
            _this._startLoop();
          }
        }
      });
      return this;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      this._beginTimers();

      this._setupFrame();

      this._updateCallbackData();

      this._renderFrame(this.animationProps);

      this._clearNeedsRedraw();

      if (this.offScreen && this.gl.commit) {
        this.gl.commit();
      }

      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);

        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }

      this._endTimers();

      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this._running) {
        this._finalizeCallbackData();

        (0, _webgl.cancelAnimationFrame)(this._animationFrameId);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._animationFrameId = null;
        this._running = false;
      }

      return this;
    }
  }, {
    key: "attachTimeline",
    value: function attachTimeline(timeline) {
      this.timeline = timeline;
      return this.timeline;
    }
  }, {
    key: "detachTimeline",
    value: function detachTimeline() {
      this.timeline = null;
    }
  }, {
    key: "waitForRender",
    value: function waitForRender() {
      var _this2 = this;

      this.setNeedsRedraw('waitForRender');

      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise(function (resolve) {
          _this2._resolveNextFrame = resolve;
        });
      }

      return this._nextFramePromise;
    }
  }, {
    key: "toDataURL",
    value: function () {
      var _toDataURL = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.setNeedsRedraw('toDataURL');
                _context.next = 3;
                return this.waitForRender();

              case 3:
                return _context.abrupt("return", this.gl.canvas.toDataURL());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function toDataURL() {
        return _toDataURL.apply(this, arguments);
      }

      return toDataURL;
    }()
  }, {
    key: "onCreateContext",
    value: function onCreateContext() {
      var _this$props;

      return (_this$props = this.props).onCreateContext.apply(_this$props, arguments);
    }
  }, {
    key: "onInitialize",
    value: function onInitialize() {
      var _this$props2;

      return (_this$props2 = this.props).onInitialize.apply(_this$props2, arguments);
    }
  }, {
    key: "onRender",
    value: function onRender() {
      var _this$props3;

      return (_this$props3 = this.props).onRender.apply(_this$props3, arguments);
    }
  }, {
    key: "onFinalize",
    value: function onFinalize() {
      var _this$props4;

      return (_this$props4 = this.props).onFinalize.apply(_this$props4, arguments);
    }
  }, {
    key: "getHTMLControlValue",
    value: function getHTMLControlValue(id) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var element = document.getElementById(id);
      return element ? Number(element.value) : defaultValue;
    }
  }, {
    key: "setViewParameters",
    value: function setViewParameters() {
      _utils.log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();

      return this;
    }
  }, {
    key: "_startLoop",
    value: function _startLoop() {
      var _this3 = this;

      var renderFrame = function renderFrame() {
        if (!_this3._running) {
          return;
        }

        _this3.redraw();

        _this3._animationFrameId = _this3._requestAnimationFrame(renderFrame);
      };

      (0, _webgl.cancelAnimationFrame)(this._animationFrameId);
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    }
  }, {
    key: "_setDisplay",
    value: function _setDisplay(display) {
      if (this.display) {
        this.display["delete"]();
        this.display.animationLoop = null;
      }

      if (display) {
        display.animationLoop = this;
      }

      this.display = display;
    }
  }, {
    key: "_requestAnimationFrame",
    value: function _requestAnimationFrame(renderFrameCallback) {
      if (this.display && this.display.requestAnimationFrame(renderFrameCallback)) {
        return;
      }

      (0, _webgl.requestAnimationFrame)(renderFrameCallback);
    }
  }, {
    key: "_renderFrame",
    value: function _renderFrame() {
      if (this.display) {
        var _this$display;

        (_this$display = this.display)._renderFrame.apply(_this$display, arguments);

        return;
      }

      this.onRender.apply(this, arguments);
    }
  }, {
    key: "_clearNeedsRedraw",
    value: function _clearNeedsRedraw() {
      this.needsRedraw = null;
    }
  }, {
    key: "_setupFrame",
    value: function _setupFrame() {
      if (this._onSetupFrame) {
        this._onSetupFrame(this.animationProps);
      } else {
        this._resizeCanvasDrawingBuffer();

        this._resizeViewport();

        this._resizeFramebuffer();
      }
    }
  }, {
    key: "_initializeCallbackData",
    value: function _initializeCallbackData() {
      this.animationProps = {
        gl: this.gl,
        stop: this.stop,
        canvas: this.gl.canvas,
        framebuffer: this.framebuffer,
        useDevicePixels: this.useDevicePixels,
        needsRedraw: null,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        time: 0,
        _timeline: this.timeline,
        _loop: this,
        _animationLoop: this,
        _mousePosition: null
      };
    }
  }, {
    key: "_updateCallbackData",
    value: function _updateCallbackData() {
      var _this$_getSizeAndAspe = this._getSizeAndAspect(),
          width = _this$_getSizeAndAspe.width,
          height = _this$_getSizeAndAspe.height,
          aspect = _this$_getSizeAndAspe.aspect;

      if (width !== this.animationProps.width || height !== this.animationProps.height) {
        this.setNeedsRedraw('drawing buffer resized');
      }

      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw('drawing buffer aspect changed');
      }

      this.animationProps.width = width;
      this.animationProps.height = height;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw;
      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;

      if (this.timeline) {
        this.timeline.update(this.animationProps.engineTime);
      }

      this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
      this.animationProps.tock++;
      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
      this.animationProps._offScreen = this.offScreen;
    }
  }, {
    key: "_finalizeCallbackData",
    value: function _finalizeCallbackData() {
      this.onFinalize(this.animationProps);
    }
  }, {
    key: "_addCallbackData",
    value: function _addCallbackData(appContext) {
      if ((0, _typeof2.default)(appContext) === 'object' && appContext !== null) {
        this.animationProps = Object.assign({}, this.animationProps, appContext);
      }
    }
  }, {
    key: "_createWebGLContext",
    value: function _createWebGLContext(opts) {
      this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;
      opts = Object.assign({}, opts, this.props.glOptions);
      this.gl = this.props.gl ? (0, _webgl.instrumentGLContext)(this.props.gl, opts) : this.onCreateContext(opts);

      if (!(0, _webgl.isWebGL)(this.gl)) {
        throw new Error('AnimationLoop.onCreateContext - illegal context returned');
      }

      (0, _webgl.resetParameters)(this.gl);

      this._createInfoDiv();
    }
  }, {
    key: "_createInfoDiv",
    value: function _createInfoDiv() {
      if (this.gl.canvas && this.props.onAddHTML) {
        var wrapperDiv = document.createElement('div');
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = 'relative';
        var div = document.createElement('div');
        div.style.position = 'absolute';
        div.style.left = '10px';
        div.style.bottom = '10px';
        div.style.width = '300px';
        div.style.background = 'white';
        wrapperDiv.appendChild(this.gl.canvas);
        wrapperDiv.appendChild(div);
        var html = this.props.onAddHTML(div);

        if (html) {
          div.innerHTML = html;
        }
      }
    }
  }, {
    key: "_getSizeAndAspect",
    value: function _getSizeAndAspect() {
      var width = this.gl.drawingBufferWidth;
      var height = this.gl.drawingBufferHeight;
      var aspect = 1;
      var _this$gl$canvas = this.gl.canvas,
          clientWidth = _this$gl$canvas.clientWidth,
          clientHeight = _this$gl$canvas.clientHeight;

      if (clientWidth > 0 && clientHeight > 0) {
        aspect = clientWidth / clientHeight;
      } else if (width > 0 && height > 0) {
        aspect = width / height;
      }

      return {
        width: width,
        height: height,
        aspect: aspect
      };
    }
  }, {
    key: "_resizeViewport",
    value: function _resizeViewport() {
      if (this.autoResizeViewport) {
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
      }
    }
  }, {
    key: "_resizeCanvasDrawingBuffer",
    value: function _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        (0, _webgl.resizeGLContext)(this.gl, {
          useDevicePixels: this.useDevicePixels
        });
      }
    }
  }, {
    key: "_createFramebuffer",
    value: function _createFramebuffer() {
      if (this.props.createFramebuffer) {
        this.framebuffer = new _webgl.Framebuffer(this.gl);
      }
    }
  }, {
    key: "_resizeFramebuffer",
    value: function _resizeFramebuffer() {
      if (this.framebuffer) {
        this.framebuffer.resize({
          width: this.gl.drawingBufferWidth,
          height: this.gl.drawingBufferHeight
        });
      }
    }
  }, {
    key: "_beginTimers",
    value: function _beginTimers() {
      this.frameRate.timeEnd();
      this.frameRate.timeStart();

      if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
        this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
      }

      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.beginTimeElapsedQuery();
      }

      this.cpuTime.timeStart();
    }
  }, {
    key: "_endTimers",
    value: function _endTimers() {
      this.cpuTime.timeEnd();

      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.end();
      }
    }
  }, {
    key: "_startEventHandling",
    value: function _startEventHandling() {
      this.gl.canvas.addEventListener('mousemove', this._onMousemove);
      this.gl.canvas.addEventListener('mouseleave', this._onMouseleave);
    }
  }, {
    key: "_onMousemove",
    value: function _onMousemove(e) {
      this.animationProps._mousePosition = [e.offsetX, e.offsetY];
    }
  }, {
    key: "_onMouseleave",
    value: function _onMouseleave(e) {
      this.animationProps._mousePosition = null;
    }
  }]);
  return AnimationLoop;
}();

exports.default = AnimationLoop;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","@babel/runtime/regenerator":"../../../node_modules/@babel/runtime/regenerator/index.js","@babel/runtime/helpers/esm/asyncToGenerator":"../../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/picking-colors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodePickingColor = encodePickingColor;
exports.decodePickingColor = decodePickingColor;
exports.getNullPickingColor = getNullPickingColor;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NULL_PICKING_COLOR = new Uint8Array([0, 0, 0]);

function encodePickingColor(i) {
  return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 16 & 255];
}

function decodePickingColor(color) {
  var _color = (0, _slicedToArray2.default)(color, 3),
      i1 = _color[0],
      i2 = _color[1],
      i3 = _color[2];

  var index = i1 + i2 * 256 + i3 * 65536 - 1;
  return index;
}

function getNullPickingColor() {
  return NULL_PICKING_COLOR;
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/model-utils.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBuffersFromGeometry = getBuffersFromGeometry;
exports.inferAttributeAccessor = inferAttributeAccessor;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GLTF_TO_LUMA_ATTRIBUTE_MAP = {
  POSITION: 'positions',
  NORMAL: 'normals',
  COLOR_0: 'colors',
  TEXCOORD_0: 'texCoords',
  TEXCOORD_1: 'texCoords1',
  TEXCOORD_2: 'texCoords2'
};

function getBuffersFromGeometry(gl, geometry, options) {
  var buffers = {};

  for (var name in geometry.attributes) {
    var attribute = geometry.attributes[name];
    var remappedName = mapAttributeName(name, options);

    if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      var typedArray = attribute.value;
      var accessor = (0, _objectSpread2.default)({}, attribute);
      delete accessor.value;
      buffers[remappedName] = [new _webgl.Buffer(gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }

  if (geometry.indices) {
    buffers.indices = new _webgl.Buffer(gl, {
      data: geometry.indices.value || geometry.indices,
      target: 34963
    });
  }

  return buffers;
}

function mapAttributeName(name, options) {
  var _ref = options || {},
      _ref$attributeMap = _ref.attributeMap,
      attributeMap = _ref$attributeMap === void 0 ? GLTF_TO_LUMA_ATTRIBUTE_MAP : _ref$attributeMap;

  return attributeMap && attributeMap[name] || name;
}

function inferAttributeAccessor(attributeName, attribute) {
  var category;

  switch (attributeName) {
    case 'indices':
      category = category || 'indices';
      break;

    case 'texCoords':
    case 'texCoord1':
    case 'texCoord2':
    case 'texCoord3':
      category = 'uvs';
      break;

    case 'vertices':
    case 'positions':
    case 'normals':
    case 'pickingColors':
      category = 'vectors';
      break;

    default:
  }

  switch (category) {
    case 'vectors':
      attribute.size = attribute.size || 3;
      break;

    case 'uvs':
      attribute.size = attribute.size || 2;
      break;

    case 'indices':
      attribute.size = attribute.size || 1;
      attribute.isIndexed = attribute.isIndexed === undefined ? true : attribute.isIndexed;
      (0, _utils.assert)(attribute.value instanceof Uint16Array || attribute.value instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
      break;

    default:
  }

  (0, _utils.assert)(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/shaders/modular-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/shaders/modular-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME luma-modular-fragment\n\nprecision highp float;\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transpileShader;

function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);

    case 100:
      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);

    default:
      throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
  }
}

function convertVertexShaderTo300(source) {
  return source.replace(/attribute\s+/g, 'in ').replace(/varying\s+/g, 'out ').replace(/texture2D\(/g, 'texture(').replace(/textureCube\(+/g, 'texture(').replace(/texture2DLodEXT\(/g, 'textureLod(').replace(/textureCubeLodEXT\(/g, 'textureLod(');
}

function convertFragmentShaderTo300(source) {
  return source.replace(/varying\s+/g, 'in ').replace(/texture2D\(/g, 'texture(').replace(/textureCube\(/g, 'texture(').replace(/texture2DLodEXT\(/g, 'textureLod(').replace(/textureCubeLodEXT\(/g, 'textureLod(');
}

function convertVertexShaderTo100(source) {
  return source.replace(/^in\s+/gm, 'attribute ').replace(/^out\s+/gm, 'varying ').replace(/texture\(/g, 'texture2D(');
}

function convertFragmentShaderTo100(source) {
  return source.replace(/^in\s+/gm, 'varying ').replace(/texture\(/g, 'texture2D(');
}
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'shadertools: assertion failed.');
  }
}
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./assert":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _transpileShader = _interopRequireDefault(require("./transpile-shader"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VERTEX_SHADER = 'vs';
var FRAGMENT_SHADER = 'fs';

var ShaderModule = function () {
  function ShaderModule(_ref) {
    var name = _ref.name,
        vs = _ref.vs,
        fs = _ref.fs,
        _ref$dependencies = _ref.dependencies,
        dependencies = _ref$dependencies === void 0 ? [] : _ref$dependencies,
        _ref$getUniforms = _ref.getUniforms,
        getUniforms = _ref$getUniforms === void 0 ? function () {
      return {};
    } : _ref$getUniforms,
        _ref$deprecations = _ref.deprecations,
        deprecations = _ref$deprecations === void 0 ? [] : _ref$deprecations,
        _ref$defines = _ref.defines,
        defines = _ref$defines === void 0 ? {} : _ref$defines,
        vertexShader = _ref.vertexShader,
        fragmentShader = _ref.fragmentShader;
    (0, _classCallCheck2.default)(this, ShaderModule);
    (0, _utils.assert)(typeof name === 'string');
    this.name = name;
    this.vs = vs || vertexShader;
    this.fs = fs || fragmentShader;
    this.getModuleUniforms = getUniforms;
    this.dependencies = dependencies;
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines;
  }

  (0, _createClass2.default)(ShaderModule, [{
    key: "getModuleSource",
    value: function getModuleSource(type, targetGLSLVersion) {
      var moduleSource;

      switch (type) {
        case VERTEX_SHADER:
          moduleSource = (0, _transpileShader.default)(this.vs || '', targetGLSLVersion, true);
          break;

        case FRAGMENT_SHADER:
          moduleSource = (0, _transpileShader.default)(this.fs || '', targetGLSLVersion, false);
          break;

        default:
          (0, _utils.assert)(false);
      }

      if (typeof moduleSource !== 'string') {
        return '';
      }

      return "#define MODULE_".concat(this.name.toUpperCase(), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
    }
  }, {
    key: "getUniforms",
    value: function getUniforms(opts, uniforms) {
      return this.getModuleUniforms(opts, uniforms);
    }
  }, {
    key: "getDefines",
    value: function getDefines() {
      return this.defines;
    }
  }, {
    key: "checkDeprecations",
    value: function checkDeprecations(shaderSource, log) {
      this.deprecations.forEach(function (def) {
        if (def.regex.test(shaderSource)) {
          if (def.deprecated && log) {
            log.deprecated(def.old, def["new"])();
          } else if (log) {
            log.removed(def.old, def["new"])();
          }
        }
      });
    }
  }, {
    key: "_parseDeprecationDefinitions",
    value: function _parseDeprecationDefinitions() {
      var deprecations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      deprecations.forEach(function (def) {
        switch (def.type) {
          case 'function':
            def.regex = new RegExp("\\b".concat(def.old, "\\("));
            break;

          default:
            def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
        }
      });
      return deprecations;
    }
  }]);
  return ShaderModule;
}();

exports.default = ShaderModule;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./transpile-shader":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js","../utils":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module-registry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _shaderModule = _interopRequireDefault(require("./shader-module"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ShaderModuleRegistry = function () {
  function ShaderModuleRegistry() {
    (0, _classCallCheck2.default)(this, ShaderModuleRegistry);
    this.shaderModules = {};
    this.defaultShaderModules = [];
  }

  (0, _createClass2.default)(ShaderModuleRegistry, [{
    key: "setDefaultShaderModules",
    value: function setDefaultShaderModules(modules) {
      this.defaultShaderModules = this.resolveModules(modules);
    }
  }, {
    key: "registerShaderModules",
    value: function registerShaderModules(shaderModuleList) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$ignoreMultipleRe = _ref.ignoreMultipleRegistrations,
          ignoreMultipleRegistrations = _ref$ignoreMultipleRe === void 0 ? false : _ref$ignoreMultipleRe;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = shaderModuleList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var shaderModule = _step.value;

          this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "getShaderModule",
    value: function getShaderModule(moduleOrName) {
      if (moduleOrName instanceof _shaderModule.default) {
        return moduleOrName;
      }

      if (typeof moduleOrName !== 'string') {
        return this._registerShaderModule(moduleOrName, true);
      }

      var module = this.shaderModules[moduleOrName];

      if (!module) {
        (0, _utils.assert)(false, "Unknown shader module ".concat(moduleOrName));
      }

      return module;
    }
  }, {
    key: "resolveModules",
    value: function resolveModules(modules) {
      var _this = this;

      return modules.map(function (moduleOrName) {
        return _this.getShaderModule(moduleOrName);
      });
    }
  }, {
    key: "_registerShaderModule",
    value: function _registerShaderModule(module) {
      var ignoreMultipleRegistrations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (module instanceof _shaderModule.default) {
        return module;
      }

      (0, _utils.assert)(module.name, 'shader module has no name');

      if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {
        module = new _shaderModule.default(module);
        module.dependencies = this.resolveModules(module.dependencies);
        this.shaderModules[module.name] = module;
      } else {
        throw new Error("shader module ".concat(module.name, " already registered"));
      }

      return this.shaderModules[module.name];
    }
  }]);
  return ShaderModuleRegistry;
}();

exports.default = ShaderModuleRegistry;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./shader-module":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js","../utils":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setDefaultShaderModules = setDefaultShaderModules;
exports.registerShaderModules = registerShaderModules;
exports.resolveModules = resolveModules;
exports.getShaderModule = getShaderModule;
exports.TEST_EXPORTS = void 0;

var _shaderModuleRegistry = _interopRequireDefault(require("./shader-module-registry"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shaderModuleRegistry = new _shaderModuleRegistry.default();

function setDefaultShaderModules(modules) {
  shaderModuleRegistry.setDefaultShaderModules(modules);
}

function registerShaderModules(shaderModuleList) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$ignoreMultipleRe = _ref.ignoreMultipleRegistrations,
      ignoreMultipleRegistrations = _ref$ignoreMultipleRe === void 0 ? false : _ref$ignoreMultipleRe;

  shaderModuleRegistry.registerShaderModules(shaderModuleList, {
    ignoreMultipleRegistrations: ignoreMultipleRegistrations
  });
}

function resolveModules(modules) {
  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);
  modules = shaderModuleRegistry.resolveModules(modules);
  return getShaderDependencies(modules);
}

function getShaderModule(moduleOrName) {
  return shaderModuleRegistry.getShaderModule(moduleOrName);
}

function getShaderDependencies(modules) {
  var moduleMap = {};
  var moduleDepth = {};
  getDependencyGraph({
    modules: modules,
    level: 0,
    moduleMap: moduleMap,
    moduleDepth: moduleDepth
  });
  return Object.keys(moduleDepth).sort(function (a, b) {
    return moduleDepth[b] - moduleDepth[a];
  }).map(function (name) {
    return moduleMap[name];
  });
}

function getDependencyGraph(_ref2) {
  var modules = _ref2.modules,
      level = _ref2.level,
      moduleMap = _ref2.moduleMap,
      moduleDepth = _ref2.moduleDepth;

  if (level >= 5) {
    throw new Error('Possible loop in shader dependency graph');
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var module = _step.value;
      moduleMap[module.name] = module;

      if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
        moduleDepth[module.name] = level;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _module = _step2.value;

      if (_module.dependencies) {
        getDependencyGraph({
          modules: _module.dependencies,
          level: level + 1,
          moduleMap: moduleMap,
          moduleDepth: moduleDepth
        });
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
}

var TEST_EXPORTS = {
  getShaderDependencies: getShaderDependencies,
  getDependencyGraph: getDependencyGraph
};
exports.TEST_EXPORTS = TEST_EXPORTS;
},{"./shader-module-registry":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module-registry.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FRAGMENT_SHADER = exports.VERTEX_SHADER = void 0;
var VERTEX_SHADER = 'vs';
exports.VERTEX_SHADER = VERTEX_SHADER;
var FRAGMENT_SHADER = 'fs';
exports.FRAGMENT_SHADER = FRAGMENT_SHADER;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;

function isOldIE() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var navigator = typeof window !== 'undefined' ? window.navigator || {} : {};
  var userAgent = opts.userAgent || navigator.userAgent || '';
  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextInfo = getContextInfo;
exports.canCompileGLGSExtension = canCompileGLGSExtension;
exports.hasFeatures = hasFeatures;
exports.FEATURES = void 0;

var _isOldIe = _interopRequireDefault(require("./is-old-ie"));

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GL_VENDOR = 0x1f00;
var GL_RENDERER = 0x1f01;
var GL_VERSION = 0x1f02;
var GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
var WEBGL_FEATURES = {
  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true],
  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],
  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],
  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]
};
var FEATURES = {};
exports.FEATURES = FEATURES;
Object.keys(WEBGL_FEATURES).forEach(function (key) {
  FEATURES[key] = key;
});

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function getContextInfo(gl) {
  var info = gl.getExtension('WEBGL_debug_renderer_info');
  var vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  var renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  var gpuVendor = identifyGPUVendor(vendor, renderer);
  var gpuInfo = {
    gpuVendor: gpuVendor,
    vendor: vendor,
    renderer: renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}

function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return 'NVIDIA';
  }

  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return 'INTEL';
  }

  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return 'AMD';
  }

  return 'UNKNOWN GPU';
}

var compiledGlslExtensions = {};

function canCompileGLGSExtension(gl, cap) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var feature = WEBGL_FEATURES[cap];
  (0, _assert.default)(feature, cap);

  if (!(0, _isOldIe.default)(opts)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  var extensionName = feature[0];
  var behavior = opts.behavior || 'enable';
  var source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
  var shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}

function getFeature(gl, cap) {
  var feature = WEBGL_FEATURES[cap];
  (0, _assert.default)(feature, cap);
  var extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  var value = typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;
  (0, _assert.default)(value === false || value === true);
  return value;
}

function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(function (feature) {
    return getFeature(gl, feature);
  });
}
},{"./is-old-ie":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js","./assert":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPlatformShaderDefines = getPlatformShaderDefines;
exports.getVersionDefines = getVersionDefines;

var _webglInfo = require("../utils/webgl-info");

function getPlatformShaderDefines(gl) {
  var debugInfo = (0, _webglInfo.getContextInfo)(gl);

  switch (debugInfo.gpuVendor.toLowerCase()) {
    case 'nvidia':
      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";

    case 'intel':
      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";

    case 'amd':
      return "#define AMD_GPU\n";

    default:
      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
  }
}

function getVersionDefines(gl, glslVersion, isFragment) {
  var versionDefines = "#if (__VERSION__ > 120)\n\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DEPTH)) {
    versionDefines += "// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES)) {
    versionDefines += "// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n";
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA, {
    behavior: 'require'
  })) {
    versionDefines += "// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n";
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_TEXTURE_LOD)) {
    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n";
  }

  return versionDefines;
}
},{"../utils/webgl-info":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MODULE_INJECTORS_FS = exports.MODULE_INJECTORS_VS = void 0;
var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
exports.MODULE_INJECTORS_VS = MODULE_INJECTORS_VS;
var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";
exports.MODULE_INJECTORS_FS = MODULE_INJECTORS_FS;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = injectShader;
exports.combineInjects = combineInjects;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _moduleInjectors = require("../modules/module-injectors");

var _constants = require("./constants");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _MODULE_INJECTORS;

var MODULE_INJECTORS = (_MODULE_INJECTORS = {}, (0, _defineProperty2.default)(_MODULE_INJECTORS, _constants.VERTEX_SHADER, _moduleInjectors.MODULE_INJECTORS_VS), (0, _defineProperty2.default)(_MODULE_INJECTORS, _constants.FRAGMENT_SHADER, _moduleInjectors.MODULE_INJECTORS_FS), _MODULE_INJECTORS);
var REGEX_START_OF_MAIN = /void main\s*\([^)]*\)\s*\{\n?/;
var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
var fragments = [];

function injectShader(source, type, inject, injectStandardStubs) {
  var isVertex = type === _constants.VERTEX_SHADER;

  var _loop = function _loop(key) {
    var fragmentData = inject[key];
    fragmentData.sort(function (a, b) {
      return a.order - b.order;
    });
    fragments.length = fragmentData.length;

    for (var i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }

    var fragmentString = "".concat(fragments.join('\n'), "\n");

    switch (key) {
      case 'vs:#decl':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, function (match) {
            return "".concat(fragmentString, "\n").concat(match);
          });
        }

        break;

      case 'vs:#main-start':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, function (match) {
            return match + fragmentString;
          });
        }

        break;

      case 'vs:#main-end':
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, function (match) {
            return fragmentString + match;
          });
        }

        break;

      case 'fs:#decl':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, function (match) {
            return "".concat(fragmentString, "\n").concat(match);
          });
        }

        break;

      case 'fs:#main-start':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, function (match) {
            return match + fragmentString;
          });
        }

        break;

      case 'fs:#main-end':
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, function (match) {
            return fragmentString + match;
          });
        }

        break;

      default:
        source = source.replace(key, function (match) {
          return match + fragmentString;
        });
    }
  };

  for (var key in inject) {
    _loop(key);
  }

  if (injectStandardStubs) {
    source = source.replace('}s*$', function (match) {
      return match + MODULE_INJECTORS[type];
    });
  }

  return source;
}

function combineInjects(injects) {
  var result = {};
  (0, _utils.assert)(Array.isArray(injects) && injects.length > 1);
  injects.forEach(function (inject) {
    for (var key in inject) {
      result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    }
  });
  return result;
}
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../modules/module-injectors":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js","./constants":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js","../utils":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createShaderHook = createShaderHook;
exports.createModuleInjection = createModuleInjection;
exports.assembleShaders = assembleShaders;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _constants = require("./constants");

var _resolveModules = require("./resolve-modules");

var _platformDefines = require("./platform-defines");

var _injectShader = _interopRequireDefault(require("./inject-shader"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _SHADER_TYPE, _HOOK_FUNCTIONS;

var SHADER_TYPE = (_SHADER_TYPE = {}, (0, _defineProperty2.default)(_SHADER_TYPE, _constants.VERTEX_SHADER, 'vertex'), (0, _defineProperty2.default)(_SHADER_TYPE, _constants.FRAGMENT_SHADER, 'fragment'), _SHADER_TYPE);
var HOOK_FUNCTIONS = (_HOOK_FUNCTIONS = {}, (0, _defineProperty2.default)(_HOOK_FUNCTIONS, _constants.VERTEX_SHADER, {}), (0, _defineProperty2.default)(_HOOK_FUNCTIONS, _constants.FRAGMENT_SHADER, {}), _HOOK_FUNCTIONS);
var MODULE_INJECTIONS = {};
var FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";

function createShaderHook(hook) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  hook = hook.trim();

  var _hook$split = hook.split(':'),
      _hook$split2 = (0, _slicedToArray2.default)(_hook$split, 2),
      stage = _hook$split2[0],
      signature = _hook$split2[1];

  var name = hook.replace(/\(.+/, '');
  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {
    signature: signature
  });
}

function createModuleInjection(moduleName, opts) {
  var hook = opts.hook,
      injection = opts.injection,
      _opts$order = opts.order,
      order = _opts$order === void 0 ? 0 : _opts$order;
  var shaderStage = hook.slice(0, 2);
  MODULE_INJECTIONS[moduleName] = MODULE_INJECTIONS[moduleName] || {};
  MODULE_INJECTIONS[moduleName][shaderStage] = MODULE_INJECTIONS[moduleName][shaderStage] || {};
  (0, _utils.assert)(!MODULE_INJECTIONS[moduleName][shaderStage][hook], 'Module injection already created');
  MODULE_INJECTIONS[moduleName][shaderStage][hook] = {
    injection: injection,
    order: order
  };
}

function assembleShaders(gl) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var vs = opts.vs,
      fs = opts.fs;
  var modules = (0, _resolveModules.resolveModules)(opts.modules || []);
  return {
    gl: gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs,
      type: _constants.VERTEX_SHADER,
      modules: modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs,
      type: _constants.FRAGMENT_SHADER,
      modules: modules
    })),
    getUniforms: assembleGetUniforms(modules),
    modules: assembleModuleMap(modules)
  };
}

function assembleShader(gl, _ref) {
  var id = _ref.id,
      source = _ref.source,
      type = _ref.type,
      _ref$modules = _ref.modules,
      modules = _ref$modules === void 0 ? [] : _ref$modules,
      _ref$defines = _ref.defines,
      defines = _ref$defines === void 0 ? {} : _ref$defines,
      _ref$inject = _ref.inject,
      inject = _ref$inject === void 0 ? {} : _ref$inject,
      _ref$prologue = _ref.prologue,
      prologue = _ref$prologue === void 0 ? true : _ref$prologue,
      log = _ref.log;
  (0, _utils.assert)(typeof source === 'string', 'shader source must be a string');
  var isVertex = type === _constants.VERTEX_SHADER;
  var sourceLines = source.split('\n');
  var glslVersion = 100;
  var versionLine = '';
  var coreSource = source;

  if (sourceLines[0].indexOf('#version ') === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join('\n');
  }

  var allDefines = {};
  modules.forEach(function (module) {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  var assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName({
    id: id,
    source: source,
    type: type
  }), "\n").concat(getShaderType({
    type: type
  }), "\n").concat((0, _platformDefines.getPlatformShaderDefines)(gl), "\n").concat((0, _platformDefines.getVersionDefines)(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  var injectStandardStubs = false;
  var hookInjections = {};
  var mainInjections = {};

  for (var key in inject) {
    var injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];

    if (key.match(/^(v|f)s:/)) {
      if (key[3] === '#') {
        mainInjections[key] = [injection];
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var module = _step.value;

      switch (module.name) {
        case 'inject':
          injectStandardStubs = true;
          break;

        default:
          module.checkDeprecations(coreSource, log);
          var moduleSource = module.getModuleSource(type, glslVersion);
          assembledSource += moduleSource;

          if (MODULE_INJECTIONS[module.name]) {
            var injections = MODULE_INJECTIONS[module.name][type];

            for (var _key in injections) {
              if (_key.match(/^(v|f)s:#/)) {
                mainInjections[_key] = mainInjections[_key] || [];

                mainInjections[_key].push(injections[_key]);
              } else {
                hookInjections[_key] = hookInjections[_key] || [];

                hookInjections[_key].push(injections[_key]);
              }
            }
          }

      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  assembledSource += getHookFunctions(type, hookInjections);
  assembledSource += coreSource;
  assembledSource = (0, _injectShader.default)(assembledSource, type, mainInjections, injectStandardStubs);
  return assembledSource;
}

function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    var uniforms = {};
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var module = _step2.value;
        var moduleUniforms = module.getUniforms(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return uniforms;
  };
}

function assembleModuleMap(modules) {
  var result = {};
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var moduleName = _step3.value;
      var shaderModule = (0, _resolveModules.getShaderModule)(moduleName);
      result[moduleName] = shaderModule;
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return result;
}

function getShaderType(_ref2) {
  var type = _ref2.type;
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}

function getShaderName(_ref3) {
  var id = _ref3.id,
      source = _ref3.source,
      type = _ref3.type;
  var injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : '';
}

function getApplicationDefines() {
  var defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var count = 0;
  var sourceText = '';

  for (var define in defines) {
    if (count === 0) {
      sourceText += '\n// APPLICATION DEFINES\n';
    }

    count++;
    var value = defines[define];

    if (value || Number.isFinite(value)) {
      sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
    }
  }

  if (count === 0) {
    sourceText += '\n';
  }

  return sourceText;
}

function getHookFunctions(shaderStage, hookInjections) {
  var result = '';
  var hookFunctions = HOOK_FUNCTIONS[shaderStage];

  for (var hookName in hookFunctions) {
    var hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");

    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }

    if (hookInjections[hookName]) {
      var injections = hookInjections[hookName];
      injections.sort(function (a, b) {
        return a.order - b.order;
      });
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = injections[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var injection = _step4.value;
          result += "  ".concat(injection.injection, "\n");
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }

    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }

    result += '}\n';
  }

  return result;
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","./constants":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js","./resolve-modules":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js","./platform-defines":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js","./inject-shader":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js","../utils":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TYPE_DEFINITIONS = {
  "boolean": {
    validate: function validate(value, propType) {
      return true;
    }
  },
  number: {
    validateType: function validateType(value, propType) {
      return 'value' in propType && (!('max' in propType) || Number.isFinite(propType.max)) && (!('min' in propType) || Number.isFinite(propType.min));
    },
    validate: function validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }
  }
};

function parsePropTypes(propDefs) {
  var propTypes = {};
  var defaultProps = {};

  for (var _i = 0, _Object$entries = Object.entries(propDefs); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),
        propName = _Object$entries$_i[0],
        propDef = _Object$entries$_i[1];

    var propType = parsePropType(propName, propDef);
    propTypes[propName] = propType;
    defaultProps[propName] = propType.value;
  }

  return {
    propTypes: propTypes,
    defaultProps: defaultProps
  };
}

function parsePropType(name, propDef) {
  switch (getTypeOf(propDef)) {
    case 'object':
      propDef = normalizePropType(name, propDef);
      return parsePropDefinition(propDef);

    case 'array':
      return guessArrayType(name, propDef);

    case 'boolean':
      return {
        name: name,
        type: 'boolean',
        value: propDef
      };

    case 'number':
      return guessNumberType(name, propDef);

    case 'function':
      return {
        name: name,
        type: 'function',
        value: propDef
      };

    default:
      return {
        name: name,
        type: 'unknown',
        value: propDef
      };
  }
}

function guessArrayType(name, array) {
  if (/color/i.test(name) && (array.length === 3 || array.length === 4)) {
    return {
      name: name,
      type: 'color',
      value: array
    };
  }

  return {
    name: name,
    type: 'array',
    value: array
  };
}

function normalizePropType(name, propDef) {
  if (!('type' in propDef)) {
    if (!('value' in propDef)) {
      return {
        name: name,
        type: 'object',
        value: propDef
      };
    }

    return Object.assign({
      name: name,
      type: getTypeOf(propDef.value)
    }, propDef);
  }

  return Object.assign({
    name: name
  }, propDef);
}

function parsePropDefinition(propDef) {
  var type = propDef.type;
  var typeDefinition = TYPE_DEFINITIONS[type] || {};
  var typeValidator = typeDefinition.typeValidator;

  if (typeValidator) {}

  return propDef;
}

function guessNumberType(name, value) {
  var isKnownProp = /radius|scale|width|height|pixel|size|miter/i.test(name) && /^((?!scale).)*$/.test(name);
  var max = isKnownProp ? 100 : 1;
  var min = 0;
  return {
    name: name,
    type: 'number',
    max: Math.max(value, max),
    min: Math.min(value, min),
    value: value
  };
}

function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return 'array';
  }

  if (value === null) {
    return 'null';
  }

  return (0, _typeof2.default)(value);
}
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/filters/normalize-module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeShaderModule = normalizeShaderModule;

var _propTypes = require("./prop-types");

function defaultGetUniforms(module, props) {
  var uniforms = {};

  if (props === undefined) {
    for (var key in module.uniforms) {
      uniforms[key] = module.uniforms[key].value;
    }

    return uniforms;
  }

  for (var _key in props) {
    uniforms[_key] = props[_key];
  }

  return uniforms;
}

function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;

    if (module.uniforms) {
      var _parsePropTypes = (0, _propTypes.parsePropTypes)(module.uniforms),
          propTypes = _parsePropTypes.propTypes;

      module.uniforms = propTypes;
    }

    if (module.uniforms && !module.getUniforms) {
      module.getUniforms = defaultGetUniforms.bind(null, module);
    }
  }

  return module;
}
},{"./prop-types":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQualifierDetails = getQualifierDetails;
exports.getPassthroughFS = getPassthroughFS;
exports.typeToChannelSuffix = typeToChannelSuffix;
exports.typeToChannelCount = typeToChannelCount;
exports.convertToVec4 = convertToVec4;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FS100 = 'void main() {gl_FragColor = vec4(0);}';
var FS300 = "#version 300 es\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";

function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  var words = line.replace(/^\s+/, '').split(/\s+/);

  var _words = (0, _slicedToArray2.default)(words, 3),
      qualifier = _words[0],
      type = _words[1],
      definition = _words[2];

  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }

  var name = definition.split(';')[0];
  return {
    qualifier: qualifier,
    type: type,
    name: name
  };
}

function getPassthroughFS() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$version = _ref.version,
      version = _ref$version === void 0 ? 100 : _ref$version,
      input = _ref.input,
      inputType = _ref.inputType,
      output = _ref.output;

  if (!input) {
    return version === 300 ? FS300 : FS100;
  }

  var outputValue = convertToVec4(input, inputType);

  if (version === 300) {
    return "#version 300 es\nin ".concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }

  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}

function typeToChannelSuffix(type) {
  switch (type) {
    case 'float':
      return 'x';

    case 'vec2':
      return 'xy';

    case 'vec3':
      return 'xyz';

    case 'vec4':
      return 'xyzw';

    default:
      (0, _utils.assert)(false);
      return null;
  }
}

function typeToChannelCount(type) {
  switch (type) {
    case 'float':
      return 1;

    case 'vec2':
      return 2;

    case 'vec3':
      return 3;

    case 'vec4':
      return 4;

    default:
      (0, _utils.assert)(false);
      return null;
  }
}

function convertToVec4(variable, type) {
  switch (type) {
    case 'float':
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");

    case 'vec2':
      return "vec4(".concat(variable, ", 0.0, 1.0)");

    case 'vec3':
      return "vec4(".concat(variable, ", 1.0)");

    case 'vec4':
      return variable;

    default:
      (0, _utils.assert)(false);
      return null;
  }
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../utils":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
var _default = {
  name: 'fp32',
  vs: fp32shader,
  fs: null
};
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp64ify = fp64ify;
exports.fp64LowPart = fp64LowPart;
exports.fp64ifyMatrix4 = fp64ifyMatrix4;

function fp64ify(a) {
  var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}

function fp64LowPart(a) {
  return a - Math.fround(a);
}

function fp64ifyMatrix4(matrix) {
  var matrixFP64 = new Float32Array(32);

  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }

  return matrixFP64;
}
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "fp64ify", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64ify;
  }
});
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64LowPart;
  }
});
Object.defineProperty(exports, "fp64ifyMatrix4", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64ifyMatrix4;
  }
});
exports.fp64fs = exports.fp64arithmetic = exports.default = void 0;

var _fp64Utils = require("./fp64-utils");

var _fp64Arithmetic = _interopRequireDefault(require("./fp64-arithmetic.glsl"));

var _fp64Functions = _interopRequireDefault(require("./fp64-functions.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fp64shader = "".concat(_fp64Arithmetic.default, "\n").concat(_fp64Functions.default);
var CONST_UNIFORMS = {
  ONE: 1.0
};

function getUniforms() {
  return Object.assign({}, CONST_UNIFORMS);
}

var _default = {
  name: 'fp64',
  vs: fp64shader,
  fs: null,
  fp64ify: _fp64Utils.fp64ify,
  fp64LowPart: _fp64Utils.fp64LowPart,
  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4,
  getUniforms: getUniforms
};
exports.default = _default;
var fp64arithmetic = {
  name: 'fp64-arithmetic',
  vs: "".concat(_fp64Arithmetic.default),
  fs: null
};
exports.fp64arithmetic = fp64arithmetic;
var fp64fs = {
  name: 'fp64-fs',
  vs: null,
  fs: fp64shader
};
exports.fp64fs = fp64fs;
},{"./fp64-utils":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js","./fp64-arithmetic.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js","./fp64-functions.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("math.gl");

var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_MODULE_OPTIONS = {
  modelMatrix: IDENTITY_MATRIX,
  viewMatrix: IDENTITY_MATRIX,
  projectionMatrix: IDENTITY_MATRIX,
  cameraPositionWorld: [0, 0, 0]
};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var uniforms = {};

  if (opts.modelMatrix !== undefined) {
    uniforms.modelMatrix = opts.modelMatrix;
  }

  if (opts.viewMatrix !== undefined) {
    uniforms.viewMatrix = opts.viewMatrix;
  }

  if (opts.projectionMatrix !== undefined) {
    uniforms.projectionMatrix = opts.projectionMatrix;
  }

  if (opts.cameraPositionWorld !== undefined) {
    uniforms.cameraPositionWorld = opts.cameraPositionWorld;
  }

  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {
    uniforms.viewProjectionMatrix = new _math.Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);
  }

  return uniforms;
}

var common = "varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n";
var vs = "".concat(common, "\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n");
var fs = "\n".concat(common);
var _default = {
  name: 'project',
  getUniforms: getUniforms,
  vs: vs,
  fs: fs
};
exports.default = _default;
},{"math.gl":"../../../node_modules/math.gl/dist/esm/index.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lights = _interopRequireDefault(require("./lights.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  name: 'lights',
  vs: _lights.default,
  fs: _lights.default,
  getUniforms: getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
};
exports.default = _default;
var INITIAL_MODULE_OPTIONS = {};

function convertColor() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? [0, 0, 0] : _ref$color,
      _ref$intensity = _ref.intensity,
      intensity = _ref$intensity === void 0 ? 1.0 : _ref$intensity;

  return color.map(function (component) {
    return component * intensity / 255.0;
  });
}

function getLightSourceUniforms(_ref2) {
  var ambientLight = _ref2.ambientLight,
      _ref2$pointLights = _ref2.pointLights,
      pointLights = _ref2$pointLights === void 0 ? [] : _ref2$pointLights,
      _ref2$directionalLigh = _ref2.directionalLights,
      directionalLights = _ref2$directionalLigh === void 0 ? [] : _ref2$directionalLigh;
  var lightSourceUniforms = {};

  if (ambientLight) {
    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);
  } else {
    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];
  }

  pointLights.forEach(function (pointLight, index) {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation;
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach(function (directionalLight, index) {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

  if ('lightSources' in opts) {
    var _ref3 = opts.lightSources || {},
        ambientLight = _ref3.ambientLight,
        pointLights = _ref3.pointLights,
        directionalLights = _ref3.directionalLights;

    var hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;

    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }

    return Object.assign({}, getLightSourceUniforms({
      ambientLight: ambientLight,
      pointLights: pointLights,
      directionalLights: directionalLights
    }), {
      lighting_uEnabled: true
    });
  }

  if ('lights' in opts) {
    var lightSources = {
      pointLights: [],
      directionalLights: []
    };
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (opts.lights || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var light = _step.value;

        switch (light.type) {
          case 'ambient':
            lightSources.ambientLight = light;
            break;

          case 'directional':
            lightSources.directionalLights.push(light);
            break;

          case 'point':
            lightSources.pointLights.push(light);
            break;

          default:
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return getUniforms({
      lightSources: lightSources
    });
  }

  return {};
}
},{"./lights.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _project = _interopRequireDefault(require("../project/project"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
var DEFAULT_MODULE_OPTIONS = {
  lightDirection: DEFAULT_LIGHT_DIRECTION
};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var uniforms = {};

  if (opts.lightDirection) {
    uniforms.dirlight_uLightDirection = opts.lightDirection;
  }

  return uniforms;
}

var vs = null;
var fs = "uniform vec3 dirlight_uLightDirection;\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n";
var _default = {
  name: 'dirlight',
  vs: vs,
  fs: fs,
  getUniforms: getUniforms,
  dependencies: [_project.default]
};
exports.default = _default;
},{"../project/project":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
var DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null,
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
  pickingThreshold: 1.0,
  pickingActive: false
};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var uniforms = {};

  if (opts.pickingSelectedColor !== undefined) {
    if (opts.pickingSelectedColor === null) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      var selectedColor = [opts.pickingSelectedColor[0], opts.pickingSelectedColor[1], opts.pickingSelectedColor[2]];
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }

  if (opts.pickingHighlightColor !== undefined) {
    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;
  }

  if (opts.pickingThreshold !== undefined) {
    uniforms.picking_uThreshold = opts.pickingThreshold;
  }

  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;
  }

  return uniforms;
}

var vs = "uniform vec3 picking_uSelectedColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    abs(vertexColor.r - picking_uSelectedColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n";
var fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n\n  if (selected) {\n    vec4 highLightColor = picking_uHighlightColor * COLOR_SCALE;\n\n    float highLightAlpha = highLightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  if (picking_uActive && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
var _default = {
  name: 'picking',
  vs: vs,
  fs: fs,
  getUniforms: getUniforms
};
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/diffuse/diffuse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var DEFAULT_MODULE_OPTIONS = {
  diffuseTexture: null,
  diffuseColor: [0.5, 0.5, 0.5, 1]
};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var uniforms = {};

  if (opts.diffuseTexture !== undefined) {
    uniforms.diffuse_uHasTexture = Boolean(opts.diffuseTexture);
    uniforms.diffuse_uTexture = opts.diffuseTexture;
  }

  if (opts.diffuseColor !== undefined) {
    uniforms.diffuse_uColor = opts.diffuseColor;
  }

  return uniforms;
}

var vs = "out vec2 diffuse_vTexCoord;\nvoid diffuse_setTextureCoordinate(vec2 uv) {\n  diffuse_vTexCoord = uv;\n}\n";
var fs = "uniform vec4 diffuse_uColor;\nuniform bool diffuse_uHasTexture;\nuniform sampler2D diffuse_uTexture;\n\nin vec2 diffuse_vTexCoord;\n\n\n\nvec4 diffuse_getColor() {\n  vec2 texCoord = diffuse_vTexCoord;\n  return diffuse_uHasTexture ?\n    texture2D(diffuse_uTexture, vec2(texCoord.s, texCoord.t)) :\n    diffuse_uColor;\n}\n\nvec4 diffuse_filterColor(vec4 color) {\n  return diffuse_getColor();\n}\n";
var _default = {
  name: 'diffuse',
  getUniforms: getUniforms,
  vs: vs,
  fs: fs
};
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phonglighting = exports.gouraudlighting = void 0;

var _lights = _interopRequireDefault(require("../lights/lights"));

var _phongLighting = _interopRequireDefault(require("./phong-lighting.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var gouraudlighting = {
  name: 'gouraud-lighting',
  dependencies: [_lights.default],
  vs: _phongLighting.default,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: getUniforms
};
exports.gouraudlighting = gouraudlighting;
var phonglighting = {
  name: 'phong-lighting',
  dependencies: [_lights.default],
  fs: _phongLighting.default,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms: getUniforms
};
exports.phonglighting = phonglighting;
var INITIAL_MODULE_OPTIONS = {};

function getMaterialUniforms(material) {
  var materialUniforms = {};
  materialUniforms.lighting_uAmbient = material.ambient;
  materialUniforms.lighting_uDiffuse = material.diffuse;
  materialUniforms.lighting_uShininess = material.shininess;
  materialUniforms.lighting_uSpecularColor = material.specularColor;
  return materialUniforms;
}

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

  if (!('material' in opts)) {
    return {};
  }

  var material = opts.material;

  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }

  return getMaterialUniforms(material);
}
},{"../lights/lights":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./phong-lighting.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/project2/project2.vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/project2/project2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _project2Vertex = _interopRequireDefault(require("./project2.vertex.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  name: 'project2',
  vs: _project2Vertex.default,
  fs: _project2Vertex.default
};
exports.default = _default;
},{"./project2.vertex.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/project2/project2.vertex.glsl.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "varying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#if (__VERSION__ < 300)\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n\n\n  float perceptualRoughness = u_MetallicRoughnessValues.y;\n  float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n  vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n  perceptualRoughness = mrSample.g * perceptualRoughness;\n  metallic = mrSample.b * metallic;\n#endif\n  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n  metallic = clamp(metallic, 0.0, 1.0);\n\n  float alphaRoughness = perceptualRoughness * perceptualRoughness;\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n  diffuseColor *= 1.0 - metallic;\n  vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n  float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n  float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n  vec3 specularEnvironmentR0 = specularColor.rgb;\n  vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n  vec3 n = getNormal();\n  vec3 v = normalize(u_Camera - pbr_vPosition);\n\n  float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n  vec3 reflection = -normalize(reflect(v, n));\n\n  PBRInfo pbrInputs = PBRInfo(\n    0.0,\n    NdotV,\n    0.0,\n    0.0,\n    0.0,\n    perceptualRoughness,\n    metallic,\n    specularEnvironmentR0,\n    specularEnvironmentR90,\n    alphaRoughness,\n    diffuseColor,\n    specularColor,\n    n,\n    v\n  );\n\n  vec3 color = vec3(0, 0, 0);\n\n#ifdef USE_LIGHTS\n  PBRInfo_setAmbientLight(pbrInputs);\n  color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n  SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n    if (i < lighting_uDirectionalLightCount) {\n      PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n      color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n    }\n  }\n  SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n    if (i < lighting_uPointLightCount) {\n      PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n      float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n      color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n    }\n  }\n#endif\n#ifdef USE_IBL\n  color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n  float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n  color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n  vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n  color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n  color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n  color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n  color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _project = _interopRequireDefault(require("../project2/project2"));

var _lights = _interopRequireDefault(require("../lights/lights"));

var _pbrVertex = _interopRequireDefault(require("./pbr-vertex.glsl"));

var _pbrFragment = _interopRequireDefault(require("./pbr-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  name: 'pbr',
  vs: _pbrVertex.default,
  fs: _pbrFragment.default,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [_project.default, _lights.default]
};
exports.default = _default;
},{"../project2/project2":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/project2/project2.js","../lights/lights":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./pbr-vertex.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js","./pbr-fragment.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js"}],"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var vs = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
var _default = {
  name: 'transform',
  vs: vs,
  fs: null
};
exports.default = _default;
},{}],"../../../node_modules/@luma.gl/shadertools/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "registerShaderModules", {
  enumerable: true,
  get: function () {
    return _resolveModules.registerShaderModules;
  }
});
Object.defineProperty(exports, "setDefaultShaderModules", {
  enumerable: true,
  get: function () {
    return _resolveModules.setDefaultShaderModules;
  }
});
Object.defineProperty(exports, "assembleShaders", {
  enumerable: true,
  get: function () {
    return _assembleShaders.assembleShaders;
  }
});
Object.defineProperty(exports, "createShaderHook", {
  enumerable: true,
  get: function () {
    return _assembleShaders.createShaderHook;
  }
});
Object.defineProperty(exports, "createModuleInjection", {
  enumerable: true,
  get: function () {
    return _assembleShaders.createModuleInjection;
  }
});
Object.defineProperty(exports, "combineInjects", {
  enumerable: true,
  get: function () {
    return _injectShader.combineInjects;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function () {
    return _normalizeModule.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "getQualifierDetails", {
  enumerable: true,
  get: function () {
    return _shaderUtils.getQualifierDetails;
  }
});
Object.defineProperty(exports, "getPassthroughFS", {
  enumerable: true,
  get: function () {
    return _shaderUtils.getPassthroughFS;
  }
});
Object.defineProperty(exports, "typeToChannelSuffix", {
  enumerable: true,
  get: function () {
    return _shaderUtils.typeToChannelSuffix;
  }
});
Object.defineProperty(exports, "typeToChannelCount", {
  enumerable: true,
  get: function () {
    return _shaderUtils.typeToChannelCount;
  }
});
Object.defineProperty(exports, "convertToVec4", {
  enumerable: true,
  get: function () {
    return _shaderUtils.convertToVec4;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _fp.default;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _fp2.default;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.default;
  }
});
Object.defineProperty(exports, "lights", {
  enumerable: true,
  get: function () {
    return _lights.default;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function () {
    return _dirlight.default;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _picking.default;
  }
});
Object.defineProperty(exports, "diffuse", {
  enumerable: true,
  get: function () {
    return _diffuse.default;
  }
});
Object.defineProperty(exports, "gouraudlighting", {
  enumerable: true,
  get: function () {
    return _phongLighting.gouraudlighting;
  }
});
Object.defineProperty(exports, "phonglighting", {
  enumerable: true,
  get: function () {
    return _phongLighting.phonglighting;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function () {
    return _pbr.default;
  }
});
Object.defineProperty(exports, "_transform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});
exports.MODULAR_SHADERS = void 0;

var _modularVertex = _interopRequireDefault(require("./shaders/modular-vertex.glsl"));

var _modularFragment = _interopRequireDefault(require("./shaders/modular-fragment.glsl"));

var _resolveModules = require("./lib/resolve-modules");

var _assembleShaders = require("./lib/assemble-shaders");

var _injectShader = require("./lib/inject-shader");

var _normalizeModule = require("./lib/filters/normalize-module");

var _shaderUtils = require("./utils/shader-utils");

var _fp = _interopRequireDefault(require("./modules/fp32/fp32"));

var _fp2 = _interopRequireDefault(require("./modules/fp64/fp64"));

var _project = _interopRequireDefault(require("./modules/project/project"));

var _lights = _interopRequireDefault(require("./modules/lights/lights"));

var _dirlight = _interopRequireDefault(require("./modules/dirlight/dirlight"));

var _picking = _interopRequireDefault(require("./modules/picking/picking"));

var _diffuse = _interopRequireDefault(require("./modules/diffuse/diffuse"));

var _phongLighting = require("./modules/phong-lighting/phong-lighting");

var _pbr = _interopRequireDefault(require("./modules/pbr/pbr"));

var _transform = _interopRequireDefault(require("./modules/transform/transform"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MODULAR_SHADERS = {
  vs: _modularVertex.default,
  fs: _modularFragment.default,
  defaultUniforms: {}
};
exports.MODULAR_SHADERS = MODULAR_SHADERS;
},{"./shaders/modular-vertex.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/shaders/modular-vertex.glsl.js","./shaders/modular-fragment.glsl":"../../../node_modules/@luma.gl/shadertools/dist/esm/shaders/modular-fragment.glsl.js","./lib/resolve-modules":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js","./lib/assemble-shaders":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js","./lib/inject-shader":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js","./lib/filters/normalize-module":"../../../node_modules/@luma.gl/shadertools/dist/esm/lib/filters/normalize-module.js","./utils/shader-utils":"../../../node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js","./modules/fp32/fp32":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js","./modules/fp64/fp64":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js","./modules/project/project":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js","./modules/lights/lights":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./modules/dirlight/dirlight":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js","./modules/picking/picking":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js","./modules/diffuse/diffuse":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/diffuse/diffuse.js","./modules/phong-lighting/phong-lighting":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","./modules/pbr/pbr":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js","./modules/transform/transform":"../../../node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js"}],"../../../node_modules/seer/dist/index.js":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var isBrowser = typeof window !== 'undefined' && window.addEventListener;

var timers = new Map();

/**
 * Ready check for Seer initialization
 *
 * @returns {Boolean}
 */
var isReady = function isReady() {
  return isBrowser && window.__SEER_INITIALIZED__;
};

/**
 * Utility method allowing to throttle a user action based on a key and a minimun delay.
 *
 * @param key {String} A unique key
 * @param delay {Number} The minimal delay to throttle
 * @returns {Boolean}
 */
var throttle = function throttle(key, delay) {
  var time = timers.get(key);
  var now = Date.now();
  if (time && now - time < delay) {
    return true;
  }
  timers.set(key, now);
  return false;
};

var replacer = function replacer(seen) {
  return function (key, value) {
    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && seen.has(value)) {
      return;
    }
    seen.add(value);
    var isArray = Object.prototype.toString.call(value).slice(8, -1).includes('Array');
    if (isArray) {
      return Array.prototype.slice.call(value, 0, 20);
    }
    return value;
  };
};

/**
 * Low-level api leveraging window.postMessage
 *
 * @param type {String} The action type
 * @param payload {Any} The action payload
 */
var send = function send(type) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isBrowser || !isReady()) {
    return;
  }

  var seen = new Set();
  var payload = JSON.stringify(data, replacer(seen));

  try {
    window.postMessage({ type: type, payload: payload, source: 'seer-agent' }, '*');
  } catch (e) {
    if (throttle('seer-log', 2E3)) {
      return;
    }
    console.log(e); // eslint-disable-line
  }
};

var listeners = new Map();

var listener = function listener(message) {
  if (!message || !message.data || message.data.source !== 'seer-core') {
    return;
  }
  var _message$data = message.data,
      type = _message$data.type,
      payload = _message$data.payload;


  var typeListeners = listeners.get(type);
  if (typeListeners) {
    typeListeners.forEach(function (cb) {
      return cb(payload);
    });
  }
};

/**
 * Initilize window listener. There will be only one for the whole process
 * to prevent too many registrations.
 *
 * This method will be called automatically if you use the `listenFor` method.
 */
var init = function init() {
  if (!isBrowser || window.__SEER_LISTENER__) {
    return;
  }
  window.addEventListener('message', listener);
  window.__SEER_LISTENER__ = true;
};

/**
 * Clean listener. Can be useful in case you want to unregister upcoming events
 * or liberate memory.
 */
var clean = function clean() {
  if (!isBrowser || !window.__SEER_LISTENER__) {
    return;
  }
  window.removeEventListener('message', listener);
  delete window.__SEER_LISTENER__;
};

/**
 * Create a listener that will be called upon events of the given key.
 *
 * @param key {String} The unique tab key
 * @param cb {Function} A callback that will receive the message payload
 */
var listenFor = function listenFor(type, cb) {
  if (!isBrowser) {
    return;
  }
  if (!type || !cb) {
    throw new Error('Please provide a type and callback');
  }
  if (!listeners.has(type)) {
    listeners.set(type, []);
  }
  if (!window.__SEER_LISTENER__) {
    init();
  }
  listeners.get(type).push(cb);
};

/**
 * Remove an identity listener
 *
 * @param cb {Function} The callback to remove
 */
var removeListener = function removeListener(cb) {
  listeners.forEach(function (typeListeners, key) {
    listeners.set(key, typeListeners.filter(function (l) {
      return l !== cb;
    }));
  });
};

/**
 * Creates a new indexed list.
 * It works by index to get O(1) accessing and performance.
 *
 * @param key {String} The key of the tab
 * @param data {Object} The indexed object
 */
var list = function list(key, data) {
  return send('LIST', { key: key, data: data });
};

/**
 * Creates an element in the indexed list, based on the itemKey.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param data {Any} The value of the item
 */
var listItem = function listItem(key, itemKey) {
  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return send('LIST_ITEM', { key: key, itemKey: itemKey, data: data });
};

/**
 * Update an item property, can be deeply nested.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param path {String} The path of the variable you want to update
 * @param data {Object} The new value
 */
var updateItem = function updateItem(key, itemKey, path, data) {
  return send('UPDATE_ITEM', { key: key, itemKey: itemKey, path: path, data: data });
};

/**
 * Similar to updateItem, but allows to pass an array with {path,data} pairs for
 * multiple update of the same item without having to send multiple messages.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param array {Array} The array of updates
 * @param array.path {String} The path for this update
 * @param array.data {Object} The value of this update
 */
var multiUpdate = function multiUpdate(key, itemKey, array) {
  return send('MULTI_UPDATE_ITEM', { key: key, itemKey: itemKey, array: array });
};

/**
 * Remove a specific item in a specific tab.
 *
 * @param key {String} They key of the tab
 * @param itemKey {String} The key of the item
 */
var deleteItem = function deleteItem(key, itemKey) {
  return send('DELETE_ITEM', { key: key, itemKey: itemKey });
};

/**
 * Will create a log message to an item, that will be displayde with the current time.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param msg {String} The message to display
 */
var addLog = function addLog(key, itemKey, msg) {
  return send('ADD_LOG', { key: key, itemKey: itemKey, msg: msg });
};

exports.default = {

  send: send,
  throttle: throttle,
  isReady: isReady,

  list: list,
  listItem: listItem,
  updateItem: updateItem,
  multiUpdate: multiUpdate,
  deleteItem: deleteItem,
  addLog: addLog,

  listeners: listeners,
  listenFor: listenFor,
  removeListener: removeListener,
  init: init,
  clean: clean

};

},{}],"../../../node_modules/@luma.gl/core/dist/esm/debug/seer-integration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOverrides = exports.setOverride = exports.removeModel = exports.logModel = exports.addModel = void 0;

var _seer = _interopRequireDefault(require("seer"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var models = {};

var addModel = function addModel(model) {
  if (models[model.id]) {
    return;
  }

  models[model.id] = model;

  _seer.default.listItem('luma.gl', model.id);
};

exports.addModel = addModel;

var logModel = function logModel(model, uniforms) {
  if (!_seer.default.isReady() || _seer.default.throttle("luma.gl:".concat(model.id), 1e3)) {
    return;
  }

  var attributesObject = model.geometry ? Object.assign({}, model.geometry.attributes, model.attributes) : model.attributes;
  var uniformsObject = Object.assign({}, model.uniforms, uniforms);

  _seer.default.multiUpdate('luma.gl', model.id, [{
    path: 'objects.uniforms',
    data: uniformsObject
  }, {
    path: 'objects.attributes',
    data: attributesObject
  }]);
};

exports.logModel = logModel;

var removeModel = function removeModel(id) {
  delete models[id];

  _seer.default.deleteItem('luma.gl', id);
};

exports.removeModel = removeModel;

var recursiveSet = function recursiveSet(obj, path, value) {
  if (!obj) {
    return;
  }

  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

var overrides = new Map();

var setOverride = function setOverride(id, valuePath, value) {
  if (!_utils.window.__SEER_INITIALIZED__) {
    return;
  }

  if (!overrides.has(id)) {
    overrides.set(id, new Map());
  }

  var uniforms = overrides.get(id);
  uniforms.set(valuePath, value);
};

exports.setOverride = setOverride;

var getOverrides = function getOverrides(id, uniforms) {
  if (!_utils.window.__SEER_INITIALIZED__ || !id) {
    return;
  }

  var overs = overrides.get(id);

  if (!overs) {
    return;
  }

  overs.forEach(function (value, valuePath) {
    recursiveSet(uniforms, valuePath, value);
  });
};

exports.getOverrides = getOverrides;

_seer.default.listenFor('luma.gl', function (payload) {
  var model = models[payload.itemKey];

  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {
    return;
  }

  var valuePath = payload.valuePath.slice(1);
  setOverride(payload.itemKey, valuePath, payload.value);
  var uniforms = model.getUniforms();
  recursiveSet(uniforms, valuePath, payload.value);
  model.setUniforms(uniforms);
});
},{"seer":"../../../node_modules/seer/dist/index.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/base-model.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _webgl = require("@luma.gl/webgl");

var _shadertools = require("@luma.gl/shadertools");

var _seerIntegration = require("../debug/seer-integration");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_DRAW_PRIORITY = 2;
var LOG_DRAW_TIMEOUT = 10000;
var DEPRECATED_PICKING_UNIFORMS = ['renderPickingBuffer', 'pickingEnabled'];

var BaseModel = function () {
  function BaseModel(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, BaseModel);
    (0, _utils.assert)((0, _webgl.isWebGL)(gl));
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('base-model') : _props$id;
    this.id = id;
    this.gl = gl;
    this.id = props.id || (0, _utils.uid)('Model');
    this.lastLogTime = 0;
    this.initialize(props);

    this._setBaseModelProps(props);
  }

  (0, _createClass2.default)(BaseModel, [{
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.props = {};
      this.program = this._createProgram(props);
      this.vertexArray = new _webgl.VertexArray(this.gl, {
        program: this.program
      });
      this.userData = {};
      this.needsRedraw = true;
      this._attributes = {};
      this.attributes = {};
      this.animatedUniforms = {};
      this.animated = false;
      this.animationLoop = null;
      this.timerQueryEnabled = false;
      this.timeElapsedQuery = undefined;
      this.lastQueryReturned = true;
      this.stats = {
        accumulatedFrameTime: 0,
        averageFrameTime: 0,
        profileFrameCount: 0
      };
      this.pickable = true;

      this._setBaseModelProps(props);

      this.setUniforms(Object.assign({}, this.getModuleUniforms(), this.getModuleUniforms(props.moduleSettings)));
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this._setBaseModelProps(props);
    }
  }, {
    key: "delete",
    value: function _delete() {
      for (var key in this._attributes) {
        if (this._attributes[key] !== this.attributes[key]) {
          this._attributes[key]["delete"]();
        }
      }

      this.program["delete"]();
      this.vertexArray["delete"]();
      (0, _seerIntegration.removeModel)(this.id);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this["delete"]();
    }
  }, {
    key: "isAnimated",
    value: function isAnimated() {
      return this.animated;
    }
  }, {
    key: "getProgram",
    value: function getProgram() {
      return this.program;
    }
  }, {
    key: "getUniforms",
    value: function getUniforms() {
      return this.program.getUniforms();
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      var _this = this;

      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      uniforms = Object.assign({}, uniforms);
      (0, _seerIntegration.getOverrides)(this.id, uniforms);
      uniforms = this._extractAnimatedUniforms(uniforms);
      this.program.setUniforms(uniforms, function () {
        _this._checkForDeprecatedUniforms(uniforms);
      });
      return this;
    }
  }, {
    key: "updateModuleSettings",
    value: function updateModuleSettings(opts) {
      var uniforms = this.getModuleUniforms(opts || {});
      return this.setUniforms(uniforms);
    }
  }, {
    key: "clear",
    value: function clear(opts) {
      (0, _webgl.clear)(this.program.gl, opts);
      return this;
    }
  }, {
    key: "drawGeometry",
    value: function drawGeometry() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _opts$moduleSettings = opts.moduleSettings,
          moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings,
          framebuffer = opts.framebuffer,
          _opts$uniforms = opts.uniforms,
          uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms,
          _opts$attributes = opts.attributes,
          attributes = _opts$attributes === void 0 ? {} : _opts$attributes,
          _opts$transformFeedba = opts.transformFeedback,
          transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba,
          _opts$parameters = opts.parameters,
          parameters = _opts$parameters === void 0 ? {} : _opts$parameters,
          _opts$vertexArray = opts.vertexArray,
          vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray,
          animationProps = opts.animationProps;
      (0, _seerIntegration.addModel)(this);
      this.setAttributes(attributes);
      this.updateModuleSettings(moduleSettings);
      this.setUniforms(uniforms);

      this._refreshAnimationProps(animationProps);

      var logPriority = this._logDrawCallStart(2);

      var drawParams = this.vertexArray.getDrawParams(this.props);

      if (drawParams.isInstanced && !this.isInstanced) {
        _utils.log.warn('Found instanced attributes on non-instanced model', this.id)();
      }

      var isIndexed = drawParams.isIndexed,
          indexType = drawParams.indexType,
          indexOffset = drawParams.indexOffset;
      var isInstanced = this.isInstanced,
          instanceCount = this.instanceCount;

      var noop = function noop() {};

      var _this$props = this.props,
          _this$props$onBeforeR = _this$props.onBeforeRender,
          onBeforeRender = _this$props$onBeforeR === void 0 ? noop : _this$props$onBeforeR,
          _this$props$onAfterRe = _this$props.onAfterRender,
          onAfterRender = _this$props$onAfterRe === void 0 ? noop : _this$props$onAfterRe;
      onBeforeRender();

      this._timerQueryStart();

      var didDraw = this.program.draw(Object.assign({}, opts, {
        logPriority: logPriority,
        uniforms: null,
        framebuffer: framebuffer,
        parameters: parameters,
        drawMode: this.getDrawMode(),
        vertexCount: this.getVertexCount(),
        vertexArray: vertexArray,
        transformFeedback: transformFeedback,
        isIndexed: isIndexed,
        indexType: indexType,
        isInstanced: isInstanced,
        instanceCount: instanceCount,
        offset: isIndexed ? indexOffset : 0
      }));

      this._timerQueryEnd();

      onAfterRender();

      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);

      return didDraw;
    }
  }, {
    key: "transform",
    value: function transform() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _opts$discard = opts.discard,
          discard = _opts$discard === void 0 ? true : _opts$discard,
          feedbackBuffers = opts.feedbackBuffers,
          _opts$unbindModels = opts.unbindModels,
          unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;
      var parameters = opts.parameters;

      if (feedbackBuffers) {
        this._setFeedbackBuffers(feedbackBuffers);
      }

      if (discard) {
        parameters = Object.assign({}, parameters, (0, _defineProperty2.default)({}, 35977, discard));
      }

      unbindModels.forEach(function (model) {
        return model.vertexArray.unbindBuffers();
      });

      try {
        this.draw(Object.assign({}, opts, {
          parameters: parameters
        }));
      } finally {
        unbindModels.forEach(function (model) {
          return model.vertexArray.bindBuffers();
        });
      }

      return this;
    }
  }, {
    key: "_setBaseModelProps",
    value: function _setBaseModelProps(props) {
      Object.assign(this.props, props);

      if ('uniforms' in props) {
        this.setUniforms(props.uniforms);
      }

      if ('pickable' in props) {
        this.pickable = props.pickable;
      }

      if ('timerQueryEnabled' in props) {
        this.timerQueryEnabled = props.timerQueryEnabled && _webgl.Query.isSupported(this.gl, ['timers']);

        if (props.timerQueryEnabled && !this.timerQueryEnabled) {
          _utils.log.warn('GPU timer not supported')();
        }
      }

      if ('_animationProps' in props) {
        this._setAnimationProps(props._animationProps);
      }

      if ('_animationLoop' in props) {
        this.animationLoop = props._animationLoop;
      }
    }
  }, {
    key: "_createProgram",
    value: function _createProgram(_ref) {
      var _ref$vs = _ref.vs,
          vs = _ref$vs === void 0 ? null : _ref$vs,
          _ref$fs = _ref.fs,
          fs = _ref$fs === void 0 ? null : _ref$fs,
          _ref$modules = _ref.modules,
          modules = _ref$modules === void 0 ? null : _ref$modules,
          _ref$defines = _ref.defines,
          defines = _ref$defines === void 0 ? {} : _ref$defines,
          _ref$inject = _ref.inject,
          inject = _ref$inject === void 0 ? {} : _ref$inject,
          _ref$shaderCache = _ref.shaderCache,
          shaderCache = _ref$shaderCache === void 0 ? null : _ref$shaderCache,
          _ref$varyings = _ref.varyings,
          varyings = _ref$varyings === void 0 ? null : _ref$varyings,
          _ref$bufferMode = _ref.bufferMode,
          bufferMode = _ref$bufferMode === void 0 ? 35981 : _ref$bufferMode,
          _ref$program = _ref.program,
          program = _ref$program === void 0 ? null : _ref$program;

      this.getModuleUniforms = function (x) {};

      var id = this.id;

      if (!program) {
        vs = vs || _shadertools.MODULAR_SHADERS.vs;
        fs = fs || _shadertools.MODULAR_SHADERS.fs;
        var assembleResult = (0, _shadertools.assembleShaders)(this.gl, {
          vs: vs,
          fs: fs,
          modules: modules,
          inject: inject,
          defines: defines,
          log: _utils.log
        });
        vs = assembleResult.vs;
        fs = assembleResult.fs;

        if (shaderCache) {
          program = shaderCache.getProgram(this.gl, {
            id: id,
            vs: vs,
            fs: fs
          });
        } else {
          program = new _webgl.Program(this.gl, {
            id: id,
            vs: vs,
            fs: fs,
            varyings: varyings,
            bufferMode: bufferMode
          });
        }

        this.getModuleUniforms = assembleResult.getUniforms || function (x) {};
      }

      (0, _utils.assert)(program instanceof _webgl.Program, 'Model needs a program');
      return program;
    }
  }, {
    key: "_checkForDeprecatedUniforms",
    value: function _checkForDeprecatedUniforms(uniforms) {
      DEPRECATED_PICKING_UNIFORMS.forEach(function (uniform) {
        if (uniform in uniforms) {
          _utils.log.deprecated(uniform, 'use picking shader module and Model class updateModuleSettings()')();
        }
      });
    }
  }, {
    key: "_refreshAnimationProps",
    value: function _refreshAnimationProps(animationProps) {
      animationProps = animationProps || this.animationLoop && this.animationLoop.animationProps;

      if (animationProps) {
        this._setAnimationProps(animationProps);
      }
    }
  }, {
    key: "_evaluateAnimateUniforms",
    value: function _evaluateAnimateUniforms(animationProps) {
      if (!this.animated) {
        return {};
      }

      var animatedUniforms = {};

      for (var uniformName in this.animatedUniforms) {
        var valueFunction = this.animatedUniforms[uniformName];
        animatedUniforms[uniformName] = valueFunction(animationProps);
      }

      return animatedUniforms;
    }
  }, {
    key: "_extractAnimatedUniforms",
    value: function _extractAnimatedUniforms(uniforms) {
      var foundAnimated = false;

      for (var uniformName in uniforms) {
        var newValue = uniforms[uniformName];

        if (typeof newValue === 'function') {
          this.animatedUniforms[uniformName] = newValue;
          foundAnimated = true;
        } else {
          delete this.animatedUniforms[uniformName];
        }
      }

      this.animated = !(0, _utils.isObjectEmpty)(this.animatedUniforms);

      if (!foundAnimated) {
        return uniforms;
      }

      var staticUniforms = {};

      for (var _uniformName in uniforms) {
        if (!this.animatedUniforms[_uniformName]) {
          staticUniforms[_uniformName] = uniforms[_uniformName];
        }
      }

      return staticUniforms;
    }
  }, {
    key: "_timerQueryStart",
    value: function _timerQueryStart() {
      if (this.timerQueryEnabled === true) {
        if (!this.timeElapsedQuery) {
          this.timeElapsedQuery = new _webgl.Query(this.gl);
        }

        if (this.lastQueryReturned) {
          this.lastQueryReturned = false;
          this.timeElapsedQuery.beginTimeElapsedQuery();
        }
      }
    }
  }, {
    key: "_timerQueryEnd",
    value: function _timerQueryEnd() {
      if (this.timerQueryEnabled === true) {
        this.timeElapsedQuery.end();

        if (this.timeElapsedQuery.isResultAvailable()) {
          this.lastQueryReturned = true;
          var elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();
          this.stats.lastFrameTime = elapsedTime;
          this.stats.accumulatedFrameTime += elapsedTime;
          this.stats.profileFrameCount++;
          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount;

          _utils.log.log(LOG_DRAW_PRIORITY, "GPU time ".concat(this.program.id, ": ").concat(this.stats.lastFrameTime, "ms average ").concat(this.stats.averageFrameTime, "ms accumulated: ").concat(this.stats.accumulatedFrameTime, "ms count: ").concat(this.stats.profileFrameCount))();
        }
      }
    }
  }, {
    key: "_logDrawCallStart",
    value: function _logDrawCallStart(priority) {
      var logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;

      if (_utils.log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {
        return undefined;
      }

      this.lastLogTime = Date.now();

      _utils.log.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: _utils.log.priority <= 2
      })();

      return priority;
    }
  }, {
    key: "_logDrawCallEnd",
    value: function _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {
      if (priority === undefined) {
        return;
      }

      var attributeTable = (0, _webgl.getDebugTableForVertexArray)({
        vertexArray: vertexArray,
        header: "".concat(this.id, " attributes"),
        attributes: this._attributes
      });

      var _getDebugTableForUnif = (0, _webgl.getDebugTableForUniforms)({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms)
      }),
          uniformTable = _getDebugTableForUnif.table,
          unusedTable = _getDebugTableForUnif.unusedTable,
          unusedCount = _getDebugTableForUnif.unusedCount;

      var _getDebugTableForUnif2 = (0, _webgl.getDebugTableForUniforms)({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms),
        undefinedOnly: true
      }),
          missingTable = _getDebugTableForUnif2.table,
          missingCount = _getDebugTableForUnif2.count;

      if (missingCount > 0) {
        _utils.log.log('MISSING UNIFORMS', Object.keys(missingTable))();
      }

      if (unusedCount > 0) {
        _utils.log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();
      }

      var configTable = (0, _webgl.getDebugTableForProgramConfiguration)(this.vertexArray.configuration);

      _utils.log.table(priority, attributeTable)();

      _utils.log.table(priority, uniformTable)();

      _utils.log.table(priority + 1, configTable)();

      (0, _seerIntegration.logModel)(this, uniforms);

      if (framebuffer) {
        framebuffer.log({
          priority: LOG_DRAW_PRIORITY,
          message: "Rendered to ".concat(framebuffer.id)
        });
      }

      _utils.log.groupEnd(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id))();
    }
  }]);
  return BaseModel;
}();

exports.default = BaseModel;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/shadertools":"../../../node_modules/@luma.gl/shadertools/dist/esm/index.js","../debug/seer-integration":"../../../node_modules/@luma.gl/core/dist/esm/debug/seer-integration.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/model.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _webgl = require("@luma.gl/webgl");

var _modelUtils = require("./model-utils");

var _baseModel = _interopRequireDefault(require("./base-model"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';
var LOG_DRAW_PRIORITY = 2;

var Model = function (_BaseModel) {
  (0, _inherits2.default)(Model, _BaseModel);

  function Model(gl, props) {
    (0, _classCallCheck2.default)(this, Model);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('model') : _props$id;
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Model).call(this, gl, (0, _objectSpread2.default)({}, props, {
      id: id
    })));
  }

  (0, _createClass2.default)(Model, [{
    key: "initialize",
    value: function initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _get2.default)((0, _getPrototypeOf2.default)(Model.prototype), "initialize", this).call(this, props);
      this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;
      this.vertexCount = props.vertexCount || 0;
      this.geometryBuffers = {};
      this.isInstanced = props.isInstanced || props.instanced;

      this._setModelProps(props);

      this.geometry = {};
      (0, _utils.assert)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Model.prototype), "setProps", this).call(this, props);

      this._setModelProps(props);
    }
  }, {
    key: "delete",
    value: function _delete() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Model.prototype), "delete", this).call(this);

      this._deleteGeometryBuffers();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this["delete"]();
    }
  }, {
    key: "getDrawMode",
    value: function getDrawMode() {
      return this.drawMode;
    }
  }, {
    key: "getVertexCount",
    value: function getVertexCount() {
      return this.vertexCount;
    }
  }, {
    key: "getInstanceCount",
    value: function getInstanceCount() {
      return this.instanceCount;
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.attributes;
    }
  }, {
    key: "setDrawMode",
    value: function setDrawMode(drawMode) {
      this.drawMode = drawMode;
      return this;
    }
  }, {
    key: "setVertexCount",
    value: function setVertexCount(vertexCount) {
      (0, _utils.assert)(Number.isFinite(vertexCount));
      this.vertexCount = vertexCount;
      return this;
    }
  }, {
    key: "setInstanceCount",
    value: function setInstanceCount(instanceCount) {
      (0, _utils.assert)(Number.isFinite(instanceCount));
      this.instanceCount = instanceCount;
      return this;
    }
  }, {
    key: "setGeometry",
    value: function setGeometry(geometry) {
      this.drawMode = geometry.drawMode;
      this.vertexCount = geometry.getVertexCount();

      this._deleteGeometryBuffers();

      this.geometryBuffers = (0, _modelUtils.getBuffersFromGeometry)(this.gl, geometry);
      this.vertexArray.setAttributes(this.geometryBuffers);
      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes() {
      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ((0, _utils.isObjectEmpty)(attributes)) {
        return this;
      }

      var normalizedAttributes = {};

      for (var name in attributes) {
        var attribute = attributes[name];
        normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
      }

      this.vertexArray.setAttributes(normalizedAttributes);
      return this;
    }
  }, {
    key: "draw",
    value: function draw() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.drawGeometry(options);
    }
  }, {
    key: "transform",
    value: function transform() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _options$discard = options.discard,
          discard = _options$discard === void 0 ? true : _options$discard,
          feedbackBuffers = options.feedbackBuffers,
          _options$unbindModels = options.unbindModels,
          unbindModels = _options$unbindModels === void 0 ? [] : _options$unbindModels;
      var parameters = options.parameters;

      if (feedbackBuffers) {
        this._setFeedbackBuffers(feedbackBuffers);
      }

      if (discard) {
        parameters = Object.assign({}, parameters, (0, _defineProperty2.default)({}, 35977, discard));
      }

      unbindModels.forEach(function (model) {
        return model.vertexArray.unbindBuffers();
      });

      try {
        this.draw(Object.assign({}, options, {
          parameters: parameters
        }));
      } finally {
        unbindModels.forEach(function (model) {
          return model.vertexArray.bindBuffers();
        });
      }

      return this;
    }
  }, {
    key: "render",
    value: function render() {
      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _utils.log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();

      return this.setUniforms(uniforms).draw();
    }
  }, {
    key: "_setModelProps",
    value: function _setModelProps(props) {
      if ('instanceCount' in props) {
        this.instanceCount = props.instanceCount;
      }

      if ('geometry' in props) {
        this.setGeometry(props.geometry);
      }

      if ('attributes' in props) {
        this.setAttributes(props.attributes);
      }

      if ('_feedbackBuffers' in props) {
        this._setFeedbackBuffers(props._feedbackBuffers);
      }
    }
  }, {
    key: "_deleteGeometryBuffers",
    value: function _deleteGeometryBuffers() {
      for (var name in this.geometryBuffers) {
        var buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];

        if (buffer instanceof _webgl.Buffer) {
          buffer["delete"]();
        }
      }
    }
  }, {
    key: "_setAnimationProps",
    value: function _setAnimationProps(animationProps) {
      var _this = this;

      if (this.animated) {
        (0, _utils.assert)(animationProps, 'Model.draw(): animated uniforms but no animationProps');

        var animatedUniforms = this._evaluateAnimateUniforms(animationProps);

        this.program.setUniforms(animatedUniforms, function () {
          _this._checkForDeprecatedUniforms(animatedUniforms);
        });
      }
    }
  }, {
    key: "_setFeedbackBuffers",
    value: function _setFeedbackBuffers() {
      var feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ((0, _utils.isObjectEmpty)(feedbackBuffers)) {
        return this;
      }

      var gl = this.program.gl;
      this.transformFeedback = this.transformFeedback || new _webgl.TransformFeedback(gl, {
        program: this.program
      });
      this.transformFeedback.setBuffers(feedbackBuffers);
      return this;
    }
  }, {
    key: "_timerQueryStart",
    value: function _timerQueryStart() {
      if (this.timerQueryEnabled === true) {
        if (!this.timeElapsedQuery) {
          this.timeElapsedQuery = new _webgl.Query(this.gl);
        }

        if (this.lastQueryReturned) {
          this.lastQueryReturned = false;
          this.timeElapsedQuery.beginTimeElapsedQuery();
        }
      }
    }
  }, {
    key: "_timerQueryEnd",
    value: function _timerQueryEnd() {
      if (this.timerQueryEnabled === true) {
        this.timeElapsedQuery.end();

        if (this.timeElapsedQuery.isResultAvailable()) {
          this.lastQueryReturned = true;
          var elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();
          this.stats.lastFrameTime = elapsedTime;
          this.stats.accumulatedFrameTime += elapsedTime;
          this.stats.profileFrameCount++;
          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount;

          _utils.log.log(LOG_DRAW_PRIORITY, "GPU time ".concat(this.program.id, ": ").concat(this.stats.lastFrameTime, "ms average ").concat(this.stats.averageFrameTime, "ms accumulated: ").concat(this.stats.accumulatedFrameTime, "ms count: ").concat(this.stats.profileFrameCount))();
        }
      }
    }
  }]);
  return Model;
}(_baseModel.default);

exports.default = Model;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js","./model-utils":"../../../node_modules/@luma.gl/core/dist/esm/lib/model-utils.js","./base-model":"../../../node_modules/@luma.gl/core/dist/esm/lib/base-model.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/transform-shader-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateForTextures = updateForTextures;
exports.getSizeUniforms = getSizeUniforms;
exports.getVaryingType = getVaryingType;
exports.processAttributeDefinition = processAttributeDefinition;

var _utils = require("../utils");

var _shadertools = require("@luma.gl/shadertools");

var SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';
var SIZE_UNIFORM_PREFIX = 'transform_uSize_';
var VS_POS_VARIABLE = 'transform_position';

function updateForTextures(_ref) {
  var vs = _ref.vs,
      sourceTextureMap = _ref.sourceTextureMap,
      targetTextureVarying = _ref.targetTextureVarying,
      targetTexture = _ref.targetTexture;
  var texAttributeNames = Object.keys(sourceTextureMap);
  var sourceCount = texAttributeNames.length;
  var targetTextureType = null;
  var samplerTextureMap = {};
  var updatedVs = vs;
  var finalInject = {};

  if (sourceCount > 0 || targetTextureVarying) {
    var vsLines = updatedVs.split('\n');
    var updateVsLines = vsLines.slice();
    vsLines.forEach(function (line, index, lines) {
      if (sourceCount > 0) {
        var updated = processAttributeDefinition(line, sourceTextureMap);

        if (updated) {
          var updatedLine = updated.updatedLine,
              inject = updated.inject;
          updateVsLines[index] = updatedLine;
          finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }

      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });

    if (targetTextureVarying) {
      (0, _utils.assert)(targetTexture);
      var sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      var uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      var posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      var inject = {
        'vs:#decl': uniformDeclaration,
        'vs:#main-start': posInstructions
      };
      finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
    }

    updatedVs = updateVsLines.join('\n');
  }

  return {
    vs: updatedVs,
    targetTextureType: targetTextureType,
    inject: finalInject,
    samplerTextureMap: samplerTextureMap
  };
}

function getSizeUniforms(_ref2) {
  var sourceTextureMap = _ref2.sourceTextureMap,
      targetTextureVarying = _ref2.targetTextureVarying,
      targetTexture = _ref2.targetTexture;
  var uniforms = {};
  var width;
  var height;

  if (targetTextureVarying) {
    width = targetTexture.width;
    height = targetTexture.height;
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }

  for (var textureName in sourceTextureMap) {
    var _sourceTextureMap$tex = sourceTextureMap[textureName];
    width = _sourceTextureMap$tex.width;
    height = _sourceTextureMap$tex.height;
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }

  return uniforms;
}

function getAttributeDefinition(line) {
  return (0, _shadertools.getQualifierDetails)(line, ['attribute', 'in']);
}

function getSamplerDeclerations(textureName) {
  var samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  var sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  var uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName: samplerName,
    sizeName: sizeName,
    uniformDeclerations: uniformDeclerations
  };
}

function getVaryingType(line, varying) {
  var qualaiferDetails = (0, _shadertools.getQualifierDetails)(line, ['varying', 'out']);

  if (!qualaiferDetails) {
    return null;
  }

  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}

function processAttributeDefinition(line, textureMap) {
  var samplerTextureMap = {};
  var attributeData = getAttributeDefinition(line);

  if (!attributeData) {
    return null;
  }

  var type = attributeData.type,
      name = attributeData.name;

  if (name && textureMap[name]) {
    var updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");

    var _getSamplerDecleratio = getSamplerDeclerations(name),
        samplerName = _getSamplerDecleratio.samplerName,
        sizeName = _getSamplerDecleratio.sizeName,
        uniformDeclerations = _getSamplerDecleratio.uniformDeclerations;

    var channels = (0, _shadertools.typeToChannelSuffix)(type);
    var sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    var inject = {
      'vs:#decl': uniformDeclerations,
      'vs:#main-start': sampleInstruction
    };
    return {
      updatedLine: updatedLine,
      inject: inject,
      samplerTextureMap: samplerTextureMap
    };
  }

  return null;
}
},{"../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js","@luma.gl/shadertools":"../../../node_modules/@luma.gl/shadertools/dist/esm/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/transform.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _shadertools = require("@luma.gl/shadertools");

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

var _model = _interopRequireDefault(require("./model"));

var _transformShaderUtils = require("./transform-shader-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _SRC_TEX_PARAMETER_OV;

var SRC_TEX_PARAMETER_OVERRIDES = (_SRC_TEX_PARAMETER_OV = {}, (0, _defineProperty2.default)(_SRC_TEX_PARAMETER_OV, 10241, 9728), (0, _defineProperty2.default)(_SRC_TEX_PARAMETER_OV, 10240, 9728), (0, _defineProperty2.default)(_SRC_TEX_PARAMETER_OV, 10242, 33071), (0, _defineProperty2.default)(_SRC_TEX_PARAMETER_OV, 10243, 33071), _SRC_TEX_PARAMETER_OV);
var FS_OUTPUT_VARIABLE = 'transform_output';

var Transform = function () {
  (0, _createClass2.default)(Transform, null, [{
    key: "isSupported",
    value: function isSupported(gl) {
      return (0, _webgl.isWebGL2)(gl);
    }
  }]);

  function Transform(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Transform);
    (0, _utils.assert)((0, _webgl.isWebGL2)(gl));
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.currentIndex = 0;
    this.sourceBuffers = new Array(2);
    this.sourceTextures = new Array(2);
    this.feedbackBuffers = new Array(2);
    this.targetTextures = new Array(2);
    this.transformFeedbacks = new Array(2);
    this.framebuffers = new Array(2);
    this._createdBuffers = {};
    this.elementIDBuffer = null;
    this._targetRefTexName = null;

    this._initialize(props);

    Object.seal(this);
  }

  (0, _createClass2.default)(Transform, [{
    key: "delete",
    value: function _delete() {
      for (var name in this._createdBuffers) {
        this._createdBuffers[name]["delete"]();
      }

      this.model["delete"]();
    }
  }, {
    key: "getBuffer",
    value: function getBuffer() {
      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var bufferOrParams = varyingName ? this.feedbackBuffers[this.currentIndex][varyingName] : null;

      if (!bufferOrParams) {
        return null;
      }

      return bufferOrParams instanceof _webgl.Buffer ? bufferOrParams : bufferOrParams.buffer;
    }
  }, {
    key: "_getTargetTexture",
    value: function _getTargetTexture() {
      if (this.framebuffers[this.currentIndex]) {
        return this.framebuffers[this.currentIndex].attachments[36064];
      }

      return null;
    }
  }, {
    key: "getData",
    value: function getData() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$varyingName = _ref.varyingName,
          varyingName = _ref$varyingName === void 0 ? null : _ref$varyingName,
          _ref$packed = _ref.packed,
          packed = _ref$packed === void 0 ? false : _ref$packed;

      var buffer = this.getBuffer(varyingName);

      if (buffer) {
        return buffer.getData();
      }

      (0, _utils.assert)(!varyingName || varyingName === this.targetTextureVarying);
      var pixels = (0, _webgl.readPixelsToArray)(this.framebuffers[this.currentIndex]);

      if (!packed) {
        return pixels;
      }

      var ArrayType = pixels.constructor;
      var channelCount = (0, _shadertools.typeToChannelCount)(this.targetTextureType);
      var packedPixels = new ArrayType(pixels.length * channelCount / 4);
      var packCount = 0;

      for (var i = 0; i < pixels.length; i += 4) {
        for (var j = 0; j < channelCount; j++) {
          packedPixels[packCount++] = pixels[i + j];
        }
      }

      return packedPixels;
    }
  }, {
    key: "getFramebuffer",
    value: function getFramebuffer() {
      return this.framebuffers[this.currentIndex];
    }
  }, {
    key: "_getInputs",
    value: function _getInputs() {
      var uniforms = {};
      var current = this.currentIndex;
      var attributes = Object.assign({}, this.sourceBuffers[current]);

      if (this.hasSourceTextures || this.targetTextureVarying) {
        attributes.transform_elementID = this.elementIDBuffer;

        for (var sampler in this.samplerTextureMap) {
          var textureName = this.samplerTextureMap[sampler];
          uniforms[sampler] = this.sourceTextures[current][textureName];
        }

        this._setSourceTextureParameters();

        var sizeUniforms = (0, _transformShaderUtils.getSizeUniforms)({
          sourceTextureMap: this.sourceTextures[current],
          targetTextureVarying: this.targetTextureVarying,
          targetTexture: this.targetTextures[current]
        });
        Object.assign(uniforms, sizeUniforms);
      }

      return {
        attributes: attributes,
        uniforms: uniforms
      };
    }
  }, {
    key: "run",
    value: function run() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_getInputs = this._getInputs(),
          attributes = _this$_getInputs.attributes,
          uniforms = _this$_getInputs.uniforms;

      Object.assign(uniforms, opts.uniforms);
      var parameters = Object.assign({}, opts.parameters);
      var _opts$clearRenderTarg = opts.clearRenderTarget,
          clearRenderTarget = _opts$clearRenderTarg === void 0 ? true : _opts$clearRenderTarg;
      var framebuffer = null;
      var discard = true;

      if (this.renderingToTexture) {
        discard = false;
        framebuffer = this.framebuffers[this.currentIndex];
        (0, _utils.assert)(framebuffer);
        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];

        if (clearRenderTarget) {
          this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        }
      }

      this.model.setAttributes(attributes);
      this.model.transform(Object.assign({}, opts, {
        transformFeedback: this.transformFeedbacks[this.currentIndex],
        uniforms: uniforms,
        discard: discard,
        framebuffer: framebuffer,
        parameters: parameters
      }));
    }
  }, {
    key: "swapBuffers",
    value: function swapBuffers() {
      _utils.log.deprecated('swapBuffers()', 'swap()')();

      this.swap();
    }
  }, {
    key: "swap",
    value: function swap() {
      (0, _utils.assert)(this.feedbackMap || this._swapTexture);
      this.currentIndex = (this.currentIndex + 1) % 2;
    }
  }, {
    key: "update",
    value: function update() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (opts.elementCount) {
        this._setElementCount(opts.elementCount);
      }

      var _opts$sourceBuffers = opts.sourceBuffers,
          sourceBuffers = _opts$sourceBuffers === void 0 ? null : _opts$sourceBuffers,
          _opts$feedbackBuffers = opts.feedbackBuffers,
          feedbackBuffers = _opts$feedbackBuffers === void 0 ? null : _opts$feedbackBuffers;
      var currentIndex = this.currentIndex;

      if (sourceBuffers || feedbackBuffers) {
        for (var bufferName in feedbackBuffers) {
          (0, _utils.assert)(feedbackBuffers[bufferName] instanceof _webgl.Buffer || feedbackBuffers[bufferName].buffer instanceof _webgl.Buffer);
        }

        Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);
        Object.assign(this.feedbackBuffers[currentIndex], feedbackBuffers);

        this._createFeedbackBuffers({
          feedbackBuffers: feedbackBuffers
        });

        if (this.transformFeedbacks[currentIndex]) {
          this.transformFeedbacks[currentIndex].setBuffers(this.feedbackBuffers[currentIndex]);
        }

        this._setupSwapBuffers();
      }

      var _sourceTextures = opts._sourceTextures,
          _targetTexture = opts._targetTexture;

      if (_sourceTextures || _targetTexture) {
        Object.assign(this.sourceTextures[currentIndex], _sourceTextures);

        this._updateTargetTexture(_targetTexture || this._targetRefTexName, currentIndex);

        this._setupSwapTextures();
      }
    }
  }, {
    key: "_setSourceTextureParameters",
    value: function _setSourceTextureParameters() {
      var index = this.currentIndex;

      for (var name in this.sourceTextures[index]) {
        this.sourceTextures[index][name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
      }
    }
  }, {
    key: "_setElementCount",
    value: function _setElementCount(elementCount) {
      if (this.elementCount === elementCount) {
        return;
      }

      if (this.elementCount < elementCount) {
        this._updateElementIDBuffer(elementCount);
      }

      this.model.setVertexCount(elementCount);
      this.elementCount = elementCount;
    }
  }, {
    key: "_updateTargetTexture",
    value: function _updateTargetTexture(texture, index) {
      var targetTexture = this._buildTargetTexture(texture);

      if (targetTexture) {
        this.targetTextures[index] = targetTexture;

        if (this.framebuffers[index]) {
          this.framebuffers[index].update({
            attachments: (0, _defineProperty2.default)({}, 36064, this.targetTextures[index]),
            resizeAttachments: false
          });
          this.framebuffers[index].resize({
            width: targetTexture.width,
            height: targetTexture.height
          });
        }
      }
    }
  }, {
    key: "_initialize",
    value: function _initialize() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_validateProps = this._validateProps(props),
          feedbackBuffers = _this$_validateProps.feedbackBuffers,
          feedbackMap = _this$_validateProps.feedbackMap;

      var sourceBuffers = props.sourceBuffers,
          varyings = props.varyings,
          _targetTexture = props._targetTexture,
          _targetTextureVarying = props._targetTextureVarying,
          _swapTexture = props._swapTexture;
      var varyingsArray = varyings;

      if (feedbackMap && !Array.isArray(varyings)) {
        varyingsArray = Object.values(feedbackMap);
      }

      this.varyingsArray = varyingsArray;
      this.feedbackMap = feedbackMap;
      this._swapTexture = _swapTexture;

      if (_targetTexture) {
        this.targetTextureVarying = _targetTextureVarying;
        this.renderingToTexture = true;
        (0, _utils.assert)(this.targetTextureVarying);
      }

      this._setupBuffers({
        sourceBuffers: sourceBuffers,
        feedbackBuffers: feedbackBuffers
      });

      this._setupTextures(props);

      this._setupSwapBuffers();

      this._setupSwapTextures();

      this._buildModel(Object.assign({}, props, {
        id: props.id || 'transform-model',
        drawMode: props.drawMode || 0,
        varyings: varyingsArray
      }));
    }
  }, {
    key: "_validateProps",
    value: function _validateProps(props) {
      var feedbackBuffers = props.feedbackBuffers,
          feedbackMap = props.feedbackMap;
      var destinationBuffers = props.destinationBuffers,
          sourceDestinationMap = props.sourceDestinationMap;

      if (destinationBuffers) {
        _utils.log.deprecated('destinationBuffers', 'feedbackBuffers')();

        feedbackBuffers = feedbackBuffers || destinationBuffers;
      }

      if (sourceDestinationMap) {
        _utils.log.deprecated('sourceDestinationMap', 'feedbackMap')();

        feedbackMap = feedbackMap || sourceDestinationMap;
      }

      var vs = props.vs,
          elementCount = props.elementCount,
          varyings = props.varyings;
      var _sourceTextures = props._sourceTextures,
          _targetTexture = props._targetTexture,
          _targetTextureVarying = props._targetTextureVarying,
          _swapTexture = props._swapTexture;
      (0, _utils.assert)(vs && (varyings || feedbackMap || _targetTexture) && elementCount);

      for (var bufferName in feedbackBuffers || {}) {
        (0, _utils.assert)(feedbackBuffers[bufferName] instanceof _webgl.Buffer || feedbackBuffers[bufferName].buffer instanceof _webgl.Buffer);
      }

      for (var textureName in _sourceTextures || {}) {
        (0, _utils.assert)(_sourceTextures[textureName] instanceof _webgl.Texture2D);
      }

      (0, _utils.assert)(!_targetTexture || _targetTextureVarying);
      (0, _utils.assert)(!_swapTexture || _sourceTextures[_swapTexture]);
      return {
        feedbackBuffers: feedbackBuffers,
        feedbackMap: feedbackMap
      };
    }
  }, {
    key: "_setupBuffers",
    value: function _setupBuffers(_ref2) {
      var _ref2$sourceBuffers = _ref2.sourceBuffers,
          sourceBuffers = _ref2$sourceBuffers === void 0 ? null : _ref2$sourceBuffers,
          _ref2$feedbackBuffers = _ref2.feedbackBuffers,
          feedbackBuffers = _ref2$feedbackBuffers === void 0 ? null : _ref2$feedbackBuffers;
      this.sourceBuffers[0] = Object.assign({}, sourceBuffers);
      this.feedbackBuffers[0] = Object.assign({}, feedbackBuffers);

      this._createFeedbackBuffers({
        feedbackBuffers: feedbackBuffers
      });

      this.sourceBuffers[1] = {};
      this.feedbackBuffers[1] = {};
    }
  }, {
    key: "_setupTextures",
    value: function _setupTextures() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _sourceTextures = props._sourceTextures,
          _targetTexture = props._targetTexture;
      this.sourceTextures[0] = Object.assign({}, _sourceTextures);
      this.sourceTextures[1] = {};
      this.hasSourceTextures = Object.keys(this.sourceTextures[0]).length > 0;

      if (this.targetTextureVarying) {
        var texture = this._buildTargetTexture(_targetTexture);

        (0, _utils.assert)(texture);
        this.targetTextures[0] = texture;
        this.targetTextures[1] = null;
      }
    }
  }, {
    key: "_buildTargetTexture",
    value: function _buildTargetTexture(textureOrAttribute) {
      var _parameters;

      if (textureOrAttribute instanceof _webgl.Texture2D) {
        return textureOrAttribute;
      }

      var refTexture = this.sourceTextures[0][textureOrAttribute];

      if (!refTexture) {
        return null;
      }

      this._targetRefTexName = textureOrAttribute;
      return (0, _webgl.cloneTextureFrom)(refTexture, {
        parameters: (_parameters = {}, (0, _defineProperty2.default)(_parameters, 10241, 9728), (0, _defineProperty2.default)(_parameters, 10240, 9728), (0, _defineProperty2.default)(_parameters, 10242, 33071), (0, _defineProperty2.default)(_parameters, 10243, 33071), _parameters),
        pixelStore: (0, _defineProperty2.default)({}, 37440, false)
      });
    }
  }, {
    key: "_createFeedbackBuffers",
    value: function _createFeedbackBuffers(_ref3) {
      var feedbackBuffers = _ref3.feedbackBuffers;

      if (!this.feedbackMap) {
        return;
      }

      var current = this.currentIndex;

      for (var sourceBufferName in this.feedbackMap) {
        var feedbackBufferName = this.feedbackMap[sourceBufferName];

        if (feedbackBufferName !== this.targetTextureVarying && (!feedbackBuffers || !feedbackBuffers[feedbackBufferName])) {
          var sourceBuffer = this.sourceBuffers[current][sourceBufferName];
          var byteLength = sourceBuffer.byteLength,
              usage = sourceBuffer.usage,
              accessor = sourceBuffer.accessor;
          var buffer = new _webgl.Buffer(this.gl, {
            byteLength: byteLength,
            usage: usage,
            accessor: accessor
          });

          if (this._createdBuffers[feedbackBufferName]) {
            this._createdBuffers[feedbackBufferName]["delete"]();
          }

          this._createdBuffers[feedbackBufferName] = buffer;
          this.feedbackBuffers[current][feedbackBufferName] = buffer;
        }
      }
    }
  }, {
    key: "_createNewBuffer",
    value: function _createNewBuffer(name, opts) {
      var buffer = new _webgl.Buffer(this.gl, opts);

      if (this._createdBuffers[name]) {
        this._createdBuffers[name]["delete"]();

        this._createdBuffers[name] = buffer;
      }

      return buffer;
    }
  }, {
    key: "_setupSwapBuffers",
    value: function _setupSwapBuffers() {
      if (!this.feedbackMap) {
        return;
      }

      var current = this.currentIndex;
      var next = (current + 1) % 2;
      Object.assign(this.sourceBuffers[next], this.sourceBuffers[current]);
      Object.assign(this.feedbackBuffers[next], this.feedbackBuffers[current]);

      for (var srcName in this.feedbackMap) {
        var dstName = this.feedbackMap[srcName];

        if (dstName !== this.targetTextureVarying) {
          this.sourceBuffers[next][srcName] = this.feedbackBuffers[current][dstName];
          this.feedbackBuffers[next][dstName] = this.sourceBuffers[current][srcName];
          (0, _utils.assert)(this.feedbackBuffers[next][dstName] instanceof _webgl.Buffer);
        }
      }

      if (this.transformFeedbacks[next]) {
        this.transformFeedbacks[next].setBuffers(this.feedbackBuffers[next]);
      }
    }
  }, {
    key: "_setupSwapTextures",
    value: function _setupSwapTextures() {
      if (!this._swapTexture || !this.targetTextureVarying) {
        return;
      }

      var current = this.currentIndex;
      var next = (current + 1) % 2;
      Object.assign(this.sourceTextures[next], this.sourceTextures[current]);
      this.sourceTextures[next][this._swapTexture] = this.targetTextures[current];

      this._updateTargetTexture(this.sourceTextures[current][this._swapTexture], next);
    }
  }, {
    key: "_buildModel",
    value: function _buildModel() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_getShaders = this._getShaders(props),
          vs = _this$_getShaders.vs,
          fs = _this$_getShaders.fs,
          modules = _this$_getShaders.modules,
          uniforms = _this$_getShaders.uniforms,
          inject = _this$_getShaders.inject,
          samplerTextureMap = _this$_getShaders.samplerTextureMap;

      this.model = new _model.default(this.gl, Object.assign({}, props, {
        vs: vs,
        fs: fs,
        vertexCount: props.elementCount,
        modules: modules,
        uniforms: uniforms,
        inject: inject
      }));
      this.samplerTextureMap = samplerTextureMap;

      this._setupTransformFeedback();

      this._setupFramebuffers();

      this._setElementCount(props.elementCount);
    }
  }, {
    key: "_setupTransformFeedback",
    value: function _setupTransformFeedback() {
      if ((0, _utils.isObjectEmpty)(this.feedbackBuffers[0])) {
        return;
      }

      this.transformFeedbacks[0] = new _webgl.TransformFeedback(this.gl, {
        program: this.model.program,
        buffers: this.feedbackBuffers[0]
      });

      if (this.feedbackMap) {
        this.transformFeedbacks[1] = new _webgl.TransformFeedback(this.gl, {
          program: this.model.program,
          buffers: this.feedbackBuffers[1]
        });
      }
    }
  }, {
    key: "_setupFramebuffers",
    value: function _setupFramebuffers() {
      if (!this.renderingToTexture) {
        return;
      }

      var _this$targetTextures$ = this.targetTextures[0],
          width = _this$targetTextures$.width,
          height = _this$targetTextures$.height;
      this.framebuffers[0] = new _webgl.Framebuffer(this.gl, {
        id: "".concat(this.id || 'transform', "-framebuffer-0"),
        width: width,
        height: height,
        attachments: (0, _defineProperty2.default)({}, 36064, this.targetTextures[0])
      });

      if (this._swapTexture) {
        var _this$targetTextures$2 = this.targetTextures[1];
        width = _this$targetTextures$2.width;
        height = _this$targetTextures$2.height;
        this.framebuffers[1] = new _webgl.Framebuffer(this.gl, {
          id: "".concat(this.id || 'transform', "-framebuffer-1"),
          width: width,
          height: height,
          attachments: (0, _defineProperty2.default)({}, 36064, this.targetTextures[1])
        });
      }
    }
  }, {
    key: "_updateElementIDBuffer",
    value: function _updateElementIDBuffer(elementCount) {
      if (!this.hasSourceTextures && !this.targetTextureVarying) {
        return;
      }

      var elementIds = new Float32Array(elementCount);
      elementIds.forEach(function (_, index, array) {
        array[index] = index;
      });

      if (!this.elementIDBuffer) {
        this.elementIDBuffer = new _webgl.Buffer(this.gl, {
          data: elementIds,
          accessor: {
            size: 1
          }
        });
      } else {
        this.elementIDBuffer.setData({
          data: elementIds
        });
      }
    }
  }, {
    key: "_getShaders",
    value: function _getShaders() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _this$_processVertexS = this._processVertexShader(props.vs),
          vs = _this$_processVertexS.vs,
          uniforms = _this$_processVertexS.uniforms,
          targetTextureType = _this$_processVertexS.targetTextureType,
          inject = _this$_processVertexS.inject,
          samplerTextureMap = _this$_processVertexS.samplerTextureMap;

      var combinedInject = (0, _shadertools.combineInjects)([props.inject || {}, inject]);
      this.targetTextureType = targetTextureType;
      var fs = (0, _shadertools.getPassthroughFS)({
        version: (0, _webgl.getShaderVersion)(vs),
        input: this.targetTextureVarying,
        inputType: targetTextureType,
        output: FS_OUTPUT_VARIABLE
      });
      var modules = this.hasSourceTextures || this.targetTextureVarying ? [_shadertools._transform].concat(props.modules || []) : props.modules;
      return {
        vs: vs,
        fs: fs,
        modules: modules,
        uniforms: uniforms,
        inject: combinedInject,
        samplerTextureMap: samplerTextureMap
      };
    }
  }, {
    key: "_processVertexShader",
    value: function _processVertexShader(vs) {
      return (0, _transformShaderUtils.updateForTextures)({
        vs: vs,
        sourceTextureMap: this.sourceTextures[this.currentIndex],
        targetTextureVarying: this.targetTextureVarying,
        targetTexture: this.targetTextures[this.currentIndex]
      });
    }
  }]);
  return Transform;
}();

exports.default = Transform;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/shadertools":"../../../node_modules/@luma.gl/shadertools/dist/esm/index.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js","./model":"../../../node_modules/@luma.gl/core/dist/esm/lib/model.js","./transform-shader-utils":"../../../node_modules/@luma.gl/core/dist/esm/lib/transform-shader-utils.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/clip-space.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _model = _interopRequireDefault(require("../lib/model"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
var POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];

var ClipSpace = function (_Model) {
  (0, _inherits2.default)(ClipSpace, _Model);

  function ClipSpace(gl, opts) {
    var _this;

    (0, _classCallCheck2.default)(this, ClipSpace);
    var TEX_COORDS = POSITIONS.map(function (coord) {
      return coord === -1 ? 0 : coord;
    });
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ClipSpace).call(this, gl, Object.assign({}, opts, {
      vs: CLIPSPACE_VERTEX_SHADER,
      geometry: new _geometry.default({
        drawMode: 5,
        vertexCount: 4,
        attributes: {
          aClipSpacePosition: {
            size: 2,
            value: new Float32Array(POSITIONS)
          },
          aTexCoord: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          },
          aCoordinate: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          }
        }
      })
    })));

    _this.setVertexCount(4);

    return _this;
  }

  return ClipSpace;
}(_model.default);

exports.default = ClipSpace;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../lib/model":"../../../node_modules/@luma.gl/core/dist/esm/lib/model.js","../geometry/geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/shader-cache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ShaderCache = function () {
  function ShaderCache() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        gl = _ref.gl,
        _ref$_cachePrograms = _ref._cachePrograms,
        _cachePrograms = _ref$_cachePrograms === void 0 ? false : _ref$_cachePrograms;

    (0, _classCallCheck2.default)(this, ShaderCache);
    (0, _utils.assert)(gl);
    this.gl = gl;
    this.vertexShaders = {};
    this.fragmentShaders = {};
    this.programs = {};
    this._cachePrograms = _cachePrograms;
  }

  (0, _createClass2.default)(ShaderCache, [{
    key: "delete",
    value: function _delete() {
      return this;
    }
  }, {
    key: "getVertexShader",
    value: function getVertexShader(gl, source) {
      (0, _utils.assert)(typeof source === 'string');
      (0, _utils.assert)(this._compareContexts(gl, this.gl));
      var shader = this.vertexShaders[source];

      if (!shader) {
        shader = new _webgl.VertexShader(gl, source);
        this.vertexShaders[source] = shader;
      }

      return shader;
    }
  }, {
    key: "getFragmentShader",
    value: function getFragmentShader(gl, source) {
      (0, _utils.assert)(typeof source === 'string');
      (0, _utils.assert)(this._compareContexts(gl, this.gl));
      var shader = this.fragmentShaders[source];

      if (!shader) {
        shader = new _webgl.FragmentShader(gl, source);
        this.fragmentShaders[source] = shader;
      }

      return shader;
    }
  }, {
    key: "getProgram",
    value: function getProgram(gl, opts) {
      (0, _utils.assert)(this._compareContexts(gl, this.gl));
      (0, _utils.assert)(typeof opts.vs === 'string');
      (0, _utils.assert)(typeof opts.fs === 'string');
      (0, _utils.assert)(typeof opts.id === 'string');

      var cacheKey = this._getProgramKey(opts);

      var program = this.programs[cacheKey];

      if (program) {
        this._resetProgram(program);

        return program;
      }

      program = this._createNewProgram(gl, opts);

      if (this._cachePrograms && this._checkProgramProp(program)) {
        program._isCached = true;
        this.programs[cacheKey] = program;
      }

      return program;
    }
  }, {
    key: "_getProgramKey",
    value: function _getProgramKey(opts) {
      return "".concat(opts.id, "-").concat(opts.vs, "-").concat(opts.fs);
    }
  }, {
    key: "_checkProgramProp",
    value: function _checkProgramProp(program) {
      return !program.varyings;
    }
  }, {
    key: "_createNewProgram",
    value: function _createNewProgram(gl, opts) {
      var vs = opts.vs,
          fs = opts.fs;
      var vertexShader = this.getVertexShader(gl, vs);
      var fragmentShader = this.getFragmentShader(gl, fs);
      return new _webgl.Program(this.gl, Object.assign({}, opts, {
        vs: vertexShader,
        fs: fragmentShader
      }));
    }
  }, {
    key: "_resetProgram",
    value: function _resetProgram(program, opts) {
      program.reset();
    }
  }, {
    key: "_compareContexts",
    value: function _compareContexts(gl1, gl2) {
      return (gl1.gl || gl1) === (gl2.gl || gl2);
    }
  }]);
  return ShaderCache;
}();

exports.default = ShaderCache;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/lib/animation-loop-proxy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _webgl = require("@luma.gl/webgl");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AnimationLoopProxy = function () {
  (0, _createClass2.default)(AnimationLoopProxy, null, [{
    key: "createWorker",
    value: function createWorker(animationLoop) {
      return function (self) {
        animationLoop.setProps({
          useDevicePixels: false,
          autoResizeDrawingBuffer: false
        });
        self.canvas = null;

        function initializeCanvas(canvas) {
          var eventHandlers = new Map();

          canvas.addEventListener = function (type, handler) {
            self.postMessage({
              command: 'addEventListener',
              type: type
            });

            if (!eventHandlers.has(type)) {
              eventHandlers.set(type, []);
            }

            eventHandlers.get(type).push(handler);
          };

          canvas.removeEventListener = function (type, handler) {
            self.postMessage({
              command: 'removeEventListener',
              type: type
            });
            var handlers = eventHandlers.get(type);

            if (handlers) {
              handlers.splice(handlers.indexOf(handler), 1);
            }
          };

          canvas.dispatchEvent = function (type, event) {
            var handlers = eventHandlers.get(type);

            if (handlers) {
              handlers.forEach(function (handler) {
                return handler(event);
              });
            }
          };

          self.canvas = canvas;
        }

        self.addEventListener('message', function (evt) {
          switch (evt.data.command) {
            case 'start':
              initializeCanvas(evt.data.opts.canvas);
              animationLoop.start(evt.data.opts);
              break;

            case 'stop':
              animationLoop.stop();
              break;

            case 'resize':
              self.canvas.width = evt.data.width;
              self.canvas.height = evt.data.height;
              break;

            case 'event':
              self.canvas.dispatchEvent(evt.data.type, evt.data.event);
              break;

            default:
          }
        });
      };
    }
  }]);

  function AnimationLoopProxy(worker) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, AnimationLoopProxy);
    var _opts$onInitialize = opts.onInitialize,
        onInitialize = _opts$onInitialize === void 0 ? function () {} : _opts$onInitialize,
        _opts$onFinalize = opts.onFinalize,
        onFinalize = _opts$onFinalize === void 0 ? function () {} : _opts$onFinalize,
        _opts$useDevicePixels = opts.useDevicePixels,
        useDevicePixels = _opts$useDevicePixels === void 0 ? true : _opts$useDevicePixels,
        _opts$autoResizeDrawi = opts.autoResizeDrawingBuffer,
        autoResizeDrawingBuffer = _opts$autoResizeDrawi === void 0 ? true : _opts$autoResizeDrawi;
    this.props = {
      onInitialize: onInitialize,
      onFinalize: onFinalize
    };
    this.setProps({
      autoResizeDrawingBuffer: autoResizeDrawingBuffer,
      useDevicePixels: useDevicePixels
    });
    (0, _utils.assert)(worker instanceof Worker);
    this.worker = worker;
    this.canvas = null;
    this.width = null;
    this.height = null;
    this._running = false;
    this._animationFrameId = null;
    this._resolveNextFrame = null;
    this._nextFramePromise = null;
    this._onMessage = this._onMessage.bind(this);
    this._onEvent = this._onEvent.bind(this);
    this._updateFrame = this._updateFrame.bind(this);
  }

  (0, _createClass2.default)(AnimationLoopProxy, [{
    key: "setProps",
    value: function setProps(props) {
      if ('autoResizeDrawingBuffer' in props) {
        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      }

      if ('useDevicePixels' in props) {
        this.useDevicePixels = props.useDevicePixels;
      }

      return this;
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;

      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._running) {
        return this;
      }

      this._running = true;
      this.worker.onmessage = this._onMessage;
      (0, _webgl.getPageLoadPromise)().then(function () {
        if (!_this._running) {
          return null;
        }

        _this._createAndTransferCanvas(opts);

        return _this.props.onInitialize(_this);
      }).then(function () {
        if (_this._running) {
          _this._animationFrameId = (0, _webgl.requestAnimationFrame)(_this._updateFrame);
        }
      });
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this._running) {
        (0, _webgl.cancelAnimationFrame)(this._animationFrameId);
        this._animationFrameId = null;
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._running = false;
        this.props.onFinalize(this);
      }

      this.worker.postMessage({
        command: 'stop'
      });
      return this;
    }
  }, {
    key: "waitForRender",
    value: function waitForRender() {
      var _this2 = this;

      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise(function (resolve) {
          _this2._resolveNextFrame = resolve;
        });
      }

      return this._nextFramePromise;
    }
  }, {
    key: "_onMessage",
    value: function _onMessage(evt) {
      switch (evt.data.command) {
        case 'addEventListener':
          this.canvas.addEventListener(evt.data.type, this._onEvent);
          break;

        case 'removeEventListener':
          this.canvas.removeEventListener(evt.data.type, this._onEvent);
          break;

        default:
      }
    }
  }, {
    key: "_onEvent",
    value: function _onEvent(evt) {
      var devicePixelRatio = this.useDevicePixels ? window.devicePixelRatio || 1 : 1;
      var type = evt.type;
      var safeEvent = {};

      for (var key in evt) {
        var value = evt[key];
        var valueType = (0, _typeof2.default)(value);

        if (key === 'offsetX' || key === 'offsetY') {
          value *= devicePixelRatio;
        }

        if (valueType === 'number' || valueType === 'boolean' || valueType === 'string') {
          safeEvent[key] = value;
        }
      }

      this.worker.postMessage({
        command: 'event',
        type: type,
        event: safeEvent
      });
    }
  }, {
    key: "_updateFrame",
    value: function _updateFrame() {
      this._resizeCanvasDrawingBuffer();

      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);

        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }

      this._animationFrameId = (0, _webgl.requestAnimationFrame)(this._updateFrame);
    }
  }, {
    key: "_createAndTransferCanvas",
    value: function _createAndTransferCanvas(opts) {
      var screenCanvas = (0, _webgl.getCanvas)(opts);

      if (!screenCanvas.transferControlToOffscreen) {
        _utils.log.error('OffscreenCanvas is not available in your browser.')();
      }

      var offscreenCanvas = screenCanvas.transferControlToOffscreen();
      this.worker.postMessage({
        command: 'start',
        opts: Object.assign({}, opts, {
          canvas: offscreenCanvas
        })
      }, [offscreenCanvas]);
      this.canvas = screenCanvas;
    }
  }, {
    key: "_resizeCanvasDrawingBuffer",
    value: function _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        var devicePixelRatio = this.useDevicePixels ? window.devicePixelRatio || 1 : 1;
        var width = this.canvas.clientWidth * devicePixelRatio;
        var height = this.canvas.clientHeight * devicePixelRatio;

        if (this.width !== width || this.height !== height) {
          this.width = width;
          this.height = height;
          this.worker.postMessage({
            command: 'resize',
            width: width,
            height: height
          });
        }
      }
    }
  }]);
  return AnimationLoopProxy;
}();

exports.default = AnimationLoopProxy;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Pass = function () {
  function Pass(gl, props) {
    (0, _classCallCheck2.default)(this, Pass);
    var _props$id = props.id,
        id = _props$id === void 0 ? 'pass' : _props$id;
    this.id = id;
    this.gl = gl;
    this.props = {
      enabled: true,
      screen: false,
      swap: false
    };
    Object.assign(this.props, props);
  }

  (0, _createClass2.default)(Pass, [{
    key: "setProps",
    value: function setProps(props) {
      Object.assign(this.props, props);
    }
  }, {
    key: "render",
    value: function render(renderState, animationProps) {
      var _this = this;

      if (!this.props.enabled) {
        return;
      }

      var gl = this.gl;
      var renderParams = {
        gl: gl,
        outputBuffer: renderState.writeBuffer,
        inputBuffer: renderState.readBuffer,
        animationProps: animationProps,
        swapBuffers: function swapBuffers() {
          return renderState._swapFramebuffers();
        }
      };

      if (this.props.screen) {
        renderParams.inputBuffer = renderParams.outputBuffer;
        renderParams.outputBuffer = _webgl.Framebuffer.getDefaultFramebuffer(gl);
      } else if (this.props.swap) {
        renderParams.inputBuffer = renderState.writeBuffer;
        renderParams.outputBuffer = renderState.readBuffer;
      }

      (0, _webgl.withParameters)(gl, {
        framebuffer: renderParams.outputBuffer
      }, function () {
        return _this._renderPass(renderParams);
      });

      if (this.props.debug) {
        renderParams.outputBuffer.log(1, this.id);
      }

      if (this.props.swap) {
        renderState._swapFramebuffers();
      }
    }
  }, {
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var gl = _ref.gl,
          inputBuffer = _ref.inputBuffer,
          outputBuffer = _ref.outputBuffer,
          animationProps = _ref.animationProps;
    }
  }]);
  return Pass;
}();

exports.default = Pass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/composite-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CompositePass = function (_Pass) {
  (0, _inherits2.default)(CompositePass, _Pass);

  function CompositePass(gl, props) {
    (0, _classCallCheck2.default)(this, CompositePass);
    props = Array.isArray(props) ? {
      passes: props
    } : props;
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CompositePass).call(this, gl, Object.assign({
      id: 'composite-pass'
    }, props)));
  }

  (0, _createClass2.default)(CompositePass, [{
    key: "render",
    value: function render() {
      var _this$props$passes = this.props.passes,
          passes = _this$props$passes === void 0 ? [] : _this$props$passes;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pass = _step.value;
          pass.render.apply(pass, arguments);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return CompositePass;
}(_pass.default);

exports.default = CompositePass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/pass.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/render-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RenderState = function () {
  function RenderState(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, RenderState);
    this.gl = gl;
    this.framebuffer1 = new _webgl.Framebuffer(gl, {
      id: 'multi-pass-1',
      stencil: true
    });
    this.framebuffer2 = new _webgl.Framebuffer(gl, {
      id: 'multi-pass-2',
      stencil: true
    });
    this.reset();
  }

  (0, _createClass2.default)(RenderState, [{
    key: "reset",
    value: function reset() {
      this.framebuffer1.resize();
      this.framebuffer2.resize();
      this.writeBuffer = this.framebuffer1;
      this.readBuffer = this.framebuffer2;
      this.maskActive = false;
    }
  }, {
    key: "_swapFramebuffers",
    value: function _swapFramebuffers() {
      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;
    }
  }]);
  return RenderState;
}();

exports.default = RenderState;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/multi-pass-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _compositePass = _interopRequireDefault(require("./composite-pass"));

var _renderState = _interopRequireDefault(require("./render-state"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MultiPassRenderer = function (_CompositePass) {
  (0, _inherits2.default)(MultiPassRenderer, _CompositePass);

  function MultiPassRenderer(gl, props) {
    var _this;

    (0, _classCallCheck2.default)(this, MultiPassRenderer);
    props = Array.isArray(props) ? {
      passes: props
    } : props;
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MultiPassRenderer).call(this, gl, Object.assign({
      id: 'multi-pass'
    }, props)));
    _this.renderState = new _renderState.default(gl, props);
    return _this;
  }

  (0, _createClass2.default)(MultiPassRenderer, [{
    key: "render",
    value: function render(animationProps) {
      this.renderState.reset();
      var _this$props$passes = this.props.passes,
          passes = _this$props$passes === void 0 ? [] : _this$props$passes;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pass = _step.value;
          pass.render(this.renderState, animationProps);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return this;
    }
  }]);
  return MultiPassRenderer;
}(_compositePass.default);

exports.default = MultiPassRenderer;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./composite-pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/composite-pass.js","./render-state":"../../../node_modules/@luma.gl/core/dist/esm/multipass/render-state.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/clear-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ClearPass = function (_Pass) {
  (0, _inherits2.default)(ClearPass, _Pass);

  function ClearPass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, ClearPass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ClearPass).call(this, gl, Object.assign({
      id: 'clear-pass'
    }, props)));
  }

  (0, _createClass2.default)(ClearPass, [{
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var gl = _ref.gl;
      var _this$props$clearBits = this.props.clearBits,
          clearBits = _this$props$clearBits === void 0 ? 16384 | 256 : _this$props$clearBits;
      gl.clear(clearBits);
    }
  }]);
  return ClearPass;
}(_pass.default);

exports.default = ClearPass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/pass.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/render-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RenderPass = function (_Pass) {
  (0, _inherits2.default)(RenderPass, _Pass);

  function RenderPass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, RenderPass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RenderPass).call(this, gl, Object.assign({
      id: 'render-pass'
    }, props)));
  }

  (0, _createClass2.default)(RenderPass, [{
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var animationProps = _ref.animationProps;
      var _this$props = this.props,
          _this$props$models = _this$props.models,
          models = _this$props$models === void 0 ? [] : _this$props$models,
          drawParams = _this$props.drawParams;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = models[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var model = _step.value;
          model.draw(Object.assign({}, drawParams, {
            animationProps: animationProps
          }));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return RenderPass;
}(_pass.default);

exports.default = RenderPass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/pass.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/copy-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _clipSpace = _interopRequireDefault(require("../lib/clip-space"));

var _pass = _interopRequireDefault(require("./pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fs = "uniform sampler2D uDiffuseSampler;\nuniform float uOpacity;\n\nvarying vec2 uv;\n\nvoid main() {\n  vec4 texel = texture2D(uDiffuseSampler, uv);\n  gl_FragColor = uOpacity * texel;\n}\n";

var CopyPass = function (_Pass) {
  (0, _inherits2.default)(CopyPass, _Pass);

  function CopyPass(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, CopyPass);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CopyPass).call(this, gl, Object.assign({
      id: 'copy-pass',
      swap: true
    }, props)));
    _this.clipspace = new _clipSpace.default(gl, {
      id: 'copy-pass',
      fs: fs
    });
    return _this;
  }

  (0, _createClass2.default)(CopyPass, [{
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var inputBuffer = _ref.inputBuffer;
      var _this$props$opacity = this.props.opacity,
          opacity = _this$props$opacity === void 0 ? 1.0 : _this$props$opacity;
      this.clipspace.draw({
        uniforms: {
          uDiffuseSampler: inputBuffer,
          uOpacity: opacity
        },
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }]);
  return CopyPass;
}(_pass.default);

exports.default = CopyPass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../lib/clip-space":"../../../node_modules/@luma.gl/core/dist/esm/lib/clip-space.js","./pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/pass.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/texture-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _clipSpace = _interopRequireDefault(require("../lib/clip-space"));

var _pass = _interopRequireDefault(require("./pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fs = "uniform sampler2D uDiffuseSampler;\nuniform float uOpacity;\nvarying vec2 uv;\n\nvoid main() {\n  vec4 texel = texture2D(uDiffuseSampler, uv);\n  gl_FragColor = uOpacity * texel;\n}\n";

var TexturePass = function (_Pass) {
  (0, _inherits2.default)(TexturePass, _Pass);

  function TexturePass(gl) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TexturePass);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TexturePass).call(this, gl, Object.assign({
      id: 'texture-pass'
    }, options)));
    var texture = options.texture,
        _options$opacity = options.opacity,
        opacity = _options$opacity === void 0 ? 1.0 : _options$opacity;
    _this.clipspace = new _clipSpace.default(gl, {
      id: 'texture-pass',
      fs: fs,
      uniforms: {
        uDiffuseSampler: texture,
        uOpacity: opacity
      }
    });
    return _this;
  }

  (0, _createClass2.default)(TexturePass, [{
    key: "_renderPass",
    value: function _renderPass() {
      this.clipspace.draw({
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }]);
  return TexturePass;
}(_pass.default);

exports.default = TexturePass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../lib/clip-space":"../../../node_modules/@luma.gl/core/dist/esm/lib/clip-space.js","./pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/pass.js"}],"../../../node_modules/@luma.gl/core/dist/esm/multipass/shader-module-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

var _compositePass = _interopRequireDefault(require("./composite-pass"));

var _clipSpace = _interopRequireDefault(require("../lib/clip-space"));

var _shadertools = require("@luma.gl/shadertools");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ShaderModuleSinglePass = function (_Pass) {
  (0, _inherits2.default)(ShaderModuleSinglePass, _Pass);

  function ShaderModuleSinglePass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, ShaderModuleSinglePass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ShaderModuleSinglePass).call(this, gl, Object.assign({
      swap: true
    }, props)));
  }

  (0, _createClass2.default)(ShaderModuleSinglePass, [{
    key: "_renderPass",
    value: function _renderPass(_ref) {
      var inputBuffer = _ref.inputBuffer,
          swapBuffers = _ref.swapBuffers;
      this.props.model.setUniforms(this.props);
      this.props.model.draw({
        uniforms: {
          texture: inputBuffer,
          texSize: [inputBuffer.width, inputBuffer.height]
        },
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }]);
  return ShaderModuleSinglePass;
}(_pass.default);

var ShaderModulePass = function (_CompositePass) {
  (0, _inherits2.default)(ShaderModulePass, _CompositePass);

  function ShaderModulePass(gl, module) {
    var _this;

    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2.default)(this, ShaderModulePass);
    var id = "".concat(module.name, "-pass");
    (0, _shadertools.normalizeShaderModule)(module);
    var passes = normalizePasses(gl, module, id, props);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ShaderModulePass).call(this, gl, Object.assign({
      id: id,
      passes: passes
    }, props)));
    _this.module = module;
    return _this;
  }

  (0, _createClass2.default)(ShaderModulePass, [{
    key: "_renderPass",
    value: function _renderPass(_ref2) {
      var inputBuffer = _ref2.inputBuffer,
          swapBuffers = _ref2.swapBuffers;
      var first = true;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.module.passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var pass = _step.value;

          if (!first) {
            swapBuffers();
          }

          first = false;

          if (pass.uniforms) {
            pass.model.setUniforms(pass.uniforms);
          }

          pass.model.draw({
            uniforms: {
              texture: inputBuffer,
              texSize: [inputBuffer.width, inputBuffer.height]
            },
            parameters: {
              depthWrite: false,
              depthTest: false
            }
          });
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ShaderModulePass;
}(_compositePass.default);

exports.default = ShaderModulePass;

function normalizePasses(gl, module, id, props) {
  if (module.filter || module.sampler) {
    var fs = getFragmentShaderForRenderPass(module);
    var pass = new ShaderModuleSinglePass(gl, {
      id: id,
      model: getModel(gl, module, fs, id, props),
      uniforms: null
    });
    return [pass];
  }

  var passes = module.passes || [];
  return passes.map(function (pass) {
    var fs = getFragmentShaderForRenderPass(module, pass);
    var idn = "".concat(id, "-").concat(passes.length + 1);
    return new ShaderModuleSinglePass(gl, Object.assign({
      id: idn,
      model: getModel(gl, module, fs, idn, props),
      uniforms: pass.uniforms
    }, props));
  });
}

function getModel(gl, module, fs, id, props) {
  var model = new _clipSpace.default(gl, {
    id: id,
    fs: fs,
    modules: [module]
  });
  var uniforms = Object.assign(module.getUniforms(), module.getUniforms(props));
  model.setUniforms(uniforms);
  return model;
}

var FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE(func) {
  return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");
};

var SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE(func) {
  return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");
};

function getFragmentShaderForRenderPass(module) {
  var pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;

  if (pass.filter) {
    var func = typeof pass.filter === 'string' ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }

  if (pass.sampler) {
    var _func = typeof pass.sampler === 'string' ? pass.sampler : "".concat(module.name, "_sampleColor");

    return SAMPLER_FS_TEMPLATE(_func);
  }

  return null;
}
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/pass.js","./composite-pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/composite-pass.js","../lib/clip-space":"../../../node_modules/@luma.gl/core/dist/esm/lib/clip-space.js","@luma.gl/shadertools":"../../../node_modules/@luma.gl/shadertools/dist/esm/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/geometries/truncated-cone-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INDEX_OFFSETS = {
  x: [2, 0, 1],
  y: [0, 1, 2],
  z: [1, 2, 0]
};

var TruncatedConeGeometry = function (_Geometry) {
  (0, _inherits2.default)(TruncatedConeGeometry, _Geometry);

  function TruncatedConeGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, TruncatedConeGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('truncated-code-geometry') : _props$id;

    var _tesselateTruncatedCo = tesselateTruncatedCone(props),
        indices = _tesselateTruncatedCo.indices,
        attributes = _tesselateTruncatedCo.attributes;

    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TruncatedConeGeometry).call(this, (0, _objectSpread2.default)({}, props, {
      id: id,
      indices: indices,
      attributes: (0, _objectSpread2.default)({}, attributes, props.attributes)
    })));
  }

  return TruncatedConeGeometry;
}(_geometry.default);

exports.default = TruncatedConeGeometry;

function tesselateTruncatedCone(props) {
  var _props$bottomRadius = props.bottomRadius,
      bottomRadius = _props$bottomRadius === void 0 ? 0 : _props$bottomRadius,
      _props$topRadius = props.topRadius,
      topRadius = _props$topRadius === void 0 ? 0 : _props$topRadius,
      _props$height = props.height,
      height = _props$height === void 0 ? 1 : _props$height,
      _props$nradial = props.nradial,
      nradial = _props$nradial === void 0 ? 10 : _props$nradial,
      _props$nvertical = props.nvertical,
      nvertical = _props$nvertical === void 0 ? 10 : _props$nvertical,
      _props$verticalAxis = props.verticalAxis,
      verticalAxis = _props$verticalAxis === void 0 ? 'y' : _props$verticalAxis,
      _props$topCap = props.topCap,
      topCap = _props$topCap === void 0 ? false : _props$topCap,
      _props$bottomCap = props.bottomCap,
      bottomCap = _props$bottomCap === void 0 ? false : _props$bottomCap;
  var extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  var numVertices = (nradial + 1) * (nvertical + 1 + extra);
  var slant = Math.atan2(bottomRadius - topRadius, height);
  var msin = Math.sin;
  var mcos = Math.cos;
  var mpi = Math.PI;
  var cosSlant = mcos(slant);
  var sinSlant = msin(slant);
  var start = topCap ? -2 : 0;
  var end = nvertical + (bottomCap ? 2 : 0);
  var vertsAroundEdge = nradial + 1;
  var indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  var indexOffset = INDEX_OFFSETS[verticalAxis];
  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var texCoords = new Float32Array(numVertices * 2);
  var i3 = 0;
  var i2 = 0;

  for (var i = start; i <= end; i++) {
    var v = i / nvertical;
    var y = height * v;
    var ringRadius = void 0;

    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }

    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }

    y -= height / 2;

    for (var j = 0; j < vertsAroundEdge; j++) {
      var sin = msin(j * mpi * 2 / nradial);
      var cos = mcos(j * mpi * 2 / nradial);
      positions[i3 + indexOffset[0]] = sin * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos * ringRadius;
      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;
      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;
      i2 += 2;
      i3 += 3;
    }
  }

  for (var _i = 0; _i < nvertical + extra; _i++) {
    for (var _j = 0; _j < nradial; _j++) {
      var index = (_i * nradial + _j) * 6;
      indices[index + 0] = vertsAroundEdge * (_i + 0) + 0 + _j;
      indices[index + 1] = vertsAroundEdge * (_i + 0) + 1 + _j;
      indices[index + 2] = vertsAroundEdge * (_i + 1) + 1 + _j;
      indices[index + 3] = vertsAroundEdge * (_i + 0) + 0 + _j;
      indices[index + 4] = vertsAroundEdge * (_i + 1) + 1 + _j;
      indices[index + 5] = vertsAroundEdge * (_i + 1) + 0 + _j;
    }
  }

  return {
    indices: indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../geometry/geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/geometries/cone-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ConeGeometry = function (_TruncatedConeGeometr) {
  (0, _inherits2.default)(ConeGeometry, _TruncatedConeGeometr);

  function ConeGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, ConeGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('cone-geometry') : _props$id,
        _props$radius = props.radius,
        radius = _props$radius === void 0 ? 1 : _props$radius,
        _props$cap = props.cap,
        cap = _props$cap === void 0 ? true : _props$cap;
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ConeGeometry).call(this, (0, _objectSpread2.default)({}, props, {
      id: id,
      topRadius: 0,
      topCap: Boolean(cap),
      bottomCap: Boolean(cap),
      bottomRadius: radius
    })));
  }

  return ConeGeometry;
}(_truncatedConeGeometry.default);

exports.default = ConeGeometry;
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./truncated-cone-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/truncated-cone-geometry.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/geometries/cube-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
var CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
var CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
var CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
var ATTRIBUTES = {
  POSITION: {
    size: 3,
    value: new Float32Array(CUBE_POSITIONS)
  },
  NORMAL: {
    size: 3,
    value: new Float32Array(CUBE_NORMALS)
  },
  TEXCOORD_0: {
    size: 2,
    value: new Float32Array(CUBE_TEX_COORDS)
  }
};

var CubeGeometry = function (_Geometry) {
  (0, _inherits2.default)(CubeGeometry, _Geometry);

  function CubeGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, CubeGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('cube-geometry') : _props$id;
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CubeGeometry).call(this, (0, _objectSpread2.default)({}, props, {
      id: id,
      indices: {
        size: 1,
        value: new Uint16Array(CUBE_INDICES)
      },
      attributes: (0, _objectSpread2.default)({}, ATTRIBUTES, props.attributes)
    })));
  }

  return CubeGeometry;
}(_geometry.default);

exports.default = CubeGeometry;
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../geometry/geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/geometries/cylinder-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CylinderGeometry = function (_TruncatedConeGeometr) {
  (0, _inherits2.default)(CylinderGeometry, _TruncatedConeGeometr);

  function CylinderGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, CylinderGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('cylinder-geometry') : _props$id,
        _props$radius = props.radius,
        radius = _props$radius === void 0 ? 1 : _props$radius;
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CylinderGeometry).call(this, (0, _objectSpread2.default)({}, props, {
      id: id,
      bottomRadius: radius,
      topRadius: radius
    })));
  }

  return CylinderGeometry;
}(_truncatedConeGeometry.default);

exports.default = CylinderGeometry;
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./truncated-cone-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/truncated-cone-geometry.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/geometries/ico-sphere-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _math = require("math.gl");

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
var ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];

var IcoSphereGeometry = function (_Geometry) {
  (0, _inherits2.default)(IcoSphereGeometry, _Geometry);

  function IcoSphereGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, IcoSphereGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('ico-sphere-geometry') : _props$id;

    var _tesselateIcosaHedron = tesselateIcosaHedron(props),
        indices = _tesselateIcosaHedron.indices,
        attributes = _tesselateIcosaHedron.attributes;

    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(IcoSphereGeometry).call(this, (0, _objectSpread2.default)({}, props, {
      id: id,
      indices: indices,
      attributes: (0, _objectSpread2.default)({}, attributes, props.attributes)
    })));
  }

  return IcoSphereGeometry;
}(_geometry.default);

exports.default = IcoSphereGeometry;

function tesselateIcosaHedron() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _props$iterations = props.iterations,
      iterations = _props$iterations === void 0 ? 0 : _props$iterations;
  var PI = Math.PI;
  var PI2 = PI * 2;
  var positions = [].concat(ICO_POSITIONS);
  var indices = [].concat(ICO_INDICES);
  positions.push();
  indices.push();

  var getMiddlePoint = function () {
    var pointMemo = {};
    return function (i1, i2) {
      i1 *= 3;
      i2 *= 3;
      var mini = i1 < i2 ? i1 : i2;
      var maxi = i1 > i2 ? i1 : i2;
      var key = "".concat(mini, "|").concat(maxi);

      if (key in pointMemo) {
        return pointMemo[key];
      }

      var x1 = positions[i1];
      var y1 = positions[i1 + 1];
      var z1 = positions[i1 + 2];
      var x2 = positions[i2];
      var y2 = positions[i2 + 1];
      var z2 = positions[i2 + 2];
      var xm = (x1 + x2) / 2;
      var ym = (y1 + y2) / 2;
      var zm = (z1 + z2) / 2;
      var len = Math.sqrt(xm * xm + ym * ym + zm * zm);
      xm /= len;
      ym /= len;
      zm /= len;
      positions.push(xm, ym, zm);
      return pointMemo[key] = positions.length / 3 - 1;
    };
  }();

  for (var i = 0; i < iterations; i++) {
    var indices2 = [];

    for (var j = 0; j < indices.length; j += 3) {
      var a = getMiddlePoint(indices[j + 0], indices[j + 1]);
      var b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      var c = getMiddlePoint(indices[j + 2], indices[j + 0]);
      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
    }

    indices = indices2;
  }

  var normals = new Array(indices.length * 3);
  var texCoords = new Array(indices.length * 2);
  var l = indices.length;

  for (var _i = l - 3; _i >= 0; _i -= 3) {
    var i1 = indices[_i + 0];
    var i2 = indices[_i + 1];
    var i3 = indices[_i + 2];
    var in1 = i1 * 3;
    var in2 = i2 * 3;
    var in3 = i3 * 3;
    var iu1 = i1 * 2;
    var iu2 = i2 * 2;
    var iu3 = i3 * 2;
    var x1 = positions[in1 + 0];
    var y1 = positions[in1 + 1];
    var z1 = positions[in1 + 2];
    var theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    var phi1 = Math.atan2(y1, x1) + PI;
    var v1 = theta1 / PI;
    var u1 = 1 - phi1 / PI2;
    var x2 = positions[in2 + 0];
    var y2 = positions[in2 + 1];
    var z2 = positions[in2 + 2];
    var theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    var phi2 = Math.atan2(y2, x2) + PI;
    var v2 = theta2 / PI;
    var u2 = 1 - phi2 / PI2;
    var x3 = positions[in3 + 0];
    var y3 = positions[in3 + 1];
    var z3 = positions[in3 + 2];
    var theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    var phi3 = Math.atan2(y3, x3) + PI;
    var v3 = theta3 / PI;
    var u3 = 1 - phi3 / PI2;
    var vec1 = [x3 - x2, y3 - y2, z3 - z2];
    var vec2 = [x1 - x2, y1 - y2, z1 - z2];
    var normal = new _math.Vector3(vec1).cross(vec2).normalize();
    var newIndex = void 0;

    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }

    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;
    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;
    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }

  return {
    indices: {
      size: 1,
      value: new Uint16Array(indices)
    },
    attributes: {
      POSITION: {
        size: 3,
        value: new Float32Array(positions)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(normals)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(texCoords)
      }
    }
  };
}
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../geometry/geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpackIndexedGeometry = unpackIndexedGeometry;

function unpackIndexedGeometry(geometry) {
  var indices = geometry.indices,
      attributes = geometry.attributes;

  if (!indices) {
    return geometry;
  }

  var POSITION = attributes.POSITION,
      NORMAL = attributes.NORMAL,
      TEXCOORD_0 = attributes.TEXCOORD_0;
  var unpackedPositions = new Float32Array(indices.length * 3);
  var unpackedNormals = new Float32Array(indices.length * 3);
  var unpackedTexCoords = new Float32Array(indices.length * 2);

  for (var x = 0; x < indices.length; ++x) {
    var index = indices[x];
    unpackedPositions[x * 3 + 0] = POSITION[index * 3 + 0];
    unpackedPositions[x * 3 + 1] = POSITION[index * 3 + 1];
    unpackedPositions[x * 3 + 2] = POSITION[index * 3 + 2];
    unpackedNormals[x * 3 + 0] = NORMAL[index * 3 + 0];
    unpackedNormals[x * 3 + 1] = NORMAL[index * 3 + 1];
    unpackedNormals[x * 3 + 2] = NORMAL[index * 3 + 2];
    unpackedTexCoords[x * 2 + 0] = TEXCOORD_0[index * 2 + 0];
    unpackedTexCoords[x * 2 + 1] = TEXCOORD_0[index * 2 + 1];
  }

  return {
    attributes: {
      POSITION: unpackedPositions,
      NORMAL: unpackedNormals,
      TEXCOORD_0: unpackedTexCoords
    }
  };
}
},{}],"../../../node_modules/@luma.gl/core/dist/esm/geometries/plane-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _geometryUtils = require("../geometry/geometry-utils");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PlaneGeometry = function (_Geometry) {
  (0, _inherits2.default)(PlaneGeometry, _Geometry);

  function PlaneGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, PlaneGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('plane-geometry') : _props$id;

    var _tesselatePlane = tesselatePlane(props),
        indices = _tesselatePlane.indices,
        attributes = _tesselatePlane.attributes;

    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PlaneGeometry).call(this, (0, _objectSpread2.default)({}, props, {
      id: id,
      indices: indices,
      attributes: (0, _objectSpread2.default)({}, attributes, props.attributes)
    })));
  }

  return PlaneGeometry;
}(_geometry.default);

exports.default = PlaneGeometry;

function tesselatePlane(props) {
  var _props$type = props.type,
      type = _props$type === void 0 ? 'x,y' : _props$type,
      _props$offset = props.offset,
      offset = _props$offset === void 0 ? 0 : _props$offset,
      _props$flipCull = props.flipCull,
      flipCull = _props$flipCull === void 0 ? false : _props$flipCull,
      _props$unpack = props.unpack,
      unpack = _props$unpack === void 0 ? false : _props$unpack;
  var coords = type.split(',');
  var c1len = props["".concat(coords[0], "len")];
  var c2len = props["".concat(coords[1], "len")];
  var subdivisions1 = props["n".concat(coords[0])] || 1;
  var subdivisions2 = props["n".concat(coords[1])] || 1;
  var numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var texCoords = new Float32Array(numVertices * 2);

  if (flipCull) {
    c1len = -c1len;
  }

  var i2 = 0;
  var i3 = 0;

  for (var z = 0; z <= subdivisions2; z++) {
    for (var x = 0; x <= subdivisions1; x++) {
      var u = x / subdivisions1;
      var v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;

      switch (type) {
        case 'x,y':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;

        case 'x,z':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;

        case 'y,z':
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;

        default:
          break;
      }

      i2 += 2;
      i3 += 3;
    }
  }

  var numVertsAcross = subdivisions1 + 1;
  var indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);

  for (var _z = 0; _z < subdivisions2; _z++) {
    for (var _x = 0; _x < subdivisions1; _x++) {
      var index = (_z * subdivisions1 + _x) * 6;
      indices[index + 0] = (_z + 0) * numVertsAcross + _x;
      indices[index + 1] = (_z + 1) * numVertsAcross + _x;
      indices[index + 2] = (_z + 0) * numVertsAcross + _x + 1;
      indices[index + 3] = (_z + 1) * numVertsAcross + _x;
      indices[index + 4] = (_z + 1) * numVertsAcross + _x + 1;
      indices[index + 5] = (_z + 0) * numVertsAcross + _x + 1;
    }
  }

  var geometry = {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
  return unpack ? (0, _geometryUtils.unpackIndexedGeometry)(geometry) : geometry;
}
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../geometry/geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry.js","../geometry/geometry-utils":"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry-utils.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/geometries/sphere-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SphereGeometry = function (_Geometry) {
  (0, _inherits2.default)(SphereGeometry, _Geometry);

  function SphereGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, SphereGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _utils.uid)('sphere-geometry') : _props$id;

    var _tesselateSphere = tesselateSphere(props),
        indices = _tesselateSphere.indices,
        attributes = _tesselateSphere.attributes;

    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SphereGeometry).call(this, (0, _objectSpread2.default)({}, props, {
      id: id,
      indices: indices,
      attributes: (0, _objectSpread2.default)({}, attributes, props.attributes)
    })));
  }

  return SphereGeometry;
}(_geometry.default);

exports.default = SphereGeometry;

function tesselateSphere(props) {
  var _props$nlat = props.nlat,
      nlat = _props$nlat === void 0 ? 10 : _props$nlat,
      _props$nlong = props.nlong,
      nlong = _props$nlong === void 0 ? 10 : _props$nlong;
  var _props$radius = props.radius,
      radius = _props$radius === void 0 ? 1 : _props$radius;
  var startLat = 0;
  var endLat = Math.PI;
  var latRange = endLat - startLat;
  var startLong = 0;
  var endLong = 2 * Math.PI;
  var longRange = endLong - startLong;
  var numVertices = (nlat + 1) * (nlong + 1);

  if (typeof radius === 'number') {
    var value = radius;

    radius = function radius(n1, n2, n3, u, v) {
      return value;
    };
  }

  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var texCoords = new Float32Array(numVertices * 2);
  var indices = new Uint16Array(nlat * nlong * 6);

  for (var y = 0; y <= nlat; y++) {
    for (var x = 0; x <= nlong; x++) {
      var u = x / nlong;
      var v = y / nlat;
      var index = x + y * (nlong + 1);
      var i2 = index * 2;
      var i3 = index * 3;
      var theta = longRange * u;
      var phi = latRange * v;
      var sinTheta = Math.sin(theta);
      var cosTheta = Math.cos(theta);
      var sinPhi = Math.sin(phi);
      var cosPhi = Math.cos(phi);
      var ux = cosTheta * sinPhi;
      var uy = cosPhi;
      var uz = sinTheta * sinPhi;
      var r = radius(ux, uy, uz, u, v);
      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;
      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;
      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }

  var numVertsAround = nlat + 1;

  for (var _x = 0; _x < nlat; _x++) {
    for (var _y = 0; _y < nlong; _y++) {
      var _index = (_x * nlong + _y) * 6;

      indices[_index + 0] = _y * numVertsAround + _x;
      indices[_index + 1] = _y * numVertsAround + _x + 1;
      indices[_index + 2] = (_y + 1) * numVertsAround + _x;
      indices[_index + 3] = (_y + 1) * numVertsAround + _x;
      indices[_index + 4] = _y * numVertsAround + _x + 1;
      indices[_index + 5] = (_y + 1) * numVertsAround + _x + 1;
    }
  }

  return {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../geometry/geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry.js","../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/materials/phong-material.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _material = _interopRequireDefault(require("./material"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultProps = {
  ambient: 0.35,
  diffuse: 0.6,
  shininess: 32,
  specularColor: [30, 30, 30]
};

var PhongMaterial = function (_Material) {
  (0, _inherits2.default)(PhongMaterial, _Material);

  function PhongMaterial(props) {
    var _this;

    (0, _classCallCheck2.default)(this, PhongMaterial);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PhongMaterial).call(this, props));
    props = Object.assign({}, defaultProps, props);
    Object.assign((0, _assertThisInitialized2.default)(_this), props);
    return _this;
  }

  return PhongMaterial;
}(_material.default);

exports.default = PhongMaterial;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./material":"../../../node_modules/@luma.gl/core/dist/esm/materials/material.js"}],"../../../node_modules/@luma.gl/core/dist/esm/materials/pbr-material.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _material = _interopRequireDefault(require("./material"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PBRMaterial = function (_Material) {
  (0, _inherits2.default)(PBRMaterial, _Material);

  function PBRMaterial() {
    (0, _classCallCheck2.default)(this, PBRMaterial);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PBRMaterial).apply(this, arguments));
  }

  return PBRMaterial;
}(_material.default);

exports.default = PBRMaterial;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./material":"../../../node_modules/@luma.gl/core/dist/esm/materials/material.js"}],"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/scenegraph-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _math = require("math.gl");

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ScenegraphNode = function () {
  function ScenegraphNode(props) {
    (0, _classCallCheck2.default)(this, ScenegraphNode);
    var id = props.id;
    this.id = id || (0, _utils.uid)(this.constructor.name);
    this.display = true;
    this.position = new _math.Vector3();
    this.rotation = new _math.Vector3();
    this.scale = new _math.Vector3(1, 1, 1);
    this.matrix = new _math.Matrix4();
    this.userData = {};
    this.props = {};

    this._setScenegraphNodeProps(props);
  }

  (0, _createClass2.default)(ScenegraphNode, [{
    key: "delete",
    value: function _delete() {}
  }, {
    key: "setProps",
    value: function setProps(props) {
      this._setScenegraphNodeProps(props);

      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
    }
  }, {
    key: "setPosition",
    value: function setPosition(position) {
      (0, _utils.assert)(position.length === 3, 'setPosition requires vector argument');
      this.position = position;
      return this;
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      (0, _utils.assert)(rotation.length === 3, 'setRotation requires vector argument');
      this.rotation = rotation;
      return this;
    }
  }, {
    key: "setScale",
    value: function setScale(scale) {
      (0, _utils.assert)(scale.length === 3, 'setScale requires vector argument');
      this.scale = scale;
      return this;
    }
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix) {
      var copyMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (copyMatrix) {
        this.matrix.copy(matrix);
      } else {
        this.matrix = matrix;
      }
    }
  }, {
    key: "setMatrixComponents",
    value: function setMatrixComponents(_ref) {
      var position = _ref.position,
          rotation = _ref.rotation,
          scale = _ref.scale,
          _ref$update = _ref.update,
          update = _ref$update === void 0 ? true : _ref$update;

      if (position) {
        this.setPosition(position);
      }

      if (rotation) {
        this.setRotation(rotation);
      }

      if (scale) {
        this.setScale(scale);
      }

      if (update) {
        this.updateMatrix();
      }

      return this;
    }
  }, {
    key: "updateMatrix",
    value: function updateMatrix() {
      var pos = this.position;
      var rot = this.rotation;
      var scale = this.scale;
      this.matrix.identity();
      this.matrix.translate(pos);
      this.matrix.rotateXYZ(rot);
      this.matrix.scale(scale);
      return this;
    }
  }, {
    key: "update",
    value: function update() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          position = _ref2.position,
          rotation = _ref2.rotation,
          scale = _ref2.scale;

      if (position) {
        this.setPosition(position);
      }

      if (rotation) {
        this.setRotation(rotation);
      }

      if (scale) {
        this.setScale(scale);
      }

      this.updateMatrix();
      return this;
    }
  }, {
    key: "getCoordinateUniforms",
    value: function getCoordinateUniforms(viewMatrix, modelMatrix) {
      (0, _utils.assert)(viewMatrix);
      modelMatrix = modelMatrix || this.matrix;
      var worldMatrix = new _math.Matrix4(viewMatrix).multiplyRight(modelMatrix);
      var worldInverse = worldMatrix.invert();
      var worldInverseTranspose = worldInverse.transpose();
      return {
        viewMatrix: viewMatrix,
        modelMatrix: modelMatrix,
        objectMatrix: modelMatrix,
        worldMatrix: worldMatrix,
        worldInverseMatrix: worldInverse,
        worldInverseTransposeMatrix: worldInverseTranspose
      };
    }
  }, {
    key: "transform",
    value: function transform() {
      if (!this.parent) {
        this.endPosition.set(this.position);
        this.endRotation.set(this.rotation);
        this.endScale.set(this.scale);
      } else {
        var parent = this.parent;
        this.endPosition.set(this.position.add(parent.endPosition));
        this.endRotation.set(this.rotation.add(parent.endRotation));
        this.endScale.set(this.scale.add(parent.endScale));
      }

      var ch = this.children;

      for (var i = 0; i < ch.length; ++i) {
        ch[i].transform();
      }

      return this;
    }
  }, {
    key: "_setScenegraphNodeProps",
    value: function _setScenegraphNodeProps(props) {
      if ('display' in props) {
        this.display = props.display;
      }

      if ('position' in props) {
        this.setPosition(props.position);
      }

      if ('rotation' in props) {
        this.setPosition(props.rotation);
      }

      if ('scale' in props) {
        this.setScale(props.scale);
      }

      if ('matrix' in props) {
        this.setMatrix(props.matrix);
      }

      Object.assign(this.props, props);
    }
  }]);
  return ScenegraphNode;
}();

exports.default = ScenegraphNode;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/group-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _math = require("math.gl");

var _utils = require("../../utils");

var _scenegraphNode = _interopRequireDefault(require("./scenegraph-node"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GroupNode = function (_ScenegraphNode) {
  (0, _inherits2.default)(GroupNode, _ScenegraphNode);

  function GroupNode() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, GroupNode);
    props = Array.isArray(props) ? {
      children: props
    } : props;
    var _props = props,
        _props$children = _props.children,
        children = _props$children === void 0 ? [] : _props$children;
    children.every(function (child) {
      return (0, _utils.assert)(child instanceof _scenegraphNode.default);
    });
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(GroupNode).call(this, props));
    _this.children = children;
    return _this;
  }

  (0, _createClass2.default)(GroupNode, [{
    key: "add",
    value: function add() {
      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
        children[_key] = arguments[_key];
      }

      for (var _i = 0, _children = children; _i < _children.length; _i++) {
        var child = _children[_i];

        if (Array.isArray(child)) {
          this.add.apply(this, (0, _toConsumableArray2.default)(child));
        } else {
          this.children.push(child);
        }
      }

      return this;
    }
  }, {
    key: "remove",
    value: function remove(child) {
      var children = this.children;
      var indexOf = children.indexOf(child);

      if (indexOf > -1) {
        children.splice(indexOf, 1);
      }

      return this;
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      this.children = [];
      return this;
    }
  }, {
    key: "delete",
    value: function _delete() {
      this.children.forEach(function (child) {
        return child["delete"]();
      });
      this.removeAll();
      (0, _get2.default)((0, _getPrototypeOf2.default)(GroupNode.prototype), "delete", this).call(this);
    }
  }, {
    key: "traverse",
    value: function traverse(visitor) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$worldMatrix = _ref.worldMatrix,
          worldMatrix = _ref$worldMatrix === void 0 ? new _math.Matrix4() : _ref$worldMatrix;

      var modelMatrix = new _math.Matrix4(worldMatrix).multiplyRight(this.matrix);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;

          if (child instanceof GroupNode) {
            child.traverse(visitor, {
              worldMatrix: modelMatrix
            });
          } else {
            visitor(child, {
              worldMatrix: modelMatrix
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "traverseReverse",
    value: function traverseReverse(visitor, opts) {
      _utils.log.warn('traverseReverse is not reverse')();

      return this.traverse(visitor, opts);
    }
  }]);
  return GroupNode;
}(_scenegraphNode.default);

exports.default = GroupNode;
},{"@babel/runtime/helpers/esm/toConsumableArray":"../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../../utils":"../../../node_modules/@luma.gl/core/dist/esm/utils/index.js","./scenegraph-node":"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/scenegraph-node.js"}],"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/model-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _model = _interopRequireDefault(require("../../lib/model"));

var _scenegraphNode = _interopRequireDefault(require("./scenegraph-node"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ModelNode = function (_ScenegraphNode) {
  (0, _inherits2.default)(ModelNode, _ScenegraphNode);

  function ModelNode(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, ModelNode);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ModelNode).call(this, props));
    _this.onBeforeRender = null;
    _this.AfterRender = null;

    if (gl instanceof _model.default) {
      _this.model = gl;

      _this._setModelNodeProps(props);
    } else {
      _this.model = new _model.default(gl, props);
    }

    _this.managedResources = props.managedResources || [];
    return _this;
  }

  (0, _createClass2.default)(ModelNode, [{
    key: "setProps",
    value: function setProps(props) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(ModelNode.prototype), "setProps", this).call(this, props);

      this._setModelNodeProps(props);

      return this;
    }
  }, {
    key: "delete",
    value: function _delete() {
      if (this.model) {
        this.model["delete"]();
        this.model = null;
      }

      this.managedResources.forEach(function (resource) {
        return resource["delete"]();
      });
      this.managedResources = [];
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this$model;

      return (_this$model = this.model).draw.apply(_this$model, arguments);
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      var _this$model2;

      (_this$model2 = this.model).setUniforms.apply(_this$model2, arguments);

      return this;
    }
  }, {
    key: "setAttributes",
    value: function setAttributes() {
      var _this$model3;

      (_this$model3 = this.model).setAttributes.apply(_this$model3, arguments);

      return this;
    }
  }, {
    key: "updateModuleSettings",
    value: function updateModuleSettings() {
      var _this$model4;

      (_this$model4 = this.model).updateModuleSettings.apply(_this$model4, arguments);

      return this;
    }
  }, {
    key: "_setModelNodeProps",
    value: function _setModelNodeProps(props) {
      this.model.setProps(props);
    }
  }]);
  return ModelNode;
}(_scenegraphNode.default);

exports.default = ModelNode;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../../lib/model":"../../../node_modules/@luma.gl/core/dist/esm/lib/model.js","./scenegraph-node":"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/scenegraph-node.js"}],"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/camera-node.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _scenegraphNode = _interopRequireDefault(require("./scenegraph-node"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CameraNode = function (_ScenegraphNode) {
  (0, _inherits2.default)(CameraNode, _ScenegraphNode);

  function CameraNode() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, CameraNode);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CameraNode).call(this, props));
    _this.projectionMatrix = props.projectionMatrix;
    return _this;
  }

  return CameraNode;
}(_scenegraphNode.default);

exports.default = CameraNode;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./scenegraph-node":"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/scenegraph-node.js"}],"../../../node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../../node_modules/ieee754/index.js":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../../node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../../node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../../node_modules/base64-js/index.js","ieee754":"../../../node_modules/ieee754/index.js","isarray":"../../../node_modules/isarray/index.js","buffer":"../../../node_modules/buffer/index.js"}],"../../../node_modules/@luma.gl/core/dist/esm/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _webgl.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _webgl.isWebGL2;
  }
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function () {
    return _webgl.lumaStats;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _webgl.createGLContext;
  }
});
Object.defineProperty(exports, "destroyGLContext", {
  enumerable: true,
  get: function () {
    return _webgl.destroyGLContext;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function () {
    return _webgl.resizeGLContext;
  }
});
Object.defineProperty(exports, "setGLContextDefaults", {
  enumerable: true,
  get: function () {
    return _webgl.setGLContextDefaults;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _webgl.getContextInfo;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _webgl.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _webgl.getContextLimits;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webgl.FEATURES;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _webgl.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _webgl.hasFeatures;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _webgl.getFeatures;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _webgl.canCompileGLGSExtension;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _webgl.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function () {
    return _webgl.getKeyValue;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function () {
    return _webgl.getKey;
  }
});
Object.defineProperty(exports, "setContextDefaults", {
  enumerable: true,
  get: function () {
    return _webgl.setGLContextDefaults;
  }
});
Object.defineProperty(exports, "glGetDebugInfo", {
  enumerable: true,
  get: function () {
    return _webgl.getContextDebugInfo;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function () {
    return _webgl.Buffer;
  }
});
Object.defineProperty(exports, "Shader", {
  enumerable: true,
  get: function () {
    return _webgl.Shader;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function () {
    return _webgl.VertexShader;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function () {
    return _webgl.FragmentShader;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _webgl.Program;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function () {
    return _webgl.Framebuffer;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function () {
    return _webgl.Renderbuffer;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function () {
    return _webgl.Texture2D;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function () {
    return _webgl.TextureCube;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function () {
    return _webgl.clear;
  }
});
Object.defineProperty(exports, "clearBuffer", {
  enumerable: true,
  get: function () {
    return _webgl.clearBuffer;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function () {
    return _webgl.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function () {
    return _webgl.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "copyToDataUrl", {
  enumerable: true,
  get: function () {
    return _webgl.copyToDataUrl;
  }
});
Object.defineProperty(exports, "copyToImage", {
  enumerable: true,
  get: function () {
    return _webgl.copyToImage;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function () {
    return _webgl.copyToTexture;
  }
});
Object.defineProperty(exports, "blit", {
  enumerable: true,
  get: function () {
    return _webgl.blit;
  }
});
Object.defineProperty(exports, "Query", {
  enumerable: true,
  get: function () {
    return _webgl.Query;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function () {
    return _webgl.Texture3D;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function () {
    return _webgl.TransformFeedback;
  }
});
Object.defineProperty(exports, "VertexArrayObject", {
  enumerable: true,
  get: function () {
    return _webgl.VertexArrayObject;
  }
});
Object.defineProperty(exports, "VertexArray", {
  enumerable: true,
  get: function () {
    return _webgl.VertexArray;
  }
});
Object.defineProperty(exports, "UniformBufferLayout", {
  enumerable: true,
  get: function () {
    return _webgl.UniformBufferLayout;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _webgl.setPathPrefix;
  }
});
Object.defineProperty(exports, "loadFile", {
  enumerable: true,
  get: function () {
    return _webgl.loadFile;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _webgl.loadImage;
  }
});
Object.defineProperty(exports, "_Accessor", {
  enumerable: true,
  get: function () {
    return _webgl.Accessor;
  }
});
Object.defineProperty(exports, "_clearBuffer", {
  enumerable: true,
  get: function () {
    return _webgl.clearBuffer;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _webgl.log;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _webgl.assert;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _webgl.uid;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _webgl.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _webgl.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _webgl.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _webgl.document;
  }
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.trackContextState;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.resetParameters;
  }
});
Object.defineProperty(exports, "getParameter", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getParameter;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getParameters;
  }
});
Object.defineProperty(exports, "setParameter", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.setParameter;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.setParameters;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.withParameters;
  }
});
Object.defineProperty(exports, "getModifiedParameters", {
  enumerable: true,
  get: function () {
    return _webglStateTracker.getModifiedParameters;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _geometry.default;
  }
});
Object.defineProperty(exports, "Material", {
  enumerable: true,
  get: function () {
    return _material.default;
  }
});
Object.defineProperty(exports, "AmbientLight", {
  enumerable: true,
  get: function () {
    return _lightSource.AmbientLight;
  }
});
Object.defineProperty(exports, "DirectionalLight", {
  enumerable: true,
  get: function () {
    return _lightSource.DirectionalLight;
  }
});
Object.defineProperty(exports, "PointLight", {
  enumerable: true,
  get: function () {
    return _lightSource.PointLight;
  }
});
Object.defineProperty(exports, "AnimationLoop", {
  enumerable: true,
  get: function () {
    return _animationLoop.default;
  }
});
Object.defineProperty(exports, "encodePickingColor", {
  enumerable: true,
  get: function () {
    return _pickingColors.encodePickingColor;
  }
});
Object.defineProperty(exports, "decodePickingColor", {
  enumerable: true,
  get: function () {
    return _pickingColors.decodePickingColor;
  }
});
Object.defineProperty(exports, "getNullPickingColor", {
  enumerable: true,
  get: function () {
    return _pickingColors.getNullPickingColor;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function () {
    return _model.default;
  }
});
Object.defineProperty(exports, "Transform", {
  enumerable: true,
  get: function () {
    return _transform2.default;
  }
});
Object.defineProperty(exports, "ClipSpace", {
  enumerable: true,
  get: function () {
    return _clipSpace.default;
  }
});
Object.defineProperty(exports, "_ShaderCache", {
  enumerable: true,
  get: function () {
    return _shaderCache.default;
  }
});
Object.defineProperty(exports, "_AnimationLoopProxy", {
  enumerable: true,
  get: function () {
    return _animationLoopProxy.default;
  }
});
Object.defineProperty(exports, "_MultiPassRenderer", {
  enumerable: true,
  get: function () {
    return _multiPassRenderer.default;
  }
});
Object.defineProperty(exports, "_RenderState", {
  enumerable: true,
  get: function () {
    return _renderState.default;
  }
});
Object.defineProperty(exports, "_Pass", {
  enumerable: true,
  get: function () {
    return _pass.default;
  }
});
Object.defineProperty(exports, "_CompositePass", {
  enumerable: true,
  get: function () {
    return _compositePass.default;
  }
});
Object.defineProperty(exports, "_ClearPass", {
  enumerable: true,
  get: function () {
    return _clearPass.default;
  }
});
Object.defineProperty(exports, "_RenderPass", {
  enumerable: true,
  get: function () {
    return _renderPass.default;
  }
});
Object.defineProperty(exports, "_CopyPass", {
  enumerable: true,
  get: function () {
    return _copyPass.default;
  }
});
Object.defineProperty(exports, "_TexturePass", {
  enumerable: true,
  get: function () {
    return _texturePass.default;
  }
});
Object.defineProperty(exports, "_ShaderModulePass", {
  enumerable: true,
  get: function () {
    return _shaderModulePass.default;
  }
});
Object.defineProperty(exports, "ConeGeometry", {
  enumerable: true,
  get: function () {
    return _coneGeometry.default;
  }
});
Object.defineProperty(exports, "CubeGeometry", {
  enumerable: true,
  get: function () {
    return _cubeGeometry.default;
  }
});
Object.defineProperty(exports, "CylinderGeometry", {
  enumerable: true,
  get: function () {
    return _cylinderGeometry.default;
  }
});
Object.defineProperty(exports, "IcoSphereGeometry", {
  enumerable: true,
  get: function () {
    return _icoSphereGeometry.default;
  }
});
Object.defineProperty(exports, "PlaneGeometry", {
  enumerable: true,
  get: function () {
    return _planeGeometry.default;
  }
});
Object.defineProperty(exports, "SphereGeometry", {
  enumerable: true,
  get: function () {
    return _sphereGeometry.default;
  }
});
Object.defineProperty(exports, "TruncatedConeGeometry", {
  enumerable: true,
  get: function () {
    return _truncatedConeGeometry.default;
  }
});
Object.defineProperty(exports, "PhongMaterial", {
  enumerable: true,
  get: function () {
    return _phongMaterial.default;
  }
});
Object.defineProperty(exports, "PBRMaterial", {
  enumerable: true,
  get: function () {
    return _pbrMaterial.default;
  }
});
Object.defineProperty(exports, "ScenegraphNode", {
  enumerable: true,
  get: function () {
    return _scenegraphNode.default;
  }
});
Object.defineProperty(exports, "GroupNode", {
  enumerable: true,
  get: function () {
    return _groupNode.default;
  }
});
Object.defineProperty(exports, "ModelNode", {
  enumerable: true,
  get: function () {
    return _modelNode.default;
  }
});
Object.defineProperty(exports, "CameraNode", {
  enumerable: true,
  get: function () {
    return _cameraNode.default;
  }
});
Object.defineProperty(exports, "registerShaderModules", {
  enumerable: true,
  get: function () {
    return _shadertools.registerShaderModules;
  }
});
Object.defineProperty(exports, "setDefaultShaderModules", {
  enumerable: true,
  get: function () {
    return _shadertools.setDefaultShaderModules;
  }
});
Object.defineProperty(exports, "assembleShaders", {
  enumerable: true,
  get: function () {
    return _shadertools.assembleShaders;
  }
});
Object.defineProperty(exports, "createShaderHook", {
  enumerable: true,
  get: function () {
    return _shadertools.createShaderHook;
  }
});
Object.defineProperty(exports, "createModuleInjection", {
  enumerable: true,
  get: function () {
    return _shadertools.createModuleInjection;
  }
});
Object.defineProperty(exports, "combineInjects", {
  enumerable: true,
  get: function () {
    return _shadertools.combineInjects;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function () {
    return _shadertools.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _shadertools.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _shadertools.fp64;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _shadertools.project;
  }
});
Object.defineProperty(exports, "lights", {
  enumerable: true,
  get: function () {
    return _shadertools.lights;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function () {
    return _shadertools.dirlight;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _shadertools.picking;
  }
});
Object.defineProperty(exports, "diffuse", {
  enumerable: true,
  get: function () {
    return _shadertools.diffuse;
  }
});
Object.defineProperty(exports, "gouraudlighting", {
  enumerable: true,
  get: function () {
    return _shadertools.gouraudlighting;
  }
});
Object.defineProperty(exports, "phonglighting", {
  enumerable: true,
  get: function () {
    return _shadertools.phonglighting;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function () {
    return _shadertools.pbr;
  }
});
Object.defineProperty(exports, "_transform", {
  enumerable: true,
  get: function () {
    return _shadertools._transform;
  }
});
Object.defineProperty(exports, "MODULAR_SHADERS", {
  enumerable: true,
  get: function () {
    return _shadertools.MODULAR_SHADERS;
  }
});
Object.defineProperty(exports, "getQualifierDetails", {
  enumerable: true,
  get: function () {
    return _shadertools.getQualifierDetails;
  }
});
Object.defineProperty(exports, "getPassthroughFS", {
  enumerable: true,
  get: function () {
    return _shadertools.getPassthroughFS;
  }
});
Object.defineProperty(exports, "typeToChannelSuffix", {
  enumerable: true,
  get: function () {
    return _shadertools.typeToChannelSuffix;
  }
});
Object.defineProperty(exports, "typeToChannelCount", {
  enumerable: true,
  get: function () {
    return _shadertools.typeToChannelCount;
  }
});
Object.defineProperty(exports, "convertToVec4", {
  enumerable: true,
  get: function () {
    return _shadertools.convertToVec4;
  }
});

var _webgl = require("@luma.gl/webgl");

var _webglStateTracker = require("@luma.gl/webgl-state-tracker");

var _geometry = _interopRequireDefault(require("./geometry/geometry"));

var _material = _interopRequireDefault(require("./materials/material"));

var _lightSource = require("./lighting/light-source");

var _animationLoop = _interopRequireDefault(require("./lib/animation-loop"));

var _pickingColors = require("./lib/picking-colors");

var _model = _interopRequireDefault(require("./lib/model"));

var _transform2 = _interopRequireDefault(require("./lib/transform"));

var _clipSpace = _interopRequireDefault(require("./lib/clip-space"));

var _shaderCache = _interopRequireDefault(require("./lib/shader-cache"));

var _animationLoopProxy = _interopRequireDefault(require("./lib/animation-loop-proxy"));

var _multiPassRenderer = _interopRequireDefault(require("./multipass/multi-pass-renderer"));

var _renderState = _interopRequireDefault(require("./multipass/render-state"));

var _pass = _interopRequireDefault(require("./multipass/pass"));

var _compositePass = _interopRequireDefault(require("./multipass/composite-pass"));

var _clearPass = _interopRequireDefault(require("./multipass/clear-pass"));

var _renderPass = _interopRequireDefault(require("./multipass/render-pass"));

var _copyPass = _interopRequireDefault(require("./multipass/copy-pass"));

var _texturePass = _interopRequireDefault(require("./multipass/texture-pass"));

var _shaderModulePass = _interopRequireDefault(require("./multipass/shader-module-pass"));

var _coneGeometry = _interopRequireDefault(require("./geometries/cone-geometry"));

var _cubeGeometry = _interopRequireDefault(require("./geometries/cube-geometry"));

var _cylinderGeometry = _interopRequireDefault(require("./geometries/cylinder-geometry"));

var _icoSphereGeometry = _interopRequireDefault(require("./geometries/ico-sphere-geometry"));

var _planeGeometry = _interopRequireDefault(require("./geometries/plane-geometry"));

var _sphereGeometry = _interopRequireDefault(require("./geometries/sphere-geometry"));

var _truncatedConeGeometry = _interopRequireDefault(require("./geometries/truncated-cone-geometry"));

var _phongMaterial = _interopRequireDefault(require("./materials/phong-material"));

var _pbrMaterial = _interopRequireDefault(require("./materials/pbr-material"));

var _scenegraphNode = _interopRequireDefault(require("./scenegraph/nodes/scenegraph-node"));

var _groupNode = _interopRequireDefault(require("./scenegraph/nodes/group-node"));

var _modelNode = _interopRequireDefault(require("./scenegraph/nodes/model-node"));

var _cameraNode = _interopRequireDefault(require("./scenegraph/nodes/camera-node"));

var _shadertools = require("@luma.gl/shadertools");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"@luma.gl/webgl":"../../../node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/webgl-state-tracker":"../../../node_modules/@luma.gl/webgl-state-tracker/dist/esm/index.js","./geometry/geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometry/geometry.js","./materials/material":"../../../node_modules/@luma.gl/core/dist/esm/materials/material.js","./lighting/light-source":"../../../node_modules/@luma.gl/core/dist/esm/lighting/light-source.js","./lib/animation-loop":"../../../node_modules/@luma.gl/core/dist/esm/lib/animation-loop.js","./lib/picking-colors":"../../../node_modules/@luma.gl/core/dist/esm/lib/picking-colors.js","./lib/model":"../../../node_modules/@luma.gl/core/dist/esm/lib/model.js","./lib/transform":"../../../node_modules/@luma.gl/core/dist/esm/lib/transform.js","./lib/clip-space":"../../../node_modules/@luma.gl/core/dist/esm/lib/clip-space.js","./lib/shader-cache":"../../../node_modules/@luma.gl/core/dist/esm/lib/shader-cache.js","./lib/animation-loop-proxy":"../../../node_modules/@luma.gl/core/dist/esm/lib/animation-loop-proxy.js","./multipass/multi-pass-renderer":"../../../node_modules/@luma.gl/core/dist/esm/multipass/multi-pass-renderer.js","./multipass/render-state":"../../../node_modules/@luma.gl/core/dist/esm/multipass/render-state.js","./multipass/pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/pass.js","./multipass/composite-pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/composite-pass.js","./multipass/clear-pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/clear-pass.js","./multipass/render-pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/render-pass.js","./multipass/copy-pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/copy-pass.js","./multipass/texture-pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/texture-pass.js","./multipass/shader-module-pass":"../../../node_modules/@luma.gl/core/dist/esm/multipass/shader-module-pass.js","./geometries/cone-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/cone-geometry.js","./geometries/cube-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/cube-geometry.js","./geometries/cylinder-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/cylinder-geometry.js","./geometries/ico-sphere-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/ico-sphere-geometry.js","./geometries/plane-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/plane-geometry.js","./geometries/sphere-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/sphere-geometry.js","./geometries/truncated-cone-geometry":"../../../node_modules/@luma.gl/core/dist/esm/geometries/truncated-cone-geometry.js","./materials/phong-material":"../../../node_modules/@luma.gl/core/dist/esm/materials/phong-material.js","./materials/pbr-material":"../../../node_modules/@luma.gl/core/dist/esm/materials/pbr-material.js","./scenegraph/nodes/scenegraph-node":"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/scenegraph-node.js","./scenegraph/nodes/group-node":"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/group-node.js","./scenegraph/nodes/model-node":"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/model-node.js","./scenegraph/nodes/camera-node":"../../../node_modules/@luma.gl/core/dist/esm/scenegraph/nodes/camera-node.js","@luma.gl/shadertools":"../../../node_modules/@luma.gl/shadertools/dist/esm/index.js","buffer":"../../../node_modules/buffer/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROJECT_COORDINATE_SYSTEM = void 0;
var PROJECT_COORDINATE_SYSTEM = {
  LNG_LAT: 1.0,
  LNGLAT_AUTO_OFFSET: 4.0,
  METER_OFFSETS: 2.0,
  LNGLAT_OFFSETS: 3.0,
  IDENTITY: 0.0
};
exports.PROJECT_COORDINATE_SYSTEM = PROJECT_COORDINATE_SYSTEM;
},{}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("./constants");

var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(_constants.PROJECT_COORDINATE_SYSTEM).map(function (key) {
  return "const float COORDINATE_SYSTEM_".concat(key, " = ").concat(_constants.PROJECT_COORDINATE_SYSTEM[key], ".;");
}).join('');

var _default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n\nuniform float project_uCoordinateSystem;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform float project_uAntimeridian;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec2 ZERO_64_XY_LOW = vec2(0.0, 0.0);\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z;\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy;\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter;\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  return normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\n    dy = clamp(dy, -1., 1.);\n  }\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x - project_uAntimeridian, 360.0) + project_uAntimeridian;\n  }\n  return vec2(\n    radians(x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\nvec4 project_position(vec4 position, vec2 position64xyLow) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNG_LAT) {\n    return project_uModelMatrix * vec4(\n      project_mercator_(position.xy) * WORLD_SCALE * project_uScale,\n      project_size(position.z),\n      position.w\n    );\n  }\n\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\n    float X = position.x - project_uCoordinateOrigin.x;\n    float Y = position.y - project_uCoordinateOrigin.y;\n    return project_offset_(vec4(X + position64xyLow.x, Y + position64xyLow.y, position.z, position.w));\n  }\n\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return project_offset_(position);\n  }\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_IDENTITY) {\n    position_world.xyz -= project_uCoordinateOrigin;\n    position_world += project_uModelMatrix * vec4(position64xyLow, 0.0, 0.0);\n  }\n\n  return project_offset_(position_world);\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_XY_LOW);\n}\n\nvec3 project_position(vec3 position, vec2 position64xyLow) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64xyLow);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_XY_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_XY_LOW);\n  return projected_position.xy;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_METER_OFFSETS ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    position.w *= project_uCommonUnitsPerMeter.z;\n  }\n  return project_uViewProjectionMatrix * position + project_uCenter;\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters);\n}\nfloat project_pixel_size(float pixels) {\n  return pixels;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels;\n}\nfloat project_scale(float meters) {\n  return project_size(meters);\n}\nvec2 project_scale(vec2 meters) {\n  return project_size(meters);\n}\nvec3 project_scale(vec3 meters) {\n  return project_size(meters);\n}\nvec4 project_scale(vec4 meters) {\n  return project_size(meters);\n}\nvec4 project_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position);\n}\nvec4 project_pixel_to_clipspace(vec2 pixels) {\n  return vec4(project_pixel_size_to_clipspace(pixels), 0.0, 0.0);\n}\n");

exports.default = _default;
},{"./constants":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/constants.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EVENTS = exports.COORDINATE_SYSTEM = void 0;
var COORDINATE_SYSTEM = {
  LNGLAT: 1,
  LNGLAT_DEPRECATED: 5,
  METER_OFFSETS: 2,
  METERS: 2,
  LNGLAT_OFFSETS: 3,
  IDENTITY: 0
};
exports.COORDINATE_SYSTEM = COORDINATE_SYSTEM;
var EVENTS = {
  click: {
    handler: 'onClick'
  },
  panstart: {
    handler: 'onDragStart'
  },
  panmove: {
    handler: 'onDrag'
  },
  panend: {
    handler: 'onDragEnd'
  }
};
exports.EVENTS = EVENTS;
},{}],"../../../node_modules/@deck.gl/core/dist/esm/utils/memoize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = memoize;

function isEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (Array.isArray(a)) {
    var len = a.length;

    if (!b || b.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
}

function memoize(compute) {
  var cachedArgs = {};
  var cachedResult;
  return function (args) {
    for (var key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }

    return cachedResult;
  };
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'deck.gl: assertion failed.');
  }
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUniformsFromViewport = getUniformsFromViewport;
exports.LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD = void 0;

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

var _constants = require("../../lib/constants");

var _memoize = _interopRequireDefault(require("../../utils/memoize"));

var _assert = _interopRequireDefault(require("../../utils/assert"));

var _constants2 = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var ZERO_VECTOR = [0, 0, 0, 0];
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
var LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD = 12;
exports.LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD = LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD;
var getMemoizedViewportUniforms = (0, _memoize.default)(calculateViewportUniforms);

function getShaderCoordinateSystem(coordinateSystem) {
  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT:
    case _constants.COORDINATE_SYSTEM.LNGLAT_EXPERIMENTAL:
    default:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET;

    case _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT;

    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
    case _constants.COORDINATE_SYSTEM.METERS:
      return _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS;

    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS;

    case _constants.COORDINATE_SYSTEM.IDENTITY:
      return _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY;
  }
}

function calculateMatrixAndOffset(_ref) {
  var viewport = _ref.viewport,
      coordinateSystem = _ref.coordinateSystem,
      coordinateOrigin = _ref.coordinateOrigin,
      coordinateZoom = _ref.coordinateZoom;
  var viewMatrixUncentered = viewport.viewMatrixUncentered;
  var viewMatrix = viewport.viewMatrix;
  var projectionMatrix = viewport.projectionMatrix;
  var viewProjectionMatrix = viewport.viewProjectionMatrix;
  var projectionCenter;
  var cameraPosCommon = viewport.cameraPosition;
  var shaderCoordinateSystem = getShaderCoordinateSystem(coordinateSystem);
  var shaderCoordinateOrigin = coordinateOrigin;

  if (shaderCoordinateSystem === _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET) {
    if (coordinateZoom < LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD) {
      shaderCoordinateSystem = _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT;
    } else {
      var lng = Math.fround(viewport.longitude);
      var lat = Math.fround(viewport.latitude);
      shaderCoordinateOrigin = [lng, lat];
    }
  }

  if (shaderCoordinateSystem === _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY) {
    shaderCoordinateOrigin = [Math.fround(viewport.position[0]), Math.fround(viewport.position[1])];
  }

  shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;

  switch (shaderCoordinateSystem) {
    case _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT:
      projectionCenter = ZERO_VECTOR;
      break;

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:
    case _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:
    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:
    case _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY:
      var positionCommonSpace = viewport.projectPosition(shaderCoordinateOrigin, Math.pow(2, coordinateZoom));
      cameraPosCommon = [cameraPosCommon[0] - positionCommonSpace[0], cameraPosCommon[1] - positionCommonSpace[1], cameraPosCommon[2] - positionCommonSpace[2]];
      positionCommonSpace[3] = 1;
      projectionCenter = vec4.transformMat4([], positionCommonSpace, viewProjectionMatrix);
      viewMatrix = viewMatrixUncentered || viewMatrix;
      viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  return {
    viewMatrix: viewMatrix,
    viewProjectionMatrix: viewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPosCommon: cameraPosCommon,
    shaderCoordinateSystem: shaderCoordinateSystem,
    shaderCoordinateOrigin: shaderCoordinateOrigin
  };
}

function getUniformsFromViewport() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      viewport = _ref2.viewport,
      _ref2$devicePixelRati = _ref2.devicePixelRatio,
      devicePixelRatio = _ref2$devicePixelRati === void 0 ? 1 : _ref2$devicePixelRati,
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === void 0 ? null : _ref2$modelMatrix,
      _ref2$coordinateSyste = _ref2.coordinateSystem,
      coordinateSystem = _ref2$coordinateSyste === void 0 ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref2$coordinateSyste,
      _ref2$coordinateOrigi = _ref2.coordinateOrigin,
      coordinateOrigin = _ref2$coordinateOrigi === void 0 ? DEFAULT_COORDINATE_ORIGIN : _ref2$coordinateOrigi,
      _ref2$wrapLongitude = _ref2.wrapLongitude,
      wrapLongitude = _ref2$wrapLongitude === void 0 ? false : _ref2$wrapLongitude,
      projectionMode = _ref2.projectionMode,
      positionOrigin = _ref2.positionOrigin;

  (0, _assert.default)(viewport);
  return Object.assign({
    project_uModelMatrix: modelMatrix || IDENTITY_MATRIX
  }, getMemoizedViewportUniforms({
    viewport: viewport,
    devicePixelRatio: devicePixelRatio,
    coordinateSystem: coordinateSystem,
    coordinateOrigin: coordinateOrigin,
    wrapLongitude: wrapLongitude
  }));
}

function calculateViewportUniforms(_ref3) {
  var viewport = _ref3.viewport,
      devicePixelRatio = _ref3.devicePixelRatio,
      coordinateSystem = _ref3.coordinateSystem,
      coordinateOrigin = _ref3.coordinateOrigin,
      wrapLongitude = _ref3.wrapLongitude;
  var coordinateZoom = viewport.zoom;

  var _calculateMatrixAndOf = calculateMatrixAndOffset({
    coordinateSystem: coordinateSystem,
    coordinateOrigin: coordinateOrigin,
    coordinateZoom: coordinateZoom,
    viewport: viewport
  }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
      cameraPosCommon = _calculateMatrixAndOf.cameraPosCommon,
      shaderCoordinateSystem = _calculateMatrixAndOf.shaderCoordinateSystem,
      shaderCoordinateOrigin = _calculateMatrixAndOf.shaderCoordinateOrigin;

  (0, _assert.default)(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');
  var distanceScales = viewport.getDistanceScales();
  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  var uniforms = {
    project_uCoordinateSystem: shaderCoordinateSystem,
    project_uCenter: projectionCenter,
    project_uWrapLongitude: wrapLongitude,
    project_uAntimeridian: (viewport.longitude || 0) - 180,
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: viewport.focalDistance || 1,
    project_uCommonUnitsPerMeter: distanceScales.pixelsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.pixelsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uCameraPosition: cameraPosCommon
  };
  var distanceScalesAtOrigin = viewport.getDistanceScales(shaderCoordinateOrigin);

  switch (shaderCoordinateSystem) {
    case _constants2.PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:
      uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.pixelsPerMeter;
      uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.pixelsPerMeter2;
      break;

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:
      uniforms.project_uCoordinateOrigin = shaderCoordinateOrigin;

    case _constants2.PROJECT_COORDINATE_SYSTEM.LNG_LAT:
    case _constants2.PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.pixelsPerDegree;
      uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.pixelsPerDegree2;
      break;

    case _constants2.PROJECT_COORDINATE_SYSTEM.IDENTITY:
      uniforms.project_uCoordinateOrigin = shaderCoordinateOrigin;
      break;

    default:
      break;
  }

  return uniforms;
}
},{"gl-matrix/mat4":"../../../node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec4":"../../../node_modules/gl-matrix/esm/vec4.js","../../lib/constants":"../../../node_modules/@deck.gl/core/dist/esm/lib/constants.js","../../utils/memoize":"../../../node_modules/@deck.gl/core/dist/esm/utils/memoize.js","../../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js","./constants":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/constants.js"}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _project = _interopRequireDefault(require("./project.glsl"));

var _viewportUniforms = require("./viewport-uniforms");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INITIAL_MODULE_OPTIONS = {};

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

  if (opts.viewport) {
    return (0, _viewportUniforms.getUniformsFromViewport)(opts);
  }

  return {};
}

var _default = {
  name: 'project',
  dependencies: [_core.fp32],
  vs: _project.default,
  getUniforms: getUniforms,
  deprecations: [{
    type: 'function',
    old: 'project_scale',
    new: 'project_size'
  }, {
    type: 'function',
    old: 'project_to_clipspace',
    new: 'project_common_position_to_clipspace'
  }, {
    type: 'function',
    old: 'project_pixel_to_clipspace',
    new: 'project_pixel_size_to_clipspace'
  }]
};
exports.default = _default;
},{"@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./project.glsl":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js","./viewport-uniforms":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _project = _interopRequireDefault(require("../project/project"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64xyLow);\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64xyLow, offset, commonPosition);\n}\n";
var _default = {
  name: 'project32',
  dependencies: [_project.default],
  vs: vs
};
exports.default = _default;
},{"../project/project":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project64/project64.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project64_uScale;\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sub_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  vec2 x_fp64 = mul_fp64(pos_fp64[0], project64_uScale);\n  vec2 y_fp64 = mul_fp64(pos_fp64[1], project64_uScale);\n  out_val[0] = mul_fp64(x_fp64, WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(y_fp64, WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\nvec4 project_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  return project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project64/project64.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _project = _interopRequireDefault(require("../project/project"));

var _memoize = _interopRequireDefault(require("../../utils/memoize"));

var _project2 = _interopRequireDefault(require("./project64.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fp64ify = _core.fp64.fp64ify,
    fp64ifyMatrix4 = _core.fp64.fp64ifyMatrix4;
var _default = {
  name: 'project64',
  dependencies: [_project.default, _core.fp64],
  vs: _project2.default,
  getUniforms: getUniforms,
  deprecations: [{
    type: 'function',
    old: 'project_to_clipspace_fp64',
    new: 'project_common_position_to_clipspace_fp64'
  }]
};
exports.default = _default;
var DEFAULT_MODULE_OPTIONS = {};
var getMemoizedUniforms = (0, _memoize.default)(calculateUniforms);

function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var project_uViewProjectionMatrix = context.project_uViewProjectionMatrix,
      project_uScale = context.project_uScale;

  if (project_uViewProjectionMatrix && project_uScale) {
    return getMemoizedUniforms({
      project_uViewProjectionMatrix: project_uViewProjectionMatrix,
      project_uScale: project_uScale
    });
  }

  return {};
}

function calculateUniforms(_ref) {
  var project_uViewProjectionMatrix = _ref.project_uViewProjectionMatrix,
      project_uScale = _ref.project_uScale;
  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(project_uViewProjectionMatrix);
  var scaleFP64 = fp64ify(project_uScale);
  return {
    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64
  };
}
},{"@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","../project/project":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","../../utils/memoize":"../../../node_modules/@deck.gl/core/dist/esm/utils/memoize.js","./project64.glsl":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project64/project64.glsl.js"}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initializeShaderModules = initializeShaderModules;
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _core.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _core.fp64;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _core.picking;
  }
});
Object.defineProperty(exports, "gouraudlighting", {
  enumerable: true,
  get: function () {
    return _core.gouraudlighting;
  }
});
Object.defineProperty(exports, "phonglighting", {
  enumerable: true,
  get: function () {
    return _core.phonglighting;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.default;
  }
});
Object.defineProperty(exports, "project64", {
  enumerable: true,
  get: function () {
    return _project3.default;
  }
});

var _core = require("@luma.gl/core");

var _project = _interopRequireDefault(require("../shaderlib/project/project"));

var _project2 = _interopRequireDefault(require("../shaderlib/project32/project32"));

var _project3 = _interopRequireDefault(require("../shaderlib/project64/project64"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function initializeShaderModules() {
  (0, _core.registerShaderModules)([_core.fp32, _core.fp64, _project.default, _project2.default, _project3.default, _core.gouraudlighting, _core.phonglighting, _core.picking]);
  (0, _core.setDefaultShaderModules)([_project.default]);
}
},{"@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","../shaderlib/project/project":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","../shaderlib/project32/project32":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js","../shaderlib/project64/project64":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project64/project64.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/init.js":[function(require,module,exports) {

"use strict";

var _globals = require("../utils/globals");

var _log = _interopRequireDefault(require("../utils/log"));

var _shaderlib = require("../shaderlib");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var version = typeof "7.1.9" !== 'undefined' ? "7.1.9" : _globals.global.DECK_VERSION || 'untranspiled source';
var STARTUP_MESSAGE = 'set deck.log.priority=1 (or higher) to trace attribute updates';

if (_globals.global.deck && _globals.global.deck.VERSION !== version) {
  throw new Error("deck.gl - multiple versions detected: ".concat(_globals.global.deck.VERSION, " vs ").concat(version));
}

if (!_globals.global.deck) {
  _log.default.log(0, "deck.gl ".concat(version, " - ").concat(STARTUP_MESSAGE))();

  _globals.global.deck = _globals.global.deck || {
    VERSION: version,
    version: version,
    log: _log.default
  };
  (0, _shaderlib.initializeShaderModules)();
}
},{"../utils/globals":"../../../node_modules/@deck.gl/core/dist/esm/utils/globals.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../shaderlib":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DirectionalLight = function (_BaseDirectionalLight) {
  (0, _inherits2.default)(DirectionalLight, _BaseDirectionalLight);

  function DirectionalLight() {
    (0, _classCallCheck2.default)(this, DirectionalLight);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(DirectionalLight).apply(this, arguments));
  }

  (0, _createClass2.default)(DirectionalLight, [{
    key: "getProjectedLight",
    value: function getProjectedLight() {
      return this;
    }
  }]);
  return DirectionalLight;
}(_core.DirectionalLight);

exports.default = DirectionalLight;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Effect = function () {
  function Effect() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Effect);
    var _props$id = props.id,
        id = _props$id === void 0 ? 'effect' : _props$id;
    this.id = id;
    this.props = {};
    Object.assign(this.props, props);
  }

  (0, _createClass2.default)(Effect, [{
    key: "prepare",
    value: function prepare() {}
  }, {
    key: "getParameters",
    value: function getParameters() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
  }]);
  return Effect;
}();

exports.default = Effect;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js"}],"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@luma.gl/core");

var _directionalLight = _interopRequireDefault(require("./directional-light"));

var _effect = _interopRequireDefault(require("../../lib/effect"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DefaultAmbientLightProps = {
  color: [255, 255, 255],
  intensity: 1.0
};
var DefaultDirectionalLightProps = [{
  color: [255, 255, 255],
  intensity: 1.0,
  direction: [-1, -3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, 8, -2.5]
}];

var LightingEffect = function (_Effect) {
  (0, _inherits2.default)(LightingEffect, _Effect);

  function LightingEffect(props) {
    var _this;

    (0, _classCallCheck2.default)(this, LightingEffect);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LightingEffect).call(this, props));
    _this.ambientLight = null;
    _this.directionalLights = [];
    _this.pointLights = [];

    for (var key in props) {
      var lightSource = props[key];

      switch (lightSource.type) {
        case 'ambient':
          _this.ambientLight = lightSource;
          break;

        case 'directional':
          _this.directionalLights.push(lightSource);

          break;

        case 'point':
          _this.pointLights.push(lightSource);

          break;

        default:
      }
    }

    _this.applyDefaultLights();

    return _this;
  }

  (0, _createClass2.default)(LightingEffect, [{
    key: "getParameters",
    value: function getParameters(layer) {
      var ambientLight = this.ambientLight;
      var pointLights = this.getProjectedPointLights(layer);
      var directionalLights = this.getProjectedDirectionalLights(layer);
      return {
        lightSources: {
          ambientLight: ambientLight,
          directionalLights: directionalLights,
          pointLights: pointLights
        }
      };
    }
  }, {
    key: "applyDefaultLights",
    value: function applyDefaultLights() {
      var ambientLight = this.ambientLight,
          pointLights = this.pointLights,
          directionalLights = this.directionalLights;

      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
        this.ambientLight = new _core.AmbientLight(DefaultAmbientLightProps);
        this.directionalLights.push(new _directionalLight.default(DefaultDirectionalLightProps[0]));
        this.directionalLights.push(new _directionalLight.default(DefaultDirectionalLightProps[1]));
      }
    }
  }, {
    key: "getProjectedPointLights",
    value: function getProjectedPointLights(layer) {
      var projectedPointLights = [];

      for (var i = 0; i < this.pointLights.length; i++) {
        var pointLight = this.pointLights[i];
        projectedPointLights.push(pointLight.getProjectedLight({
          layer: layer
        }));
      }

      return projectedPointLights;
    }
  }, {
    key: "getProjectedDirectionalLights",
    value: function getProjectedDirectionalLights(layer) {
      var projectedDirectionalLights = [];

      for (var i = 0; i < this.directionalLights.length; i++) {
        var directionalLight = this.directionalLights[i];
        projectedDirectionalLights.push(directionalLight.getProjectedLight({
          layer: layer
        }));
      }

      return projectedDirectionalLights;
    }
  }]);
  return LightingEffect;
}(_effect.default);

exports.default = LightingEffect;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./directional-light":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","../../lib/effect":"../../../node_modules/@deck.gl/core/dist/esm/lib/effect.js"}],"../../../node_modules/viewport-mercator-project/dist/esm/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMat4 = createMat4;
exports.transformVector = transformVector;
exports.mod = mod;
exports.lerp = lerp;

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

function transformVector(matrix, vector) {
  var result = vec4.transformMat4([], vector, matrix);
  vec4.scale(result, result, 1 / result[3]);
  return result;
}

function mod(value, divisor) {
  var modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}

function lerp(start, end, step) {
  return step * end + (1 - step) * start;
}
},{"gl-matrix/vec4":"../../../node_modules/gl-matrix/esm/vec4.js"}],"../../../node_modules/viewport-mercator-project/dist/esm/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'viewport-mercator-project: assertion failed.');
  }
}
},{}],"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoomToScale = zoomToScale;
exports.scaleToZoom = scaleToZoom;
exports.lngLatToWorld = lngLatToWorld;
exports.worldToLngLat = worldToLngLat;
exports.getMeterZoom = getMeterZoom;
exports.getDistanceScales = getDistanceScales;
exports.addMetersToLngLat = addMetersToLngLat;
exports.getViewMatrix = getViewMatrix;
exports.getProjectionParameters = getProjectionParameters;
exports.getProjectionMatrix = getProjectionMatrix;
exports.worldToPixels = worldToPixels;
exports.pixelsToWorld = pixelsToWorld;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _mathUtils = require("./math-utils");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var EARTH_CIRCUMFERENCE = 40.03e6;
var DEFAULT_ALTITUDE = 1.5;

function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}

function scaleToZoom(scale) {
  return Math.log2(scale);
}

function lngLatToWorld(_ref, scale) {
  var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  (0, _assert.default)(Number.isFinite(lng) && Number.isFinite(scale));
  (0, _assert.default)(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');
  scale *= TILE_SIZE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

function worldToLngLat(_ref3, scale) {
  var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale *= TILE_SIZE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

function getMeterZoom(_ref5) {
  var latitude = _ref5.latitude;
  (0, _assert.default)(Number.isFinite(latitude));
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}

function getDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      zoom = _ref6.zoom,
      scale = _ref6.scale,
      _ref6$highPrecision = _ref6.highPrecision,
      highPrecision = _ref6$highPrecision === void 0 ? false : _ref6$highPrecision;
  scale = scale !== undefined ? scale : zoomToScale(zoom);
  (0, _assert.default)(Number.isFinite(latitude) && Number.isFinite(longitude) && Number.isFinite(scale));
  var result = {};
  var worldSize = TILE_SIZE * scale;
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  result.pixelsPerMeter = [altPixelsPerMeter, -altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, -1 / altPixelsPerMeter, 1 / altPixelsPerMeter];
  result.pixelsPerDegree = [pixelsPerDegreeX, -pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, -1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;
    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
  }

  return result;
}

function addMetersToLngLat(lngLatZ, xyz) {
  var _lngLatZ = (0, _slicedToArray2.default)(lngLatZ, 3),
      longitude = _lngLatZ[0],
      latitude = _lngLatZ[1],
      z0 = _lngLatZ[2];

  var _xyz = (0, _slicedToArray2.default)(xyz, 3),
      x = _xyz[0],
      y = _xyz[1],
      z = _xyz[2];

  var scale = 1;

  var _getDistanceScales = getDistanceScales({
    longitude: longitude,
    latitude: latitude,
    scale: scale,
    highPrecision: true
  }),
      pixelsPerMeter = _getDistanceScales.pixelsPerMeter,
      pixelsPerMeter2 = _getDistanceScales.pixelsPerMeter2;

  var worldspace = lngLatToWorld(lngLatZ, scale);
  worldspace[0] += x * (pixelsPerMeter[0] + pixelsPerMeter2[0] * y);
  worldspace[1] += y * (pixelsPerMeter[1] + pixelsPerMeter2[1] * y);
  var newLngLat = worldToLngLat(worldspace, scale);
  var newZ = (z0 || 0) + (z || 0);
  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}

function getViewMatrix(_ref7) {
  var height = _ref7.height,
      pitch = _ref7.pitch,
      bearing = _ref7.bearing,
      altitude = _ref7.altitude,
      _ref7$center = _ref7.center,
      center = _ref7$center === void 0 ? null : _ref7$center,
      _ref7$flipY = _ref7.flipY,
      flipY = _ref7$flipY === void 0 ? false : _ref7$flipY;
  var vm = (0, _mathUtils.createMat4)();
  mat4.translate(vm, vm, [0, 0, -altitude]);
  mat4.scale(vm, vm, [1, 1, 1 / height]);
  mat4.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  mat4.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);

  if (flipY) {
    mat4.scale(vm, vm, [1, -1, 1]);
  }

  if (center) {
    mat4.translate(vm, vm, vec3.negate([], center));
  }

  return vm;
}

function getProjectionParameters(_ref8) {
  var width = _ref8.width,
      height = _ref8.height,
      _ref8$altitude = _ref8.altitude,
      altitude = _ref8$altitude === void 0 ? DEFAULT_ALTITUDE : _ref8$altitude,
      _ref8$pitch = _ref8.pitch,
      pitch = _ref8$pitch === void 0 ? 0 : _ref8$pitch,
      _ref8$nearZMultiplier = _ref8.nearZMultiplier,
      nearZMultiplier = _ref8$nearZMultiplier === void 0 ? 1 : _ref8$nearZMultiplier,
      _ref8$farZMultiplier = _ref8.farZMultiplier,
      farZMultiplier = _ref8$farZMultiplier === void 0 ? 1 : _ref8$farZMultiplier;
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;
  return {
    fov: 2 * Math.atan(height / 2 / altitude),
    aspect: width / height,
    focalDistance: altitude,
    near: nearZMultiplier,
    far: farZ * farZMultiplier
  };
}

function getProjectionMatrix(_ref9) {
  var width = _ref9.width,
      height = _ref9.height,
      pitch = _ref9.pitch,
      altitude = _ref9.altitude,
      nearZMultiplier = _ref9.nearZMultiplier,
      farZMultiplier = _ref9.farZMultiplier;

  var _getProjectionParamet = getProjectionParameters({
    width: width,
    height: height,
    altitude: altitude,
    pitch: pitch,
    nearZMultiplier: nearZMultiplier,
    farZMultiplier: farZMultiplier
  }),
      fov = _getProjectionParamet.fov,
      aspect = _getProjectionParamet.aspect,
      near = _getProjectionParamet.near,
      far = _getProjectionParamet.far;

  var projectionMatrix = mat4.perspective([], fov, aspect, near, far);
  return projectionMatrix;
}

function worldToPixels(xyz, pixelProjectionMatrix) {
  var _xyz2 = (0, _slicedToArray2.default)(xyz, 3),
      x = _xyz2[0],
      y = _xyz2[1],
      _xyz2$ = _xyz2[2],
      z = _xyz2$ === void 0 ? 0 : _xyz2$;

  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
  return (0, _mathUtils.transformVector)(pixelProjectionMatrix, [x, y, z, 1]);
}

function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var _xyz3 = (0, _slicedToArray2.default)(xyz, 3),
      x = _xyz3[0],
      y = _xyz3[1],
      z = _xyz3[2];

  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');

  if (Number.isFinite(z)) {
    var coord = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }

  var coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 0, 1]);
  var coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 1, 1]);
  var z0 = coord0[2];
  var z1 = coord1[2];
  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2.lerp([], coord0, coord1, t);
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","./math-utils":"../../../node_modules/viewport-mercator-project/dist/esm/math-utils.js","gl-matrix/mat4":"../../../node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"../../../node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"../../../node_modules/gl-matrix/esm/vec3.js","./assert":"../../../node_modules/viewport-mercator-project/dist/esm/assert.js"}],"../../../node_modules/viewport-mercator-project/dist/esm/viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _mathUtils = require("./math-utils");

var _webMercatorUtils = require("./web-mercator-utils");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var IDENTITY = (0, _mathUtils.createMat4)();

var Viewport = function () {
  function Viewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$viewMatrix = _ref.viewMatrix,
        viewMatrix = _ref$viewMatrix === void 0 ? IDENTITY : _ref$viewMatrix,
        _ref$projectionMatrix = _ref.projectionMatrix,
        projectionMatrix = _ref$projectionMatrix === void 0 ? IDENTITY : _ref$projectionMatrix;

    (0, _classCallCheck2.default)(this, Viewport);
    this.width = width || 1;
    this.height = height || 1;
    this.scale = 1;
    this.pixelsPerMeter = 1;
    this.viewMatrix = viewMatrix;
    this.projectionMatrix = projectionMatrix;
    var vpm = (0, _mathUtils.createMat4)();
    mat4.multiply(vpm, vpm, this.projectionMatrix);
    mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    var m = (0, _mathUtils.createMat4)();
    mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
    mat4.translate(m, m, [1, -1, 0]);
    mat4.multiply(m, m, this.viewProjectionMatrix);
    var mInverse = mat4.invert((0, _mathUtils.createMat4)(), m);

    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }

  (0, _createClass2.default)(Viewport, [{
    key: "equals",
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);
    }
  }, {
    key: "project",
    value: function project(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;

      var worldPosition = this.projectPosition(xyz);
      var coord = (0, _webMercatorUtils.worldToPixels)(worldPosition, this.pixelProjectionMatrix);

      var _coord = (0, _slicedToArray2.default)(coord, 2),
          x = _coord[0],
          y = _coord[1];

      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
    }
  }, {
    key: "unproject",
    value: function unproject(xyz) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$topLeft = _ref3.topLeft,
          topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft,
          targetZ = _ref3.targetZ;

      var _xyz = (0, _slicedToArray2.default)(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          z = _xyz[2];

      var y2 = topLeft ? y : this.height - y;
      var targetZWorld = targetZ && targetZ * this.pixelsPerMeter;
      var coord = (0, _webMercatorUtils.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);

      var _this$unprojectPositi = this.unprojectPosition(coord),
          _this$unprojectPositi2 = (0, _slicedToArray2.default)(_this$unprojectPositi, 3),
          X = _this$unprojectPositi2[0],
          Y = _this$unprojectPositi2[1],
          Z = _this$unprojectPositi2[2];

      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }

      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
  }, {
    key: "projectPosition",
    value: function projectPosition(xyz) {
      var _this$projectFlat = this.projectFlat(xyz),
          _this$projectFlat2 = (0, _slicedToArray2.default)(_this$projectFlat, 2),
          X = _this$projectFlat2[0],
          Y = _this$projectFlat2[1];

      var Z = (xyz[2] || 0) * this.pixelsPerMeter;
      return [X, Y, Z];
    }
  }, {
    key: "unprojectPosition",
    value: function unprojectPosition(xyz) {
      var _this$unprojectFlat = this.unprojectFlat(xyz),
          _this$unprojectFlat2 = (0, _slicedToArray2.default)(_this$unprojectFlat, 2),
          X = _this$unprojectFlat2[0],
          Y = _this$unprojectFlat2[1];

      var Z = (xyz[2] || 0) / this.pixelsPerMeter;
      return [X, Y, Z];
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
      return xyz;
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
      return xyz;
    }
  }]);
  return Viewport;
}();

exports.default = Viewport;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./math-utils":"../../../node_modules/viewport-mercator-project/dist/esm/math-utils.js","./web-mercator-utils":"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-utils.js","gl-matrix/mat4":"../../../node_modules/gl-matrix/esm/mat4.js"}],"../../../node_modules/viewport-mercator-project/dist/esm/fit-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fitBounds;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fitBounds(_ref) {
  var width = _ref.width,
      height = _ref.height,
      bounds = _ref.bounds,
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? 0 : _ref$padding,
      _ref$offset = _ref.offset,
      offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;

  var _bounds = (0, _slicedToArray2.default)(bounds, 2),
      _bounds$ = (0, _slicedToArray2.default)(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = (0, _slicedToArray2.default)(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  if (Number.isFinite(padding)) {
    var p = padding;
    padding = {
      top: p,
      bottom: p,
      left: p,
      right: p
    };
  } else {
    (0, _assert.default)(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  }

  var viewport = new _webMercatorViewport.default({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });
  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  (0, _assert.default)(targetSize[0] > 0 && targetSize[1] > 0);
  var scaleX = targetSize[0] / size[0];
  var scaleY = targetSize[1] / size[1];
  var offsetX = (padding.right - padding.left) / 2 / scaleX;
  var offsetY = (padding.bottom - padding.top) / 2 / scaleY;
  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","./web-mercator-viewport":"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-viewport.js","./assert":"../../../node_modules/viewport-mercator-project/dist/esm/assert.js"}],"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _viewport = _interopRequireDefault(require("./viewport"));

var _webMercatorUtils = require("./web-mercator-utils");

var _fitBounds3 = _interopRequireDefault(require("./fit-bounds"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var WebMercatorViewport = function (_Viewport) {
  (0, _inherits2.default)(WebMercatorViewport, _Viewport);

  function WebMercatorViewport() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        _ref$latitude = _ref.latitude,
        latitude = _ref$latitude === void 0 ? 0 : _ref$latitude,
        _ref$longitude = _ref.longitude,
        longitude = _ref$longitude === void 0 ? 0 : _ref$longitude,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === void 0 ? 0 : _ref$zoom,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude,
        nearZMultiplier = _ref.nearZMultiplier,
        farZMultiplier = _ref.farZMultiplier;

    (0, _classCallCheck2.default)(this, WebMercatorViewport);
    width = width || 1;
    height = height || 1;
    var scale = (0, _webMercatorUtils.zoomToScale)(zoom);
    altitude = Math.max(0.75, altitude);
    var center = (0, _webMercatorUtils.lngLatToWorld)([longitude, latitude], scale);
    center[2] = 0;
    var projectionMatrix = (0, _webMercatorUtils.getProjectionMatrix)({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      nearZMultiplier: nearZMultiplier || 1 / height,
      farZMultiplier: farZMultiplier || 1.01
    });
    var viewMatrix = (0, _webMercatorUtils.getViewMatrix)({
      height: height,
      center: center,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      flipY: true
    });
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(WebMercatorViewport).call(this, {
      width: width,
      height: height,
      viewMatrix: viewMatrix,
      projectionMatrix: projectionMatrix
    }));
    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;
    _this.scale = scale;
    _this.center = center;
    _this.pixelsPerMeter = (0, _webMercatorUtils.getDistanceScales)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this))).pixelsPerMeter[2];
    Object.freeze((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    return _this;
  }

  (0, _createClass2.default)(WebMercatorViewport, [{
    key: "projectFlat",
    value: function projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
      return (0, _webMercatorUtils.lngLatToWorld)(lngLat, scale);
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
      return (0, _webMercatorUtils.worldToLngLat)(xy, scale);
    }
  }, {
    key: "getMapCenterByLngLatPosition",
    value: function getMapCenterByLngLatPosition(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;
      var fromLocation = (0, _webMercatorUtils.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
      var toLocation = (0, _webMercatorUtils.lngLatToWorld)(lngLat, this.scale);
      var translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
      var newCenter = vec2.add([], this.center, translate);
      return (0, _webMercatorUtils.worldToLngLat)(newCenter, this.scale);
    }
  }, {
    key: "getLocationAtPoint",
    value: function getLocationAtPoint(_ref3) {
      var lngLat = _ref3.lngLat,
          pos = _ref3.pos;
      return this.getMapCenterByLngLatPosition({
        lngLat: lngLat,
        pos: pos
      });
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = (0, _fitBounds3.default)(Object.assign({
        width: width,
        height: height,
        bounds: bounds
      }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({
        width: width,
        height: height,
        longitude: longitude,
        latitude: latitude,
        zoom: zoom
      });
    }
  }]);
  return WebMercatorViewport;
}(_viewport.default);

exports.default = WebMercatorViewport;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","./viewport":"../../../node_modules/viewport-mercator-project/dist/esm/viewport.js","./web-mercator-utils":"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-utils.js","./fit-bounds":"../../../node_modules/viewport-mercator-project/dist/esm/fit-bounds.js","gl-matrix/vec2":"../../../node_modules/gl-matrix/esm/vec2.js"}],"../../../node_modules/viewport-mercator-project/dist/esm/normalize-viewport-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeViewportProps;

var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));

var _mathUtils = require("./math-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_LATITUDE = 85.05113;
var MIN_LATITUDE = -85.05113;

function normalizeViewportProps(_ref) {
  var width = _ref.width,
      height = _ref.height,
      longitude = _ref.longitude,
      latitude = _ref.latitude,
      zoom = _ref.zoom,
      _ref$pitch = _ref.pitch,
      pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
      _ref$bearing = _ref.bearing,
      bearing = _ref$bearing === void 0 ? 0 : _ref$bearing;

  if (longitude < -180 || longitude > 180) {
    longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
  }

  if (bearing < -180 || bearing > 180) {
    bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
  }

  var flatViewport = new _webMercatorViewport.default({
    width: width,
    height: height,
    longitude: longitude,
    latitude: latitude,
    zoom: zoom
  });
  var topY = flatViewport.project([longitude, MAX_LATITUDE])[1];
  var bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];
  var shiftY = 0;

  if (bottomY - topY < height) {
    zoom += Math.log2(height / (bottomY - topY));
    flatViewport = new _webMercatorViewport.default({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom
    });
    topY = flatViewport.project([longitude, MAX_LATITUDE])[1];
    bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];
  }

  if (topY > 0) {
    shiftY = topY;
  } else if (bottomY < height) {
    shiftY = bottomY - height;
  }

  if (shiftY) {
    latitude = flatViewport.unproject([width / 2, height / 2 + shiftY])[1];
  }

  return {
    width: width,
    height: height,
    longitude: longitude,
    latitude: latitude,
    zoom: zoom,
    pitch: pitch,
    bearing: bearing
  };
}
},{"./web-mercator-viewport":"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-viewport.js","./math-utils":"../../../node_modules/viewport-mercator-project/dist/esm/math-utils.js"}],"../../../node_modules/viewport-mercator-project/dist/esm/fly-to-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = flyToViewport;

var _mathUtils = require("./math-utils");

var _webMercatorUtils = require("./web-mercator-utils");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var EPSILON = 0.01;
var VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];

function flyToViewport(startProps, endProps, t) {
  var viewport = {};
  var rho = 1.414;
  var startZoom = startProps.zoom;
  var startCenter = [startProps.longitude, startProps.latitude];
  var startScale = (0, _webMercatorUtils.zoomToScale)(startZoom);
  var endZoom = endProps.zoom;
  var endCenter = [endProps.longitude, endProps.latitude];
  var scale = (0, _webMercatorUtils.zoomToScale)(endZoom - startZoom);
  var startCenterXY = (0, _webMercatorUtils.lngLatToWorld)(startCenter, startScale);
  var endCenterXY = (0, _webMercatorUtils.lngLatToWorld)(endCenter, startScale);
  var uDelta = vec2.sub([], endCenterXY, startCenterXY);
  var w0 = Math.max(startProps.width, startProps.height);
  var w1 = w0 / scale;
  var u1 = vec2.length(uDelta);

  if (Math.abs(u1) < EPSILON) {
    for (var _i = 0; _i < VIEWPORT_TRANSITION_PROPS.length; _i++) {
      var key = VIEWPORT_TRANSITION_PROPS[_i];
      var startValue = startProps[key];
      var endValue = endProps[key];
      viewport[key] = (0, _mathUtils.lerp)(startValue, endValue, t);
    }

    return viewport;
  }

  var rho2 = rho * rho;
  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);
  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);
  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  var S = (r1 - r0) / rho;
  var s = t * S;
  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
  var scaleIncrement = 1 / w;
  var newZoom = startZoom + (0, _webMercatorUtils.scaleToZoom)(scaleIncrement);
  var newCenterWorld = vec2.scale([], uDelta, u);
  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);
  vec2.scale(newCenterWorld, newCenterWorld, scaleIncrement);
  var newCenter = (0, _webMercatorUtils.worldToLngLat)(newCenterWorld, (0, _webMercatorUtils.zoomToScale)(newZoom));
  viewport.longitude = newCenter[0];
  viewport.latitude = newCenter[1];
  viewport.zoom = newZoom;
  return viewport;
}
},{"./math-utils":"../../../node_modules/viewport-mercator-project/dist/esm/math-utils.js","./web-mercator-utils":"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-utils.js","gl-matrix/vec2":"../../../node_modules/gl-matrix/esm/vec2.js"}],"../../../node_modules/viewport-mercator-project/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "PerspectiveMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "fitBounds", {
  enumerable: true,
  get: function () {
    return _fitBounds.default;
  }
});
Object.defineProperty(exports, "normalizeViewportProps", {
  enumerable: true,
  get: function () {
    return _normalizeViewportProps.default;
  }
});
Object.defineProperty(exports, "flyToViewport", {
  enumerable: true,
  get: function () {
    return _flyToViewport.default;
  }
});
Object.defineProperty(exports, "lngLatToWorld", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.lngLatToWorld;
  }
});
Object.defineProperty(exports, "worldToLngLat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToLngLat;
  }
});
Object.defineProperty(exports, "worldToPixels", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToPixels;
  }
});
Object.defineProperty(exports, "pixelsToWorld", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.pixelsToWorld;
  }
});
Object.defineProperty(exports, "getMeterZoom", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getMeterZoom;
  }
});
Object.defineProperty(exports, "getDistanceScales", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getDistanceScales;
  }
});
Object.defineProperty(exports, "addMetersToLngLat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.addMetersToLngLat;
  }
});
Object.defineProperty(exports, "getViewMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getViewMatrix;
  }
});
Object.defineProperty(exports, "getProjectionMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getProjectionMatrix;
  }
});
Object.defineProperty(exports, "getProjectionParameters", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getProjectionParameters;
  }
});
Object.defineProperty(exports, "getUncenteredViewMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getViewMatrix;
  }
});
Object.defineProperty(exports, "projectFlat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.lngLatToWorld;
  }
});
Object.defineProperty(exports, "unprojectFlat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToLngLat;
  }
});

var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));

var _fitBounds = _interopRequireDefault(require("./fit-bounds"));

var _normalizeViewportProps = _interopRequireDefault(require("./normalize-viewport-props"));

var _flyToViewport = _interopRequireDefault(require("./fly-to-viewport"));

var _webMercatorUtils = require("./web-mercator-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./web-mercator-viewport":"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-viewport.js","./fit-bounds":"../../../node_modules/viewport-mercator-project/dist/esm/fit-bounds.js","./normalize-viewport-props":"../../../node_modules/viewport-mercator-project/dist/esm/normalize-viewport-props.js","./fly-to-viewport":"../../../node_modules/viewport-mercator-project/dist/esm/fly-to-viewport.js","./web-mercator-utils":"../../../node_modules/viewport-mercator-project/dist/esm/web-mercator-utils.js"}],"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorldPosition = getWorldPosition;
exports.projectPosition = projectPosition;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _constants = require("../../lib/constants");

var _viewportUniforms = require("./viewport-uniforms");

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var _viewportMercatorProject = require("viewport-mercator-project");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function lngLatZToWorldPosition(lngLatZ, viewport) {
  var offsetMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var _lngLatZ = (0, _slicedToArray2.default)(lngLatZ, 3),
      longitude = _lngLatZ[0],
      latitude = _lngLatZ[1],
      _lngLatZ$ = _lngLatZ[2],
      z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;

  var _viewport$projectFlat = viewport.projectFlat(lngLatZ),
      _viewport$projectFlat2 = (0, _slicedToArray2.default)(_viewport$projectFlat, 2),
      X = _viewport$projectFlat2[0],
      Y = _viewport$projectFlat2[1];

  var distanceScales = offsetMode ? (0, _viewportMercatorProject.getDistanceScales)({
    longitude: longitude,
    latitude: latitude,
    scale: viewport.scale
  }) : viewport.getDistanceScales();
  var Z = z * distanceScales.pixelsPerMeter[2];
  return [X, Y, Z];
}

function normalizeParameters(opts) {
  var normalizedParams = Object.assign({}, opts);
  var viewport = opts.viewport,
      coordinateSystem = opts.coordinateSystem,
      coordinateOrigin = opts.coordinateOrigin,
      fromCoordinateSystem = opts.fromCoordinateSystem,
      fromCoordinateOrigin = opts.fromCoordinateOrigin;

  if (fromCoordinateSystem === undefined) {
    normalizedParams.fromCoordinateSystem = coordinateSystem;
  }

  if (fromCoordinateOrigin === undefined) {
    normalizedParams.fromCoordinateOrigin = coordinateOrigin;
  }

  if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT && viewport.zoom >= _viewportUniforms.LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD) {
    normalizedParams.coordinateSystem = _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS;
    normalizedParams.coordinateOrigin = [Math.fround(viewport.longitude), Math.fround(viewport.latitude)];
  }

  return normalizedParams;
}

function getWorldPosition(position, _ref) {
  var viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix,
      coordinateSystem = _ref.coordinateSystem,
      coordinateOrigin = _ref.coordinateOrigin,
      offsetMode = _ref.offsetMode;

  var _position = (0, _slicedToArray2.default)(position, 3),
      x = _position[0],
      y = _position[1],
      z = _position[2];

  if (modelMatrix) {
    var _vec4$transformMat = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);

    var _vec4$transformMat2 = (0, _slicedToArray2.default)(_vec4$transformMat, 3);

    x = _vec4$transformMat2[0];
    y = _vec4$transformMat2[1];
    z = _vec4$transformMat2[2];
  }

  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT:
    case _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition((0, _viewportMercatorProject.addMetersToLngLat)(coordinateOrigin, [x, y, z]), viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.IDENTITY:
    default:
      return viewport.projectPosition([x, y, z]);
  }
}

function projectPosition(position, params) {
  var _normalizeParameters = normalizeParameters(params),
      viewport = _normalizeParameters.viewport,
      coordinateSystem = _normalizeParameters.coordinateSystem,
      coordinateOrigin = _normalizeParameters.coordinateOrigin,
      modelMatrix = _normalizeParameters.modelMatrix,
      fromCoordinateSystem = _normalizeParameters.fromCoordinateSystem,
      fromCoordinateOrigin = _normalizeParameters.fromCoordinateOrigin;

  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      {
        var worldPosition = getWorldPosition(position, {
          viewport: viewport,
          modelMatrix: modelMatrix,
          coordinateSystem: fromCoordinateSystem,
          coordinateOrigin: fromCoordinateOrigin,
          offsetMode: true
        });
        var originWorld = lngLatZToWorldPosition(coordinateOrigin, viewport, true);
        vec3.sub(worldPosition, worldPosition, originWorld);
        return worldPosition;
      }

    case _constants.COORDINATE_SYSTEM.LNGLAT:
    case _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:
    case _constants.COORDINATE_SYSTEM.IDENTITY:
    default:
      return getWorldPosition(position, {
        viewport: viewport,
        modelMatrix: modelMatrix,
        coordinateSystem: fromCoordinateSystem,
        coordinateOrigin: fromCoordinateOrigin,
        offsetMode: false
      });
  }
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../lib/constants":"../../../node_modules/@deck.gl/core/dist/esm/lib/constants.js","./viewport-uniforms":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js","gl-matrix/vec4":"../../../node_modules/gl-matrix/esm/vec4.js","gl-matrix/vec3":"../../../node_modules/gl-matrix/esm/vec3.js","viewport-mercator-project":"../../../node_modules/viewport-mercator-project/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIterable = createIterable;
var EMPTY_ARRAY = [];
var placeholderArray = [];

function createIterable(data) {
  var startRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var endRow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  var iterable = EMPTY_ARRAY;
  var objectInfo = {
    index: -1,
    data: data,
    target: []
  };

  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === 'function') {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }

  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }

  return {
    iterable: iterable,
    objectInfo: objectInfo
  };
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/utils/flatten.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flatten = flatten;
exports.countVertices = countVertices;
exports.flattenVertices = flattenVertices;
exports.fillArray = fillArray;

function flatten(array) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$filter = _ref.filter,
      filter = _ref$filter === void 0 ? function () {
    return true;
  } : _ref$filter,
      _ref$map = _ref.map,
      map = _ref$map === void 0 ? function (x) {
    return x;
  } : _ref$map,
      _ref$result = _ref.result,
      result = _ref$result === void 0 ? [] : _ref$result;

  if (!Array.isArray(array)) {
    return filter(array) ? [map(array)] : [];
  }

  return flattenArray(array, filter, map, result);
}

function flattenArray(array, filter, map, result) {
  var index = -1;

  while (++index < array.length) {
    var value = array[index];

    if (Array.isArray(value)) {
      flattenArray(value, filter, map, result);
    } else if (filter(value)) {
      result.push(map(value));
    }
  }

  return result;
}

function countVertices(nestedArray) {
  var count = 0;
  var index = -1;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      count += countVertices(value);
    } else {
      count++;
    }
  }

  return count;
}

function flattenVertices(nestedArray) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$result = _ref2.result,
      result = _ref2$result === void 0 ? [] : _ref2$result,
      _ref2$dimensions = _ref2.dimensions,
      dimensions = _ref2$dimensions === void 0 ? 3 : _ref2$dimensions;

  var index = -1;
  var vertexLength = 0;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      flattenVertices(value, {
        result: result,
        dimensions: dimensions
      });
    } else {
      if (vertexLength < dimensions) {
        result.push(value);
        vertexLength++;
      }
    }
  }

  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }

  return result;
}

function fillArray(_ref3) {
  var target = _ref3.target,
      source = _ref3.source,
      _ref3$start = _ref3.start,
      start = _ref3$start === void 0 ? 0 : _ref3$start,
      _ref3$count = _ref3.count,
      count = _ref3$count === void 0 ? 1 : _ref3$count;
  var length = source.length;
  var total = count * length;
  var copied = 0;

  for (var i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/utils/range.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.FULL = exports.EMPTY = void 0;
var EMPTY = [];
exports.EMPTY = EMPTY;
var FULL = [[0, Infinity]];
exports.FULL = FULL;

function add(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }

  if (range[0] < 0) {
    range[0] = 0;
  }

  if (range[0] >= range[1]) {
    return rangeList;
  }

  var newRangeList = [];
  var len = rangeList.length;
  var insertPosition = 0;

  for (var i = 0; i < len; i++) {
    var range0 = rangeList[i];

    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }

  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/lib/base-attribute.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BaseAttribute = function () {
  function BaseAttribute(gl) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, BaseAttribute);
    var _opts$id = opts.id,
        id = _opts$id === void 0 ? (0, _core.uid)('attribute') : _opts$id,
        type = opts.type,
        _opts$isIndexed = opts.isIndexed,
        isIndexed = _opts$isIndexed === void 0 ? false : _opts$isIndexed;
    this.gl = gl;
    this.id = id;
    this.isIndexed = isIndexed;
    this.target = isIndexed ? 34963 : 34962;
    this.type = type;

    if (isIndexed && !type) {
      this.type = gl && (0, _core.hasFeature)(gl, _core.FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
    }

    this.value = null;
    this.externalBuffer = null;
    this.buffer = null;
    this.userData = {};
    this.update(opts);

    this._validateAttributeDefinition();
  }

  (0, _createClass2.default)(BaseAttribute, [{
    key: "delete",
    value: function _delete() {
      if (this.buffer) {
        this.buffer.delete();
        this.buffer = null;
      }
    }
  }, {
    key: "update",
    value: function update(opts) {
      var value = opts.value,
          buffer = opts.buffer,
          _opts$constant = opts.constant,
          constant = _opts$constant === void 0 ? this.constant || false : _opts$constant;
      this.constant = constant;

      if (buffer) {
        this.externalBuffer = buffer;
        this.constant = false;
        this.type = opts.type || buffer.accessor.type;

        if (buffer.accessor.divisor !== undefined) {
          this.divisor = buffer.accessor.divisor;
        }

        if (opts.divisor !== undefined) {
          this.divisor = opts.divisor;
        }
      } else if (value) {
        this.externalBuffer = null;
        var size = this.size || opts.size || 0;

        if (constant && value.length !== size) {
          this.value = new Float32Array(size);
          var index = this.offset / 4;

          for (var i = 0; i < this.size; ++i) {
            this.value[i] = value[index + i];
          }
        } else {
          this.value = value;
        }

        if (!constant && this.gl) {
          this.buffer = this.buffer || this._createBuffer(opts);
          this.buffer.setData({
            data: value
          });
          this.type = this.buffer.accessor.type;
        }
      }

      this._setAccessor(opts);
    }
  }, {
    key: "getBuffer",
    value: function getBuffer() {
      if (this.constant) {
        return null;
      }

      return this.externalBuffer || this.buffer;
    }
  }, {
    key: "getValue",
    value: function getValue() {
      if (this.constant) {
        return this.value;
      }

      var buffer = this.externalBuffer || this.buffer;

      if (buffer) {
        return [buffer, this];
      }

      return null;
    }
  }, {
    key: "_createBuffer",
    value: function _createBuffer(opts) {
      var props = Object.assign({}, opts, {
        id: this.id,
        target: this.target,
        accessor: {
          type: this.type
        }
      });

      if (Number.isFinite(props.divisor)) {
        props.accessor.divisor = props.divisor;
      }

      delete props.divisor;

      if (Number.isFinite(props.size)) {
        props.accessor.size = props.size;
      }

      delete props.size;
      return new _core.Buffer(this.gl, props);
    }
  }, {
    key: "_setAccessor",
    value: function _setAccessor(opts) {
      var _opts$size = opts.size,
          size = _opts$size === void 0 ? this.size : _opts$size,
          _opts$offset = opts.offset,
          offset = _opts$offset === void 0 ? this.offset || 0 : _opts$offset,
          _opts$stride = opts.stride,
          stride = _opts$stride === void 0 ? this.stride || 0 : _opts$stride,
          _opts$normalized = opts.normalized,
          normalized = _opts$normalized === void 0 ? this.normalized || false : _opts$normalized,
          _opts$integer = opts.integer,
          integer = _opts$integer === void 0 ? this.integer || false : _opts$integer,
          _opts$divisor = opts.divisor,
          divisor = _opts$divisor === void 0 ? this.divisor || 0 : _opts$divisor,
          instanced = opts.instanced,
          isInstanced = opts.isInstanced;
      this.size = size;
      this.offset = offset;
      this.stride = stride;
      this.normalized = normalized;
      this.integer = integer;
      this.divisor = divisor;

      if (isInstanced !== undefined) {
        _core.log.deprecated('Attribute.isInstanced')();

        this.divisor = isInstanced ? 1 : 0;
      }

      if (instanced !== undefined) {
        _core.log.deprecated('Attribute.instanced')();

        this.divisor = instanced ? 1 : 0;
      }
    }
  }, {
    key: "_validateAttributeDefinition",
    value: function _validateAttributeDefinition() {}
  }]);
  return BaseAttribute;
}();

exports.default = BaseAttribute;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glArrayFromType = glArrayFromType;
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@luma.gl/core");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _iterableUtils = require("../utils/iterable-utils");

var _flatten = require("../utils/flatten");

var range = _interopRequireWildcard(require("../utils/range"));

var _log = _interopRequireDefault(require("../utils/log"));

var _baseAttribute = _interopRequireDefault(require("./base-attribute"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_STATE = {
  isExternalBuffer: false,
  needsUpdate: true,
  needsRedraw: false,
  updateRanges: range.FULL,
  allocedInstances: -1
};

var Attribute = function (_BaseAttribute) {
  (0, _inherits2.default)(Attribute, _BaseAttribute);

  function Attribute(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Attribute);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Attribute).call(this, gl, opts));
    var _opts$transition = opts.transition,
        transition = _opts$transition === void 0 ? false : _opts$transition,
        _opts$noAlloc = opts.noAlloc,
        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,
        _opts$update = opts.update,
        update = _opts$update === void 0 ? null : _opts$update,
        _opts$accessor = opts.accessor,
        accessor = _opts$accessor === void 0 ? null : _opts$accessor,
        _opts$bufferLayout = opts.bufferLayout,
        bufferLayout = _opts$bufferLayout === void 0 ? null : _opts$bufferLayout;
    var _opts$defaultValue = opts.defaultValue,
        defaultValue = _opts$defaultValue === void 0 ? [0, 0, 0, 0] : _opts$defaultValue;
    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
    _this.shaderAttributes = {};
    _this.hasShaderAttributes = false;

    if (opts.shaderAttributes) {
      var shaderAttributes = opts.shaderAttributes;

      for (var shaderAttributeName in shaderAttributes) {
        var shaderAttribute = shaderAttributes[shaderAttributeName];
        _this.shaderAttributes[shaderAttributeName] = new Attribute(_this.gl, Object.assign({}, shaderAttribute, {
          id: shaderAttributeName,
          constant: shaderAttribute.constant || false,
          isIndexed: shaderAttribute.isIndexed || shaderAttribute.elements,
          size: shaderAttribute.elements && 1 || shaderAttribute.size || _this.size,
          value: shaderAttribute.value || null,
          divisor: shaderAttribute.instanced || shaderAttribute.divisor || _this.divisor,
          buffer: _this.getBuffer(),
          noAlloc: true
        }));
        _this.hasShaderAttributes = true;
      }
    }

    Object.assign(_this.userData, DEFAULT_STATE, opts, {
      transition: transition,
      noAlloc: noAlloc,
      update: update || accessor && _this._standardAccessor,
      accessor: accessor,
      defaultValue: defaultValue,
      bufferLayout: bufferLayout
    });
    Object.seal(_this.userData);

    _this._validateAttributeUpdaters();

    return _this;
  }

  (0, _createClass2.default)(Attribute, [{
    key: "needsUpdate",
    value: function needsUpdate() {
      return this.userData.needsUpdate;
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$clearChangedFlag = _ref.clearChangedFlags,
          clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;

      var needsRedraw = this.userData.needsRedraw;
      this.userData.needsRedraw = this.userData.needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
  }, {
    key: "getInstanceCount",
    value: function getInstanceCount() {
      return this.value !== null ? this.value.length / this.size : 0;
    }
  }, {
    key: "getUpdateTriggers",
    value: function getUpdateTriggers() {
      var accessor = this.userData.accessor;
      return [this.id].concat(typeof accessor !== 'function' && accessor || []);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor() {
      return this.userData.accessor;
    }
  }, {
    key: "getShaderAttributes",
    value: function getShaderAttributes() {
      var shaderAttributes = {};

      if (this.hasShaderAttributes) {
        Object.assign(shaderAttributes, this.shaderAttributes);
      } else {
        shaderAttributes[this.id] = this;
      }

      return shaderAttributes;
    }
  }, {
    key: "supportsTransition",
    value: function supportsTransition() {
      return this.userData.transition;
    }
  }, {
    key: "getTransitionSetting",
    value: function getTransitionSetting(opts) {
      var _this$userData = this.userData,
          transition = _this$userData.transition,
          accessor = _this$userData.accessor;

      if (!transition) {
        return null;
      }

      var settings = Array.isArray(accessor) ? opts[accessor.find(function (a) {
        return opts[a];
      })] : opts[accessor];

      if (Number.isFinite(settings)) {
        settings = {
          duration: settings
        };
      }

      if (settings && settings.duration > 0) {
        return Object.assign({}, transition, settings);
      }

      return null;
    }
  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      var dataRange = arguments.length > 1 ? arguments[1] : undefined;
      this.userData.needsUpdate = this.userData.needsUpdate || reason;

      if (dataRange) {
        var _dataRange$startRow = dataRange.startRow,
            startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,
            _dataRange$endRow = dataRange.endRow,
            endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;
        this.userData.updateRanges = range.add(this.userData.updateRanges, [startRow, endRow]);
      } else {
        this.userData.updateRanges = range.FULL;
      }
    }
  }, {
    key: "clearNeedsUpdate",
    value: function clearNeedsUpdate() {
      this.userData.needsUpdate = false;
      this.userData.updateRanges = range.EMPTY;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      this.userData.needsRedraw = this.userData.needsRedraw || reason;
    }
  }, {
    key: "allocate",
    value: function allocate(numInstances) {
      var state = this.userData;

      if (state.isExternalBuffer || state.noAlloc) {
        return false;
      }

      var instanceCount = this.getInstanceCount();
      var needsAlloc = instanceCount === 0 || instanceCount < numInstances;

      if (needsAlloc && (state.update || state.accessor)) {
        (0, _assert.default)(Number.isFinite(numInstances));
        var allocCount = Math.max(numInstances, 1);
        var ArrayType = glArrayFromType(this.type || 5126);
        var oldValue = this.value;
        this.constant = false;
        this.value = new ArrayType(this.size * allocCount);

        if (this.buffer && this.buffer.byteLength < this.value.byteLength) {
          this.buffer.reallocate(this.value.byteLength);
        }

        if (state.updateRanges !== range.FULL) {
          this.value.set(oldValue);
          this.buffer.subData(oldValue);
        }

        this.setNeedsUpdate(true, {
          startRow: instanceCount
        });
        state.allocedInstances = allocCount;
        return true;
      }

      return false;
    }
  }, {
    key: "updateBuffer",
    value: function updateBuffer(_ref2) {
      var numInstances = _ref2.numInstances,
          bufferLayout = _ref2.bufferLayout,
          data = _ref2.data,
          props = _ref2.props,
          context = _ref2.context;

      if (!this.needsUpdate()) {
        return false;
      }

      var state = this.userData;
      var update = state.update,
          updateRanges = state.updateRanges,
          noAlloc = state.noAlloc;
      var updated = true;

      if (update) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = updateRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
                startRow = _step$value[0],
                endRow = _step$value[1];

            update.call(context, this, {
              data: data,
              startRow: startRow,
              endRow: endRow,
              props: props,
              numInstances: numInstances,
              bufferLayout: bufferLayout
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength) {
          this.update({
            value: this.value,
            constant: this.constant
          });
        } else {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = updateRanges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
                  startRow = _step2$value[0],
                  endRow = _step2$value[1];

              var startOffset = Number.isFinite(startRow) ? this._getVertexOffset(startRow, this.bufferLayout) : 0;
              var endOffset = Number.isFinite(endRow) ? this._getVertexOffset(endRow, this.bufferLayout) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
              this.buffer.subData({
                data: this.value.subarray(startOffset, endOffset),
                offset: startOffset * this.value.BYTES_PER_ELEMENT
              });
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }

        this._checkAttributeArray();
      } else {
        updated = false;
      }

      this._updateShaderAttributes();

      this.clearNeedsUpdate();
      state.needsRedraw = true;
      return updated;
    }
  }, {
    key: "update",
    value: function update(props) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Attribute.prototype), "update", this).call(this, props);

      this._updateShaderAttributes();
    }
  }, {
    key: "setGenericValue",
    value: function setGenericValue(value) {
      var state = this.userData;

      if (value === undefined || typeof value === 'function') {
        state.isExternalBuffer = false;
        return false;
      }

      value = this._normalizeValue(value);
      var hasChanged = !this.constant || !this._areValuesEqual(value, this.value);

      if (hasChanged) {
        this.update({
          constant: true,
          value: value
        });
      }

      state.needsRedraw = state.needsUpdate || hasChanged;
      this.clearNeedsUpdate();
      state.isExternalBuffer = true;

      this._updateShaderAttributes();

      return true;
    }
  }, {
    key: "setExternalBuffer",
    value: function setExternalBuffer(buffer, numInstances) {
      var state = this.userData;

      if (buffer) {
        state.isExternalBuffer = true;
        this.clearNeedsUpdate();

        if (buffer instanceof _core.Buffer) {
          if (this.externalBuffer !== buffer) {
            this.update({
              constant: false,
              buffer: buffer
            });
            state.needsRedraw = true;
          }
        } else if (this.value !== buffer) {
          if (!ArrayBuffer.isView(buffer)) {
            throw new Error('Attribute prop must be typed array');
          }

          if (state.auto && buffer.length <= numInstances * this.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          var ArrayType = glArrayFromType(this.type || 5126);

          if (buffer instanceof ArrayType) {
            this.update({
              constant: false,
              value: buffer
            });
          } else {
            _log.default.warn("Attribute prop ".concat(this.id, " is casted to ").concat(ArrayType.name))();

            this.update({
              constant: false,
              value: new ArrayType(buffer)
            });
          }

          this.value = buffer;
          state.needsRedraw = true;
        }

        this._updateShaderAttributes();

        return true;
      }

      state.isExternalBuffer = false;
      return false;
    }
  }, {
    key: "_getVertexOffset",
    value: function _getVertexOffset(row, bufferLayout) {
      if (bufferLayout) {
        var offset = 0;
        var index = 0;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = bufferLayout[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var geometrySize = _step3.value;

            if (index >= row) {
              break;
            }

            offset += geometrySize * this.size;
            index++;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return offset;
      }

      return row * this.size;
    }
  }, {
    key: "_normalizeValue",
    value: function _normalizeValue(value) {
      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var defaultValue = this.userData.defaultValue;

      if (!Array.isArray(value) && !ArrayBuffer.isView(value)) {
        out[start] = Number.isFinite(value) ? value : defaultValue[0];
        return out;
      }

      switch (this.size) {
        case 4:
          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];

        case 3:
          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];

        case 2:
          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];

        case 1:
          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
      }

      return out;
    }
  }, {
    key: "_areValuesEqual",
    value: function _areValuesEqual(value1, value2) {
      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.size;

      for (var i = 0; i < size; i++) {
        if (value1[i] !== value2[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_standardAccessor",
    value: function _standardAccessor(attribute, _ref3) {
      var data = _ref3.data,
          startRow = _ref3.startRow,
          endRow = _ref3.endRow,
          props = _ref3.props,
          numInstances = _ref3.numInstances,
          bufferLayout = _ref3.bufferLayout;
      var state = attribute.userData;
      var accessor = state.accessor;
      var value = attribute.value,
          size = attribute.size;
      var accessorFunc = typeof accessor === 'function' ? accessor : props[accessor];
      (0, _assert.default)(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));

      var i = attribute._getVertexOffset(startRow, bufferLayout);

      var _createIterable = (0, _iterableUtils.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = iterable[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var object = _step4.value;
          objectInfo.index++;
          var objectValue = accessorFunc(object, objectInfo);

          if (bufferLayout) {
            attribute._normalizeValue(objectValue, objectInfo.target);

            var numVertices = bufferLayout[objectInfo.index];
            (0, _flatten.fillArray)({
              target: attribute.value,
              source: objectInfo.target,
              start: i,
              count: numVertices
            });
            i += numVertices * size;
          } else {
            attribute._normalizeValue(objectValue, value, i);

            i += size;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      attribute.constant = false;
      attribute.bufferLayout = bufferLayout;
    }
  }, {
    key: "_validateAttributeUpdaters",
    value: function _validateAttributeUpdaters() {
      var state = this.userData;
      var hasUpdater = state.noAlloc || typeof state.update === 'function' || typeof state.accessor === 'string';

      if (!hasUpdater) {
        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
      }
    }
  }, {
    key: "_checkAttributeArray",
    value: function _checkAttributeArray() {
      var value = this.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);

        if (!valid) {
          throw new Error("Illegal attribute generated for ".concat(this.id));
        }
      }
    }
  }, {
    key: "_updateShaderAttributes",
    value: function _updateShaderAttributes() {
      var shaderAttributes = this.shaderAttributes;

      for (var shaderAttributeName in shaderAttributes) {
        var shaderAttribute = shaderAttributes[shaderAttributeName];
        shaderAttribute.update({
          buffer: this.getBuffer(),
          value: this.value,
          constant: this.constant
        });
      }
    }
  }, {
    key: "bufferLayout",
    get: function get() {
      return this.userData.bufferLayout;
    },
    set: function set(layout) {
      this.userData.bufferLayout = layout;
    }
  }]);
  return Attribute;
}(_baseAttribute.default);

exports.default = Attribute;

function glArrayFromType(glType) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$clamped = _ref4.clamped,
      clamped = _ref4$clamped === void 0 ? true : _ref4$clamped;

  switch (glType) {
    case 5126:
      return Float32Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Failed to deduce type from array');
  }
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js","../utils/iterable-utils":"../../../node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","../utils/flatten":"../../../node_modules/@deck.gl/core/dist/esm/utils/flatten.js","../utils/range":"../../../node_modules/@deck.gl/core/dist/esm/utils/range.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","./base-attribute":"../../../node_modules/@deck.gl/core/dist/esm/lib/base-attribute.js"}],"../../../node_modules/@deck.gl/core/dist/esm/utils/array-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padArray = padArray;

function padArrayChunk(_ref) {
  var source = _ref.source,
      target = _ref.target,
      _ref$start = _ref.start,
      start = _ref$start === void 0 ? 0 : _ref$start,
      end = _ref.end,
      getData = _ref.getData;
  end = end || target.length;
  var sourceLength = source.length;
  var targetLength = end - start;

  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start);
    return;
  }

  target.set(source, start);

  if (!getData) {
    return;
  }

  var i = sourceLength;

  while (i < targetLength) {
    var datum = getData(i, source);

    for (var j = 0; j < datum.length; j++) {
      target[start + i] = datum[j];
      i++;
    }
  }
}

function padArray(_ref2) {
  var source = _ref2.source,
      target = _ref2.target,
      size = _ref2.size,
      getData = _ref2.getData,
      sourceLayout = _ref2.sourceLayout,
      targetLayout = _ref2.targetLayout;

  if (!Array.isArray(targetLayout)) {
    padArrayChunk({
      source: source,
      target: target,
      getData: getData
    });
    return target;
  }

  var sourceIndex = 0;
  var targetIndex = 0;

  var getChunkData = getData && function (i, chunk) {
    return getData(i + targetIndex, chunk);
  };

  var n = Math.min(sourceLayout.length, targetLayout.length);

  for (var i = 0; i < n; i++) {
    var sourceChunkLength = sourceLayout[i] * size;
    var targetChunkLength = targetLayout[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, sourceIndex + sourceChunkLength),
      target: target,
      start: targetIndex,
      end: targetIndex + targetChunkLength,
      getData: getChunkData
    });
    sourceIndex += sourceChunkLength;
    targetIndex += targetChunkLength;
  }

  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target: target,
      start: targetIndex,
      getData: getChunkData
    });
  }

  return target;
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute-transition-utils.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShaders = getShaders;
exports.getBuffers = getBuffers;
exports.padBuffer = padBuffer;

var _core = require("@luma.gl/core");

var _arrayUtils = require("../utils/array-utils");

var ATTRIBUTE_MAPPING = {
  1: 'float',
  2: 'vec2',
  3: 'vec3',
  4: 'vec4'
};

function getShaders(transitions) {
  var varyings = [];
  var attributeDeclarations = [];
  var uniformsDeclarations = [];
  var varyingDeclarations = [];
  var calculations = [];

  for (var attributeName in transitions) {
    var transition = transitions[attributeName];
    var attributeType = ATTRIBUTE_MAPPING[transition.attribute.size];

    if (attributeType) {
      transition.bufferIndex = varyings.length;
      varyings.push(attributeName);
      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "From;"));
      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "To;"));
      uniformsDeclarations.push("uniform float ".concat(attributeName, "Time;"));
      varyingDeclarations.push("varying ".concat(attributeType, " ").concat(attributeName, ";"));
      calculations.push("".concat(attributeName, " = mix(").concat(attributeName, "From, ").concat(attributeName, "To,\n        ").concat(attributeName, "Time);"));
    }
  }

  var vs = "\n#define SHADER_NAME feedback-vertex-shader\n".concat(attributeDeclarations.join('\n'), "\n").concat(uniformsDeclarations.join('\n'), "\n").concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  ").concat(calculations.join('\n'), "\n  gl_Position = vec4(0.0);\n}\n");
  var fs = "#define SHADER_NAME feedback-fragment-shader\n\nprecision highp float;\n\n".concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  gl_FragColor = vec4(0.0);\n}\n");
  return {
    vs: vs,
    fs: fs,
    varyings: varyings
  };
}

function getBuffers(transitions) {
  var sourceBuffers = {};
  var feedbackBuffers = {};

  for (var attributeName in transitions) {
    var _transitions$attribut = transitions[attributeName],
        fromState = _transitions$attribut.fromState,
        toState = _transitions$attribut.toState,
        buffer = _transitions$attribut.buffer;
    sourceBuffers["".concat(attributeName, "From")] = fromState instanceof _core.Buffer ? [fromState, {
      divisor: 0
    }] : fromState;
    sourceBuffers["".concat(attributeName, "To")] = toState;
    feedbackBuffers["".concat(attributeName)] = buffer;
  }

  return {
    sourceBuffers: sourceBuffers,
    feedbackBuffers: feedbackBuffers
  };
}

function padBuffer(_ref) {
  var fromState = _ref.fromState,
      toState = _ref.toState,
      fromLength = _ref.fromLength,
      toLength = _ref.toLength,
      fromBufferLayout = _ref.fromBufferLayout,
      toBufferLayout = _ref.toBufferLayout,
      _ref$getData = _ref.getData,
      getData = _ref$getData === void 0 ? function (x) {
    return x;
  } : _ref$getData;
  var hasBufferLayout = fromBufferLayout && toBufferLayout;

  if (!hasBufferLayout && fromLength >= toLength || !(fromState instanceof _core.Buffer)) {
    return;
  }

  var data = new Float32Array(toLength);
  var fromData = fromState.getData({});
  var size = toState.size,
      constant = toState.constant;
  var toData = constant ? toState.getValue() : toState.getBuffer().getData({});
  var getMissingData = constant ? function (i, chunk) {
    return getData(toData, chunk);
  } : function (i, chunk) {
    return getData(toData.subarray(i, i + size), chunk);
  };
  (0, _arrayUtils.padArray)({
    source: fromData,
    target: data,
    sourceLayout: fromBufferLayout,
    targetLayout: toBufferLayout,
    size: toState.size,
    getData: getMissingData
  });
  fromState.setData({
    data: data
  });
}
},{"@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","../utils/array-utils":"../../../node_modules/@deck.gl/core/dist/esm/utils/array-utils.js"}],"../../../node_modules/@deck.gl/core/dist/esm/transitions/transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRANSITION_STATE = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TRANSITION_STATE = {
  NONE: 'none',
  PENDING: 'pending',
  IN_PROGRESS: 'in_progress',
  ENDED: 'ended'
};
exports.TRANSITION_STATE = TRANSITION_STATE;

function noop() {}

var Transition = function () {
  function Transition(props) {
    (0, _classCallCheck2.default)(this, Transition);
    this._startTime = null;
    this._state = TRANSITION_STATE.NONE;
    this.duration = 1;

    this.easing = function (t) {
      return t;
    };

    this.onStart = noop;
    this.onUpdate = noop;
    this.onInterrupt = noop;
    this.onEnd = noop;
    Object.assign(this, props);
  }

  (0, _createClass2.default)(Transition, [{
    key: "start",
    value: function start(props) {
      if (this.inProgress) {
        this.onInterrupt(this);
      }

      Object.assign(this, props);

      this._setState(TRANSITION_STATE.PENDING);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (this.inProgress) {
        this.onInterrupt(this);

        this._setState(TRANSITION_STATE.NONE);
      }
    }
  }, {
    key: "update",
    value: function update(currentTime) {
      if (this.state === TRANSITION_STATE.PENDING) {
        this._startTime = currentTime;

        this._setState(TRANSITION_STATE.IN_PROGRESS);
      }

      if (this.state === TRANSITION_STATE.IN_PROGRESS) {
        var shouldEnd = false;
        var time = (currentTime - this._startTime) / this.duration;

        if (time >= 1) {
          time = 1;
          shouldEnd = true;
        }

        this.time = this.easing(time);
        this.onUpdate(this);

        if (shouldEnd) {
          this._setState(TRANSITION_STATE.ENDED);
        }

        return true;
      }

      return false;
    }
  }, {
    key: "_setState",
    value: function _setState(newState) {
      if (this._state === newState) {
        return;
      }

      this._state = newState;

      switch (newState) {
        case TRANSITION_STATE.PENDING:
          this.onStart(this);
          break;

        case TRANSITION_STATE.ENDED:
          this.onEnd(this);
          break;

        default:
      }
    }
  }, {
    key: "state",
    get: function get() {
      return this._state;
    }
  }, {
    key: "inProgress",
    get: function get() {
      return this._state === TRANSITION_STATE.PENDING || this._state === TRANSITION_STATE.IN_PROGRESS;
    }
  }]);
  return Transition;
}();

exports.default = Transition;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute-transition-manager.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _core = require("@luma.gl/core");

var _attributeTransitionUtils = require("./attribute-transition-utils");

var _attribute = _interopRequireDefault(require("./attribute"));

var _baseAttribute = _interopRequireDefault(require("./base-attribute"));

var _transition = _interopRequireDefault(require("../transitions/transition"));

var _log = _interopRequireDefault(require("../utils/log"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var noop = function noop() {};

var DEFAULT_TRANSITION_SETTINGS = {
  duration: 0,
  easing: function easing(t) {
    return t;
  },
  onStart: noop,
  onEnd: noop,
  onInterrupt: noop
};

var AttributeTransitionManager = function () {
  function AttributeTransitionManager(gl, _ref) {
    var id = _ref.id;
    (0, _classCallCheck2.default)(this, AttributeTransitionManager);
    this.id = id;
    this.gl = gl;
    this.attributeTransitions = {};
    this.needsRedraw = false;
    this.transform = null;
    this.numInstances = 0;

    if (_core.Transform.isSupported(gl)) {
      this.isSupported = true;
    } else if (gl) {
      _log.default.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();
    }
  }

  (0, _createClass2.default)(AttributeTransitionManager, [{
    key: "finalize",
    value: function finalize() {
      if (this.transform) {
        this.transform.delete();
      }

      for (var attributeName in this.attributeTransitions) {
        this._removeTransition(attributeName);
      }
    }
  }, {
    key: "update",
    value: function update(_ref2) {
      var attributes = _ref2.attributes,
          _ref2$transitions = _ref2.transitions,
          transitions = _ref2$transitions === void 0 ? {} : _ref2$transitions,
          numInstances = _ref2.numInstances;
      this.opts = transitions;
      this.numInstances = numInstances || 1;

      if (!this.isSupported) {
        return;
      }

      var attributeTransitions = this.attributeTransitions;
      var changedTransitions = {};

      for (var attributeName in attributes) {
        var hasChanged = this._updateAttribute(attributeName, attributes[attributeName]);

        if (hasChanged) {
          changedTransitions[attributeName] = attributeTransitions[attributeName];
        }
      }

      for (var _attributeName in attributeTransitions) {
        var attribute = attributes[_attributeName];

        if (!attribute || !attribute.supportsTransition()) {
          this._removeTransition(_attributeName);
        }
      }

      if (!this.transform) {
        this._createModel();
      } else if (this.transform) {
        var _getBuffers = (0, _attributeTransitionUtils.getBuffers)(changedTransitions),
            sourceBuffers = _getBuffers.sourceBuffers,
            feedbackBuffers = _getBuffers.feedbackBuffers;

        this.transform.update({
          elementCount: this.numInstances,
          sourceBuffers: sourceBuffers,
          feedbackBuffers: feedbackBuffers
        });
      }
    }
  }, {
    key: "hasAttribute",
    value: function hasAttribute(attributeName) {
      return attributeName in this.attributeTransitions;
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      var animatedAttributes = {};

      for (var attributeName in this.attributeTransitions) {
        var transition = this.attributeTransitions[attributeName];

        if (transition.buffer) {
          animatedAttributes[attributeName] = transition.attributeInTransition;
        }
      }

      return animatedAttributes;
    }
  }, {
    key: "setCurrentTime",
    value: function setCurrentTime(currentTime) {
      if (!this.transform || this.numInstances === 0) {
        return false;
      }

      var uniforms = {};
      var needsRedraw = this.needsRedraw;
      this.needsRedraw = false;

      for (var attributeName in this.attributeTransitions) {
        var transition = this.attributeTransitions[attributeName];
        var updated = transition.update(currentTime);

        if (updated) {
          uniforms["".concat(attributeName, "Time")] = transition.time;
          needsRedraw = true;
        }
      }

      if (needsRedraw) {
        this.transform.run({
          uniforms: uniforms
        });
      }

      return needsRedraw;
    }
  }, {
    key: "_createTransition",
    value: function _createTransition(attributeName, attribute) {
      var transition = this.attributeTransitions[attributeName];

      if (!transition) {
        transition = new _transition.default({
          name: attributeName,
          attribute: attribute,
          attributeInTransition: new _attribute.default(this.gl, attribute),
          bufferLayout: attribute.bufferLayout
        });
        this.attributeTransitions[attributeName] = transition;

        this._invalidateModel();

        return transition;
      }

      return null;
    }
  }, {
    key: "_removeTransition",
    value: function _removeTransition(attributeName) {
      var transition = this.attributeTransitions[attributeName];

      if (transition) {
        if (transition.buffer) {
          transition.buffer.delete();
        }

        if (transition._swapBuffer) {
          transition._swapBuffer.delete();
        }

        delete this.attributeTransitions[attributeName];

        this._invalidateModel();
      }
    }
  }, {
    key: "_updateAttribute",
    value: function _updateAttribute(attributeName, attribute) {
      var settings = attribute.getTransitionSetting(this.opts);

      if (settings) {
        var hasChanged;
        var transition = this.attributeTransitions[attributeName];

        if (transition) {
          hasChanged = attribute.needsRedraw();
        } else {
          transition = this._createTransition(attributeName, attribute);
          hasChanged = true;
        }

        if (hasChanged) {
          this._triggerTransition(transition, settings);

          return true;
        }
      }

      return false;
    }
  }, {
    key: "_invalidateModel",
    value: function _invalidateModel() {
      if (this.transform) {
        this.transform.delete();
        this.transform = null;
      }
    }
  }, {
    key: "_createModel",
    value: function _createModel() {
      if (Object.keys(this.attributeTransitions).length === 0) {
        return;
      }

      this.transform = new _core.Transform(this.gl, Object.assign({
        elementCount: this.numInstances
      }, (0, _attributeTransitionUtils.getBuffers)(this.attributeTransitions), (0, _attributeTransitionUtils.getShaders)(this.attributeTransitions)));
    }
  }, {
    key: "_getNextTransitionStates",
    value: function _getNextTransitionStates(transition, settings) {
      var attribute = transition.attribute;
      var size = attribute.size;
      var toState;

      if (attribute.constant) {
        toState = new _baseAttribute.default(this.gl, {
          constant: true,
          value: attribute.value,
          size: size
        });
      } else {
        toState = new _baseAttribute.default(this.gl, {
          constant: false,
          buffer: attribute.getBuffer(),
          divisor: 0,
          size: size,
          value: attribute.externalBuffer ? null : attribute.value
        });
      }

      var fromState = transition.buffer || toState;
      var toLength = this.numInstances * size;
      var fromLength = fromState instanceof _core.Buffer && fromState.getElementCount() || toLength;
      var buffer = transition._swapBuffer;
      transition._swapBuffer = transition.buffer;

      if (!buffer) {
        buffer = new _core.Buffer(this.gl, {
          data: new Float32Array(toLength),
          usage: 35050
        });
      } else if (buffer.getElementCount() < toLength) {
        buffer.setData({
          data: new Float32Array(toLength)
        });
      }

      transition.attributeInTransition.update({
        buffer: buffer
      });
      (0, _attributeTransitionUtils.padBuffer)({
        fromState: fromState,
        toState: toState,
        fromLength: fromLength,
        toLength: toLength,
        fromBufferLayout: transition.bufferLayout,
        toBufferLayout: attribute.bufferLayout,
        getData: settings.enter
      });
      transition.bufferLayout = attribute.bufferLayout;
      return {
        fromState: fromState,
        toState: toState,
        buffer: buffer
      };
    }
  }, {
    key: "_triggerTransition",
    value: function _triggerTransition(transition, settings) {
      (0, _assert.default)(settings && settings.duration > 0);
      this.needsRedraw = true;
      var transitionSettings = Object.assign({}, DEFAULT_TRANSITION_SETTINGS, settings);
      transition.start(Object.assign({}, this._getNextTransitionStates(transition, settings), transitionSettings));
    }
  }]);
  return AttributeTransitionManager;
}();

exports.default = AttributeTransitionManager;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./attribute-transition-utils":"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute-transition-utils.js","./attribute":"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute.js","./base-attribute":"../../../node_modules/@deck.gl/core/dist/esm/lib/base-attribute.js","../transitions/transition":"../../../node_modules/@deck.gl/core/dist/esm/transitions/transition.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _attribute = _interopRequireDefault(require("./attribute"));

var _log = _interopRequireDefault(require("../utils/log"));

var _attributeTransitionManager = _interopRequireDefault(require("./attribute-transition-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_START_END_PRIORITY = 2;
var LOG_DETAIL_PRIORITY = 3;

function noop() {}

var logFunctions = {
  savedMessages: null,
  timeStart: null,
  onLog: function onLog(_ref) {
    var level = _ref.level,
        message = _ref.message;

    _log.default.log(level, message)();
  },
  onUpdateStart: function onUpdateStart(_ref2) {
    var level = _ref2.level,
        numInstances = _ref2.numInstances;
    logFunctions.savedMessages = [];
    logFunctions.timeStart = new Date();
  },
  onUpdate: function onUpdate(_ref3) {
    var level = _ref3.level,
        message = _ref3.message;

    if (logFunctions.savedMessages) {
      logFunctions.savedMessages.push(message);
    }
  },
  onUpdateEnd: function onUpdateEnd(_ref4) {
    var level = _ref4.level,
        id = _ref4.id,
        numInstances = _ref4.numInstances;
    var timeMs = Math.round(new Date() - logFunctions.timeStart);
    var time = "".concat(timeMs, "ms");

    _log.default.group(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time), {
      collapsed: true
    })();

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var message = _step.value;

        _log.default.log(level, message)();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    _log.default.groupEnd(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time))();

    logFunctions.savedMessages = null;
  }
};

var AttributeManager = function () {
  (0, _createClass2.default)(AttributeManager, null, [{
    key: "setDefaultLogFunctions",
    value: function setDefaultLogFunctions() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref5.onLog,
          onUpdateStart = _ref5.onUpdateStart,
          onUpdate = _ref5.onUpdate,
          onUpdateEnd = _ref5.onUpdateEnd;

      if (onLog !== undefined) {
        logFunctions.onLog = onLog || noop;
      }

      if (onUpdateStart !== undefined) {
        logFunctions.onUpdateStart = onUpdateStart || noop;
      }

      if (onUpdate !== undefined) {
        logFunctions.onUpdate = onUpdate || noop;
      }

      if (onUpdateEnd !== undefined) {
        logFunctions.onUpdateEnd = onUpdateEnd || noop;
      }
    }
  }]);

  function AttributeManager(gl) {
    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref6$id = _ref6.id,
        id = _ref6$id === void 0 ? 'attribute-manager' : _ref6$id,
        stats = _ref6.stats;

    (0, _classCallCheck2.default)(this, AttributeManager);
    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.accessors = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new _attributeTransitionManager.default(gl, {
      id: "".concat(id, "-transitions")
    });
    Object.seal(this);
  }

  (0, _createClass2.default)(AttributeManager, [{
    key: "finalize",
    value: function finalize() {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }

      this.attributeTransitionManager.finalize();
    }
  }, {
    key: "getNeedsRedraw",
    value: function getNeedsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      var redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
      return redraw && this.id;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.needsRedraw = true;
      return this;
    }
  }, {
    key: "add",
    value: function add(attributes, updaters) {
      this._add(attributes, updaters);
    }
  }, {
    key: "addInstanced",
    value: function addInstanced(attributes, updaters) {
      this._add(attributes, updaters, {
        instanced: 1
      });
    }
  }, {
    key: "remove",
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];

        if (this.attributes[name] !== undefined) {
          this.attributes[name].delete();
          delete this.attributes[name];
        }
      }
    }
  }, {
    key: "invalidate",
    value: function invalidate(triggerName, dataRange) {
      var invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);

      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: "invalidated attributes ".concat(invalidatedAttributes, " (").concat(triggerName, ") for ").concat(this.id)
      });
    }
  }, {
    key: "invalidateAll",
    value: function invalidateAll(dataRange) {
      for (var attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
      }

      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: "invalidated all attributes for ".concat(this.id)
      });
    }
  }, {
    key: "update",
    value: function update() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref7.data,
          numInstances = _ref7.numInstances,
          bufferLayout = _ref7.bufferLayout,
          transitions = _ref7.transitions,
          _ref7$props = _ref7.props,
          props = _ref7$props === void 0 ? {} : _ref7$props,
          _ref7$buffers = _ref7.buffers,
          buffers = _ref7$buffers === void 0 ? {} : _ref7$buffers,
          _ref7$context = _ref7.context,
          context = _ref7$context === void 0 ? {} : _ref7$context;

      var updated = false;
      logFunctions.onUpdateStart({
        level: LOG_START_END_PRIORITY,
        id: this.id,
        numInstances: numInstances
      });

      if (this.stats) {
        this.stats.get('Update Attributes').timeStart();
      }

      for (var attributeName in this.attributes) {
        var attribute = this.attributes[attributeName];

        if (attribute.setExternalBuffer(buffers[attributeName], this.numInstances)) {} else if (attribute.setGenericValue(props[attribute.getAccessor()])) {} else if (attribute.needsUpdate()) {
          updated = true;

          this._updateAttribute({
            attribute: attribute,
            numInstances: numInstances,
            bufferLayout: bufferLayout,
            data: data,
            props: props,
            context: context
          });
        }

        this.needsRedraw |= attribute.needsRedraw();
      }

      if (updated) {
        logFunctions.onUpdateEnd({
          level: LOG_START_END_PRIORITY,
          id: this.id,
          numInstances: numInstances
        });
      }

      if (this.stats) {
        this.stats.get('Update Attributes').timeEnd();
      }

      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances: numInstances,
        transitions: transitions
      });
    }
  }, {
    key: "updateTransition",
    value: function updateTransition(timestamp) {
      var attributeTransitionManager = this.attributeTransitionManager;
      var transitionUpdated = attributeTransitionManager.setCurrentTime(timestamp);
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.attributes;
    }
  }, {
    key: "getChangedAttributes",
    value: function getChangedAttributes() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearChangedFlags: false
      };
      var attributes = this.attributes,
          attributeTransitionManager = this.attributeTransitionManager;
      var changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
          changedAttributes[attributeName] = attribute;
        }
      }

      return changedAttributes;
    }
  }, {
    key: "getAccessors",
    value: function getAccessors() {
      return this.updateTriggers;
    }
  }, {
    key: "_add",
    value: function _add(attributes, updaters) {
      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (updaters) {
        _log.default.warn('AttributeManager.add({updaters}) - updater map no longer supported')();
      }

      var newAttributes = {};

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        var newAttribute = this._createAttribute(attributeName, attribute, extraProps);

        newAttributes[attributeName] = newAttribute;
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }
  }, {
    key: "_createAttribute",
    value: function _createAttribute(name, attribute, extraProps) {
      var props = {
        id: name,
        constant: attribute.constant || false,
        isIndexed: attribute.isIndexed || attribute.elements,
        size: attribute.elements && 1 || attribute.size,
        value: attribute.value || null,
        divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor
      };
      return new _attribute.default(this.gl, Object.assign({}, attribute, props));
    }
  }, {
    key: "_mapUpdateTriggersToAttributes",
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach(function (triggerName) {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }

          triggers[triggerName].push(attributeName);
        });
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: "_invalidateTrigger",
    value: function _invalidateTrigger(triggerName, dataRange) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;
      var invalidatedAttributes = updateTriggers[triggerName];

      if (invalidatedAttributes) {
        invalidatedAttributes.forEach(function (name) {
          var attribute = attributes[name];

          if (attribute) {
            attribute.setNeedsUpdate(attribute.id, dataRange);
          }
        });
      } else {
        var message = "invalidating non-existent trigger ".concat(triggerName, " for ").concat(this.id, "\n");
        message += "Valid triggers: ".concat(Object.keys(attributes).join(', '));

        _log.default.warn(message, invalidatedAttributes)();
      }

      return invalidatedAttributes;
    }
  }, {
    key: "_updateAttribute",
    value: function _updateAttribute(opts) {
      var attribute = opts.attribute,
          numInstances = opts.numInstances;

      if (attribute.allocate(numInstances)) {
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: "".concat(attribute.id, " allocated ").concat(numInstances),
          id: this.id
        });
      }

      var timeStart = Date.now();
      var updated = attribute.updateBuffer(opts);

      if (updated) {
        this.needsRedraw = true;
        var timeMs = Math.round(Date.now() - timeStart);
        logFunctions.onUpdate({
          level: LOG_DETAIL_PRIORITY,
          message: "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms")
        });
      }
    }
  }]);
  return AttributeManager;
}();

exports.default = AttributeManager;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./attribute":"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","./attribute-transition-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute-transition-manager.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/seer-integration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeLayerInSeer = exports.updateLayerInSeer = exports.initLayerInSeer = exports.seerInitListener = exports.layerEditListener = exports.applyPropOverrides = exports.setPropOverrides = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/toConsumableArray"));

var _seer = _interopRequireDefault(require("seer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var recursiveSet = function recursiveSet(obj, path, value) {
  if (!obj) {
    return;
  }

  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

var overrides = new Map();

var setPropOverrides = function setPropOverrides(id, valuePath, value) {
  if (!_seer.default.isReady()) {
    return;
  }

  if (!overrides.has(id)) {
    overrides.set(id, new Map());
  }

  var props = overrides.get(id);
  props.set(valuePath, value);
};

exports.setPropOverrides = setPropOverrides;

var applyPropOverrides = function applyPropOverrides(props) {
  if (!_seer.default.isReady() || !props.id) {
    return;
  }

  var overs = overrides.get(props.id);

  if (!overs) {
    return;
  }

  overs.forEach(function (value, valuePath) {
    recursiveSet(props, valuePath, value);

    if (valuePath[0] === 'data') {
      props.data = (0, _toConsumableArray2.default)(props.data);
    }
  });
};

exports.applyPropOverrides = applyPropOverrides;

var layerEditListener = function layerEditListener(cb) {
  if (!_seer.default.isReady()) {
    return;
  }

  _seer.default.listenFor('deck.gl', cb);
};

exports.layerEditListener = layerEditListener;

var seerInitListener = function seerInitListener(cb) {
  if (!_seer.default.isReady()) {
    return;
  }

  _seer.default.listenFor('init', cb);
};

exports.seerInitListener = seerInitListener;

var initLayerInSeer = function initLayerInSeer(layer) {
  if (!_seer.default.isReady() || !layer) {
    return;
  }

  var badges = [layer.constructor.layerName];

  _seer.default.listItem('deck.gl', layer.id, {
    badges: badges,
    links: layer.state && layer.state.model ? ["luma.gl:".concat(layer.state.model.id)] : undefined,
    parent: layer.parent ? layer.parent.id : undefined
  });
};

exports.initLayerInSeer = initLayerInSeer;

var updateLayerInSeer = function updateLayerInSeer(layer) {
  if (!_seer.default.isReady() || _seer.default.throttle("deck.gl:".concat(layer.id), 1e3)) {
    return;
  }

  var data = logPayload(layer);

  _seer.default.multiUpdate('deck.gl', layer.id, data);
};

exports.updateLayerInSeer = updateLayerInSeer;

var removeLayerInSeer = function removeLayerInSeer(id) {
  if (!_seer.default.isReady() || !id) {
    return;
  }

  _seer.default.deleteItem('deck.gl', id);
};

exports.removeLayerInSeer = removeLayerInSeer;

function logPayload(layer) {
  var data = [{
    path: 'objects.props',
    data: layer.props
  }];
  var badges = [layer.constructor.layerName];

  if (layer.state) {
    if (layer.getAttributeManager()) {
      var attrs = layer.getAttributeManager().getAttributes();
      data.push({
        path: 'objects.attributes',
        data: attrs
      });
    }

    if (layer.state.model) {
      layer.state.model.setProps({
        timerQueryEnabled: true
      });
      var lastFrameTime = layer.state.model.stats.lastFrameTime;

      if (lastFrameTime) {
        badges.push("".concat((lastFrameTime * 1000).toFixed(0), "\u03BCs"));
      }
    }
  }

  data.push({
    path: 'badges',
    data: badges
  });
  return data;
}
},{"@babel/runtime/helpers/esm/toConsumableArray":"../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","seer":"../../../node_modules/seer/dist/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateProps = validateProps;
exports.diffProps = diffProps;
exports.compareProps = compareProps;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validateProps(props) {
  var propTypes = getPropTypes(props);

  for (var propName in propTypes) {
    var propType = propTypes[propName];
    var validate = propType.validate;

    if (validate && !validate(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}

function diffProps(props, oldProps) {
  var propsChangedReason = compareProps({
    newProps: props,
    oldProps: oldProps,
    propTypes: getPropTypes(props),
    ignoreProps: {
      data: null,
      updateTriggers: null
    }
  });
  var dataChangedReason = diffDataProps(props, oldProps);
  var updateTriggersChangedReason = false;

  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }

  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason
  };
}

function compareProps() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      newProps = _ref.newProps,
      oldProps = _ref.oldProps,
      _ref$ignoreProps = _ref.ignoreProps,
      ignoreProps = _ref$ignoreProps === void 0 ? {} : _ref$ignoreProps,
      _ref$propTypes = _ref.propTypes,
      propTypes = _ref$propTypes === void 0 ? {} : _ref$propTypes,
      _ref$triggerName = _ref.triggerName,
      triggerName = _ref$triggerName === void 0 ? 'props' : _ref$triggerName;

  (0, _assert.default)(oldProps !== undefined && newProps !== undefined, 'compareProps args');

  if (oldProps === newProps) {
    return null;
  }

  if ((0, _typeof2.default)(newProps) !== 'object' || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }

  if ((0, _typeof2.default)(oldProps) !== 'object' || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }

  for (var key in oldProps) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return "".concat(triggerName, ".").concat(key, " dropped");
      }

      var newProp = newProps[key];
      var oldProp = oldProps[key];
      var propType = propTypes[key];
      var equal = propType && propType.equal;

      if (equal && !equal(newProp, oldProp, propType)) {
        return "".concat(triggerName, ".").concat(key, " changed deeply");
      }

      if (!equal) {
        equal = newProp && oldProp && newProp.equals;

        if (equal && !equal.call(newProp, oldProp)) {
          return "".concat(triggerName, ".").concat(key, " changed deeply");
        }
      }

      if (!equal && oldProp !== newProp) {
        return "".concat(triggerName, ".").concat(key, " changed shallowly");
      }
    }
  }

  for (var _key in newProps) {
    if (!(_key in ignoreProps)) {
      if (!(_key in oldProps)) {
        return "".concat(triggerName, ".").concat(_key, " added: undefined -> ").concat(newProps[_key]);
      }
    }
  }

  return null;
}

function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  var dataComparator = props.dataComparator;

  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      return 'Data comparator detected a change';
    }
  } else if (props.data !== oldProps.data) {
    return 'A new data container was supplied';
  }

  return null;
}

function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  if ('all' in props.updateTriggers) {
    var diffReason = diffUpdateTrigger(props, oldProps, 'all');

    if (diffReason) {
      return {
        all: true
      };
    }
  }

  var triggerChanged = {};
  var reason = false;

  for (var triggerName in props.updateTriggers) {
    if (triggerName !== 'all') {
      var _diffReason = diffUpdateTrigger(props, oldProps, triggerName);

      if (_diffReason) {
        triggerChanged[triggerName] = true;
        reason = triggerChanged;
      }
    }
  }

  return reason;
}

function diffUpdateTrigger(props, oldProps, triggerName) {
  var newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;
  var oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;
  var diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName: triggerName
  });
  return diffReason;
}

function getPropTypes(props) {
  var layer = props._component;
  var LayerType = layer && layer.constructor;
  return LayerType ? LayerType._propTypes : {};
}
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/utils/count.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.count = count;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_NOT_OBJECT = 'count(): argument not an object';
var ERR_NOT_CONTAINER = 'count(): argument not a container';

function count(container) {
  if (!isObject(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }

  if (typeof container.count === 'function') {
    return container.count();
  }

  if (Number.isFinite(container.size)) {
    return container.size;
  }

  if (Number.isFinite(container.length)) {
    return container.length;
  }

  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }

  throw new Error(ERR_NOT_CONTAINER);
}

function isPlainObject(value) {
  return value !== null && (0, _typeof2.default)(value) === 'object' && value.constructor === Object;
}

function isObject(value) {
  return value !== null && (0, _typeof2.default)(value) === 'object';
}
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LIFECYCLE = void 0;
var LIFECYCLE = {
  NO_STATE: 'Awaiting state',
  MATCHED: 'Matched. State transferred from previous layer',
  INITIALIZED: 'Initialized',
  AWAITING_GC: 'Discarded. Awaiting garbage collection',
  AWAITING_FINALIZATION: 'No longer matched. Awaiting garbage collection',
  FINALIZED: 'Finalized! Awaiting garbage collection'
};
exports.LIFECYCLE = LIFECYCLE;
},{}],"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TYPE_DEFINITIONS = {
  boolean: {
    validate: function validate(value, propType) {
      return true;
    },
    equal: function equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }
  },
  number: {
    validate: function validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }
  },
  color: {
    validate: function validate(value, propType) {
      return isArray(value) && (value.length === 3 || value.length === 4);
    },
    equal: function equal(value1, value2, propType) {
      return arrayEqual(value1, value2);
    }
  },
  accessor: {
    validate: function validate(value, propType) {
      var valueType = getTypeOf(value);
      return valueType === 'function' || valueType === getTypeOf(propType.value);
    },
    equal: function equal(value1, value2, propType) {
      if (typeof value2 === 'function') {
        return true;
      }

      return arrayEqual(value1, value2);
    }
  },
  array: {
    validate: function validate(value, propType) {
      return propType.optional && !value || isArray(value);
    },
    equal: function equal(value1, value2, propType) {
      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;
    }
  },
  function: {
    validate: function validate(value, propType) {
      return propType.optional && !value || typeof value === 'function';
    },
    equal: function equal(value1, value2, propType) {
      return !propType.compare || value1 === value2;
    }
  }
};

function arrayEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }

  if (!isArray(array1) || !isArray(array2)) {
    return false;
  }

  var len = array1.length;

  if (len !== array2.length) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}

function parsePropTypes(propDefs) {
  var propTypes = {};
  var defaultProps = {};
  var deprecatedProps = {};

  var _arr = Object.entries(propDefs);

  for (var _i = 0; _i < _arr.length; _i++) {
    var _arr$_i = (0, _slicedToArray2.default)(_arr[_i], 2),
        propName = _arr$_i[0],
        propDef = _arr$_i[1];

    if (propDef && propDef.deprecatedFor) {
      deprecatedProps[propName] = Array.isArray(propDef.deprecatedFor) ? propDef.deprecatedFor : [propDef.deprecatedFor];
    } else {
      var propType = parsePropType(propName, propDef);
      propTypes[propName] = propType;
      defaultProps[propName] = propType.value;
    }
  }

  return {
    propTypes: propTypes,
    defaultProps: defaultProps,
    deprecatedProps: deprecatedProps
  };
}

function parsePropType(name, propDef) {
  switch (getTypeOf(propDef)) {
    case 'object':
      return normalizePropDefinition(name, propDef);

    case 'array':
      return normalizePropDefinition(name, {
        type: 'array',
        value: propDef,
        compare: false
      });

    case 'boolean':
      return normalizePropDefinition(name, {
        type: 'boolean',
        value: propDef
      });

    case 'number':
      return normalizePropDefinition(name, {
        type: 'number',
        value: propDef
      });

    case 'function':
      return normalizePropDefinition(name, {
        type: 'function',
        value: propDef,
        compare: true
      });

    default:
      return {
        name: name,
        type: 'unknown',
        value: propDef
      };
  }
}

function normalizePropDefinition(name, propDef) {
  if (!('type' in propDef)) {
    if (!('value' in propDef)) {
      return {
        name: name,
        type: 'object',
        value: propDef
      };
    }

    return Object.assign({
      name: name,
      type: getTypeOf(propDef.value)
    }, propDef);
  }

  return Object.assign({
    name: name
  }, TYPE_DEFINITIONS[propDef.type], propDef);
}

function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}

function getTypeOf(value) {
  if (isArray(value)) {
    return 'array';
  }

  if (value === null) {
    return 'null';
  }

  return (0, _typeof2.default)(value);
}
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProps = createProps;

var _seerIntegration = require("../lib/seer-integration");

var _log = _interopRequireDefault(require("../utils/log"));

var _propTypes = require("./prop-types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createProps() {
  var component = this;
  var propTypeDefs = getPropsPrototypeAndTypes(component.constructor);
  var propsPrototype = propTypeDefs.defaultProps;
  var propsInstance = Object.create(propsPrototype, {
    _component: {
      enumerable: false,
      value: component
    },
    _asyncPropOriginalValues: {
      enumerable: false,
      value: {}
    },
    _asyncPropResolvedValues: {
      enumerable: false,
      value: {}
    }
  });

  for (var i = 0; i < arguments.length; ++i) {
    Object.assign(propsInstance, arguments[i]);
  }

  var layerName = component.constructor.layerName;
  var deprecatedProps = propTypeDefs.deprecatedProps;
  checkDeprecatedProps(layerName, propsInstance, deprecatedProps);
  checkDeprecatedProps(layerName, propsInstance.updateTriggers, deprecatedProps);
  checkDeprecatedProps(layerName, propsInstance.transitions, deprecatedProps);
  (0, _seerIntegration.applyPropOverrides)(propsInstance);
  Object.freeze(propsInstance);
  return propsInstance;
}

function checkDeprecatedProps(layerName, propsInstance, deprecatedProps) {
  if (!propsInstance) {
    return;
  }

  for (var name in deprecatedProps) {
    if (hasOwnProperty(propsInstance, name)) {
      var nameStr = "".concat(layerName || 'Layer', ": ").concat(name);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = deprecatedProps[name][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var newPropName = _step.value;

          if (!hasOwnProperty(propsInstance, newPropName)) {
            propsInstance[newPropName] = propsInstance[name];
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      _log.default.deprecated(nameStr, deprecatedProps[name].join('/'))();
    }
  }
}

function getPropsPrototypeAndTypes(componentClass) {
  var props = getOwnProperty(componentClass, '_mergedDefaultProps');

  if (props) {
    return {
      defaultProps: props,
      propTypes: getOwnProperty(componentClass, '_propTypes'),
      deprecatedProps: getOwnProperty(componentClass, '_deprecatedProps')
    };
  }

  return createPropsPrototypeAndTypes(componentClass);
}

function createPropsPrototypeAndTypes(componentClass) {
  var parent = componentClass.prototype;

  if (!parent) {
    return {
      defaultProps: {}
    };
  }

  var parentClass = Object.getPrototypeOf(componentClass);
  var parentPropDefs = parent && getPropsPrototypeAndTypes(parentClass) || null;
  var componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};
  var componentPropDefs = (0, _propTypes.parsePropTypes)(componentDefaultProps);
  var propTypes = Object.assign({}, parentPropDefs && parentPropDefs.propTypes, componentPropDefs.propTypes);
  var defaultProps = createPropsPrototype(componentPropDefs.defaultProps, parentPropDefs && parentPropDefs.defaultProps, propTypes, componentClass);
  var deprecatedProps = Object.assign({}, parentPropDefs && parentPropDefs.deprecatedProps, componentPropDefs.deprecatedProps);
  componentClass._mergedDefaultProps = defaultProps;
  componentClass._propTypes = propTypes;
  componentClass._deprecatedProps = deprecatedProps;
  return {
    propTypes: propTypes,
    defaultProps: defaultProps,
    deprecatedProps: deprecatedProps
  };
}

function createPropsPrototype(props, parentProps, propTypes, componentClass) {
  var defaultProps = Object.create(null);
  Object.assign(defaultProps, parentProps, props);
  var id = getComponentName(componentClass);
  delete props.id;
  Object.defineProperties(defaultProps, {
    id: {
      configurable: false,
      writable: true,
      value: id
    }
  });
  addAsyncPropsToPropPrototype(defaultProps, propTypes);
  return defaultProps;
}

function addAsyncPropsToPropPrototype(defaultProps, propTypes) {
  var defaultValues = {};
  var descriptors = {
    _asyncPropDefaultValues: {
      enumerable: false,
      value: defaultValues
    },
    _asyncPropOriginalValues: {
      enumerable: false,
      value: {}
    }
  };

  for (var propName in propTypes) {
    var propType = propTypes[propName];
    var name = propType.name,
        value = propType.value;

    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name, value);
    }
  }

  Object.defineProperties(defaultProps, descriptors);
}

function getDescriptorForAsyncProp(name) {
  return {
    configurable: false,
    enumerable: true,
    set: function set(newValue) {
      if (typeof newValue === 'string' || newValue instanceof Promise) {
        this._asyncPropOriginalValues[name] = newValue;
      } else {
        this._asyncPropResolvedValues[name] = newValue;
      }
    },
    get: function get() {
      if (this._asyncPropResolvedValues) {
        if (name in this._asyncPropResolvedValues) {
          var value = this._asyncPropResolvedValues[name];

          if (name === 'data') {
            return value || this._asyncPropDefaultValues[name];
          }

          return value;
        }

        if (name in this._asyncPropOriginalValues) {
          var state = this._component && this._component.internalState;

          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name);
          }
        }
      }

      return this._asyncPropDefaultValues[name];
    }
  };
}

function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}

function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}

function getComponentName(componentClass) {
  var componentName = getOwnProperty(componentClass, 'layerName') || getOwnProperty(componentClass, 'componentName');

  if (!componentName) {
    _log.default.once(0, "".concat(componentClass.name, ".componentName not specified"))();
  }

  return componentName || componentClass.name;
}
},{"../lib/seer-integration":"../../../node_modules/@deck.gl/core/dist/esm/lib/seer-integration.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","./prop-types":"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _log = _interopRequireDefault(require("../utils/log"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EMPTY_PROPS = Object.freeze({});

var ComponentState = function () {
  function ComponentState() {
    var component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, ComponentState);
    this.component = component;
    this.asyncProps = {};

    this.onAsyncPropUpdated = function () {};

    this.oldProps = EMPTY_PROPS;
    this.oldAsyncProps = null;
  }

  (0, _createClass2.default)(ComponentState, [{
    key: "getOldProps",
    value: function getOldProps() {
      return this.oldAsyncProps || this.oldProps;
    }
  }, {
    key: "resetOldProps",
    value: function resetOldProps() {
      this.oldAsyncProps = null;
      this.oldProps = this.component.props;
    }
  }, {
    key: "freezeAsyncOldProps",
    value: function freezeAsyncOldProps() {
      if (!this.oldAsyncProps) {
        this.oldProps = this.oldProps || this.component.props;
        this.oldAsyncProps = {};

        for (var propName in this.oldProps) {
          this.oldAsyncProps[propName] = this.oldProps[propName];
        }
      }
    }
  }, {
    key: "hasAsyncProp",
    value: function hasAsyncProp(propName) {
      return propName in this.asyncProps;
    }
  }, {
    key: "getAsyncProp",
    value: function getAsyncProp(propName) {
      var asyncProp = this.asyncProps[propName];
      return asyncProp && asyncProp.resolvedValue;
    }
  }, {
    key: "isAsyncPropLoading",
    value: function isAsyncPropLoading(propName) {
      var asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }
  }, {
    key: "setAsyncProps",
    value: function setAsyncProps(props) {
      var resolvedValues = props._asyncPropResolvedValues || {};
      var originalValues = props._asyncPropOriginalValues || props;
      var defaultValues = props._asyncPropDefaultValues || {};

      for (var propName in resolvedValues) {
        var value = resolvedValues[propName];

        this._createAsyncPropData(propName, value, defaultValues[propName]);

        this._updateAsyncProp(propName, value);
      }

      for (var _propName in originalValues) {
        var _value = originalValues[_propName];

        this._createAsyncPropData(_propName, _value, defaultValues[_propName]);

        this._updateAsyncProp(_propName, _value);
      }
    }
  }, {
    key: "_updateAsyncProp",
    value: function _updateAsyncProp(propName, value) {
      if (!this._didAsyncInputValueChange(propName, value)) {
        return;
      }

      if (typeof value === 'string') {
        var fetch = this.layer.props.fetch;
        var url = value;
        value = fetch(url, {
          propName: propName,
          layer: this.layer
        });
      }

      if (value instanceof Promise) {
        this._watchPromise(propName, value);

        return;
      }

      this._setPropValue(propName, value);
    }
  }, {
    key: "_didAsyncInputValueChange",
    value: function _didAsyncInputValueChange(propName, value) {
      var asyncProp = this.asyncProps[propName];

      if (value === asyncProp.lastValue) {
        return false;
      }

      asyncProp.lastValue = value;
      return true;
    }
  }, {
    key: "_setPropValue",
    value: function _setPropValue(propName, value) {
      var asyncProp = this.asyncProps[propName];
      asyncProp.value = value;
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }, {
    key: "_setAsyncPropValue",
    value: function _setAsyncPropValue(propName, value, loadCount) {
      var asyncProp = this.asyncProps[propName];

      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount) {
        (0, _assert.default)(value !== undefined);
        this.freezeAsyncOldProps();
        value = this._postProcessValue(propName, value);
        asyncProp.resolvedValue = value;
        asyncProp.resolvedLoadCount = loadCount;
        this.onAsyncPropUpdated(propName, value);
      }
    }
  }, {
    key: "_watchPromise",
    value: function _watchPromise(propName, promise) {
      var _this = this;

      var asyncProp = this.asyncProps[propName];
      asyncProp.pendingLoadCount++;
      var loadCount = asyncProp.pendingLoadCount;
      promise.then(function (data) {
        return _this._setAsyncPropValue(propName, data, loadCount);
      }).catch(function (error) {
        return _log.default.error(error)();
      });
    }
  }, {
    key: "_postProcessValue",
    value: function _postProcessValue(propName, value) {
      var _ref = this.component ? this.component.props : {},
          dataTransform = _ref.dataTransform;

      if (propName === 'data' && dataTransform) {
        value = dataTransform(value);
      }

      return value;
    }
  }, {
    key: "_createAsyncPropData",
    value: function _createAsyncPropData(propName, value, defaultValue) {
      var asyncProp = this.asyncProps[propName];

      if (!asyncProp) {
        this.asyncProps[propName] = {
          lastValue: null,
          resolvedValue: defaultValue,
          pendingLoadCount: 0,
          resolvedLoadCount: 0
        };
      }
    }
  }]);
  return ComponentState;
}();

exports.default = ComponentState;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/component.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _constants = require("../lifecycle/constants");

var _createProps = require("../lifecycle/create-props");

var _componentState = _interopRequireDefault(require("./component-state"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultProps = {};
var counter = 0;

var Component = function () {
  function Component() {
    (0, _classCallCheck2.default)(this, Component);
    this.props = _createProps.createProps.apply(this, arguments);
    this.id = this.props.id;
    this.count = counter++;
    this.lifecycle = _constants.LIFECYCLE.NO_STATE;
    this.parent = null;
    this.context = null;
    this.state = null;
    this.internalState = null;
    Object.seal(this);
  }

  (0, _createClass2.default)(Component, [{
    key: "clone",
    value: function clone(newProps) {
      var props = this.props;
      var asyncProps = {};

      for (var key in props._asyncPropDefaultValues) {
        if (key in props._asyncPropResolvedValues) {
          asyncProps[key] = props._asyncPropResolvedValues[key];
        } else if (key in props._asyncPropOriginalValues) {
          asyncProps[key] = props._asyncPropOriginalValues[key];
        }
      }

      return new this.constructor(Object.assign({}, props, asyncProps, newProps));
    }
  }, {
    key: "_initState",
    value: function _initState() {
      this.internalState = new _componentState.default({});
    }
  }, {
    key: "stats",
    get: function get() {
      return this.internalState.stats;
    }
  }]);
  return Component;
}();

exports.default = Component;
Component.componentName = 'Component';
Component.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../lifecycle/constants":"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","../lifecycle/create-props":"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js","./component-state":"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/layer-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _componentState = _interopRequireDefault(require("../lifecycle/component-state"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LayerState = function (_ComponentState) {
  (0, _inherits2.default)(LayerState, _ComponentState);

  function LayerState(_ref) {
    var _this;

    var attributeManager = _ref.attributeManager,
        layer = _ref.layer;
    (0, _classCallCheck2.default)(this, LayerState);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LayerState).call(this, layer));
    _this.attributeManager = attributeManager;
    _this.model = null;
    _this.needsRedraw = true;
    _this.subLayers = null;
    return _this;
  }

  (0, _createClass2.default)(LayerState, [{
    key: "layer",
    get: function get() {
      return this.component;
    },
    set: function set(layer) {
      this.component = layer;
    }
  }]);
  return LayerState;
}(_componentState.default);

exports.default = LayerState;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../lifecycle/component-state":"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _constants = require("./constants");

var _attributeManager = _interopRequireDefault(require("./attribute-manager"));

var _seerIntegration = require("./seer-integration");

var _props = require("../lifecycle/props");

var _count = require("../utils/count");

var _log = _interopRequireDefault(require("../utils/log"));

var _core = require("@luma.gl/core");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _projectFunctions = require("../shaderlib/project/project-functions");

var _component = _interopRequireDefault(require("../lifecycle/component"));

var _layerState = _interopRequireDefault(require("./layer-state"));

var _viewportMercatorProject = require("viewport-mercator-project");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_PRIORITY_UPDATE = 1;
var EMPTY_ARRAY = Object.freeze([]);
var pickingColorCache = new Uint8ClampedArray(0);
var defaultProps = {
  data: {
    type: 'data',
    value: EMPTY_ARRAY,
    async: true
  },
  dataComparator: null,
  dataTransform: {
    type: 'function',
    value: function value(data) {
      return data;
    },
    compare: false
  },
  fetch: {
    type: 'function',
    value: function value(url) {
      return fetch(url).then(function (response) {
        return response.json();
      });
    },
    compare: false
  },
  updateTriggers: {},
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0.8
  },
  onHover: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onClick: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDragStart: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDrag: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDragEnd: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  coordinateSystem: _constants.COORDINATE_SYSTEM.LNGLAT,
  coordinateOrigin: {
    type: 'array',
    value: [0, 0, 0],
    compare: true
  },
  modelMatrix: {
    type: 'array',
    value: null,
    compare: true,
    optional: true
  },
  wrapLongitude: false,
  parameters: {},
  uniforms: {},
  framebuffer: null,
  animation: null,
  getPolygonOffset: {
    type: 'function',
    value: function value(_ref) {
      var layerIndex = _ref.layerIndex;
      return [0, -layerIndex * 100];
    },
    compare: false
  },
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: {
    type: 'color',
    value: [0, 0, 128, 128]
  }
};

var Layer = function (_Component) {
  (0, _inherits2.default)(Layer, _Component);

  function Layer() {
    (0, _classCallCheck2.default)(this, Layer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Layer).apply(this, arguments));
  }

  (0, _createClass2.default)(Layer, [{
    key: "toString",
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return "".concat(className, "({id: '").concat(this.props.id, "'})");
    }
  }, {
    key: "setState",
    value: function setState(updateObject) {
      this.setChangeFlags({
        stateChanged: true
      });
      Object.assign(this.state, updateObject);
      this.setNeedsRedraw();
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.internalState) {
        this.internalState.needsRedraw = redraw;
      }
    }
  }, {
    key: "setLayerNeedsUpdate",
    value: function setLayerNeedsUpdate() {
      this.context.layerManager.setNeedsUpdate(String(this));
    }
  }, {
    key: "getNeedsRedraw",
    value: function getNeedsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      return this._getNeedsRedraw(opts);
    }
  }, {
    key: "needsUpdate",
    value: function needsUpdate() {
      return this.shouldUpdateState(this._getUpdateParams());
    }
  }, {
    key: "isPickable",
    value: function isPickable() {
      return this.props.pickable && this.props.visible;
    }
  }, {
    key: "getModels",
    value: function getModels() {
      return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
    }
  }, {
    key: "getSingleModel",
    value: function getSingleModel() {
      return this.state && this.state.model;
    }
  }, {
    key: "getAttributeManager",
    value: function getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
  }, {
    key: "getCurrentLayer",
    value: function getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
  }, {
    key: "getFirstObject",
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }
  }, {
    key: "project",
    value: function project(xyz) {
      var viewport = this.context.viewport;
      var worldPosition = (0, _projectFunctions.getWorldPosition)(xyz, {
        viewport: viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });

      var _worldToPixels = (0, _viewportMercatorProject.worldToPixels)(worldPosition, viewport.pixelProjectionMatrix),
          _worldToPixels2 = (0, _slicedToArray2.default)(_worldToPixels, 3),
          x = _worldToPixels2[0],
          y = _worldToPixels2[1],
          z = _worldToPixels2[2];

      return xyz.length === 2 ? [x, y] : [x, y, z];
    }
  }, {
    key: "unproject",
    value: function unproject(xy) {
      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(xy));
      return viewport.unproject(xy);
    }
  }, {
    key: "projectPosition",
    value: function projectPosition(xyz) {
      (0, _assert.default)(Array.isArray(xyz));
      return (0, _projectFunctions.projectPosition)(xyz, {
        viewport: this.context.viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(lngLat) {
      _log.default.deprecated('layer.projectFlat', 'layer.projectPosition')();

      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(lngLat));
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xy) {
      _log.default.deprecated('layer.unprojectFlat')();

      var viewport = this.context.viewport;
      (0, _assert.default)(Array.isArray(xy));
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: "use64bitProjection",
    value: function use64bitProjection() {
      if (this.props.fp64) {
        if (this.props.coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT_DEPRECATED) {
          return true;
        }

        _log.default.once(0, "Legacy 64-bit mode only works with coordinateSystem set to\n        COORDINATE_SYSTEM.LNGLAT_DEPRECATED. Rendering in 32-bit mode instead")();
      }

      return false;
    }
  }, {
    key: "use64bitPositions",
    value: function use64bitPositions() {
      return this.props.fp64 || this.props.coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || this.props.coordinateSystem === _constants.COORDINATE_SYSTEM.IDENTITY;
    }
  }, {
    key: "screenToDevicePixels",
    value: function screenToDevicePixels(screenPixels) {
      _log.default.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion')();

      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }
  }, {
    key: "onHover",
    value: function onHover(info, pickingEvent) {
      if (this.props.onHover) {
        return this.props.onHover(info, pickingEvent);
      }

      return false;
    }
  }, {
    key: "onClick",
    value: function onClick(info, pickingEvent) {
      if (this.props.onClick) {
        return this.props.onClick(info, pickingEvent);
      }

      return false;
    }
  }, {
    key: "nullPickingColor",
    value: function nullPickingColor() {
      return [0, 0, 0];
    }
  }, {
    key: "encodePickingColor",
    value: function encodePickingColor(i) {
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      (0, _assert.default)(i < 16777215, 'index out of picking color range');
      target[0] = i + 1 & 255;
      target[1] = i + 1 >> 8 & 255;
      target[2] = i + 1 >> 8 >> 8 & 255;
      return target;
    }
  }, {
    key: "decodePickingColor",
    value: function decodePickingColor(color) {
      (0, _assert.default)(color instanceof Uint8Array);

      var _color = (0, _slicedToArray2.default)(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];

      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      throw new Error("Layer ".concat(this, " has not defined initializeState"));
    }
  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          context = _ref2.context,
          changeFlags = _ref2.changeFlags;
      return changeFlags.propsOrDataChanged;
    }
  }, {
    key: "updateState",
    value: function updateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;
      var attributeManager = this.getAttributeManager();

      if (changeFlags.dataChanged && attributeManager) {
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.getModels()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var model = _step2.value;
          model.delete();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var attributeManager = this.getAttributeManager();

      if (attributeManager) {
        attributeManager.finalize();
      }
    }
  }, {
    key: "draw",
    value: function draw(opts) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var model = _step3.value;
          model.draw(opts);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref4) {
      var info = _ref4.info,
          mode = _ref4.mode;
      var index = info.index;

      if (index >= 0) {
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      return info;
    }
  }, {
    key: "invalidateAttribute",
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var attributeManager = this.getAttributeManager();

      if (!attributeManager) {
        return;
      }

      if (name === 'all') {
        _log.default.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating all attributes: ".concat(diffReason))();

        attributeManager.invalidateAll();
      } else {
        _log.default.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating attribute ".concat(name, ": ").concat(diffReason))();

        attributeManager.invalidate(name);
      }
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(props) {
      var attributeManager = this.getAttributeManager();

      if (!attributeManager) {
        return;
      }

      var numInstances = this.getNumInstances(props);
      var bufferLayout = this.getBufferLayout(props);
      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        bufferLayout: bufferLayout,
        props: props,
        transitions: props.transitions,
        buffers: props,
        context: this,
        ignoreUnknownAttributes: true
      });
      var models = this.getModels();

      if (models.length > 0) {
        var changedAttributes = attributeManager.getChangedAttributes({
          clearChangedFlags: true
        });

        for (var i = 0, len = models.length; i < len; ++i) {
          this._setModelAttributes(models[i], changedAttributes);
        }
      }
    }
  }, {
    key: "updateTransition",
    value: function updateTransition() {
      var attributeManager = this.getAttributeManager();

      if (attributeManager) {
        attributeManager.updateTransition(this.context.time);
      }
    }
  }, {
    key: "calculateInstancePickingColors",
    value: function calculateInstancePickingColors(attribute, _ref5) {
      var numInstances = _ref5.numInstances;
      var value = attribute.value,
          size = attribute.size;

      if (value[0] === 1) {
        return;
      }

      var cacheSize = pickingColorCache.length / size;

      if (cacheSize < numInstances) {
        var newPickingColorCache = new Uint8ClampedArray(numInstances * size);
        newPickingColorCache.set(pickingColorCache);
        var pickingColor = [];

        for (var i = cacheSize; i < numInstances; i++) {
          this.encodePickingColor(i, pickingColor);
          newPickingColorCache[i * size + 0] = pickingColor[0];
          newPickingColorCache[i * size + 1] = pickingColor[1];
          newPickingColorCache[i * size + 2] = pickingColor[2];
        }

        pickingColorCache = newPickingColorCache;
      }

      value.set(numInstances < cacheSize ? pickingColorCache.subarray(0, numInstances * size) : pickingColorCache);
    }
  }, {
    key: "_setModelAttributes",
    value: function _setModelAttributes(model, changedAttributes) {
      var shaderAttributes = {};
      var excludeAttributes = model.userData.excludeAttributes || {};

      for (var attributeName in changedAttributes) {
        if (!excludeAttributes[attributeName]) {
          Object.assign(shaderAttributes, changedAttributes[attributeName].getShaderAttributes());
        }
      }

      model.setAttributes(shaderAttributes);
    }
  }, {
    key: "_clearInstancePickingColor",
    value: function _clearInstancePickingColor(color) {
      var instancePickingColors = this.getAttributeManager().attributes.instancePickingColors;
      var value = instancePickingColors.value,
          size = instancePickingColors.size;
      var i = this.decodePickingColor(color);
      value[i * size + 0] = 0;
      value[i * size + 1] = 0;
      value[i * size + 2] = 0;
      instancePickingColors.update({
        value: value
      });
    }
  }, {
    key: "_clearPickingColor",
    value: function _clearPickingColor(color) {
      var pickingColors = this.getAttributeManager().attributes.pickingColors;
      var value = pickingColors.value;

      for (var i = 0; i < value.length; i += 3) {
        if (value[i + 0] === color[0] && value[i + 1] === color[1] && value[i + 2] === color[2]) {
          value[i + 0] = 0;
          value[i + 1] = 0;
          value[i + 2] = 0;
        }
      }

      pickingColors.update({
        value: value
      });
    }
  }, {
    key: "clearPickingColor",
    value: function clearPickingColor(color) {
      if (this.getAttributeManager().attributes.pickingColors) {
        this._clearPickingColor(color);
      } else {
        this._clearInstancePickingColor(color);
      }
    }
  }, {
    key: "copyPickingColors",
    value: function copyPickingColors() {
      var _this$getAttributeMan = this.getAttributeManager().attributes,
          pickingColors = _this$getAttributeMan.pickingColors,
          instancePickingColors = _this$getAttributeMan.instancePickingColors;
      var colors = pickingColors || instancePickingColors;
      return new Uint8ClampedArray(colors.value);
    }
  }, {
    key: "restorePickingColors",
    value: function restorePickingColors(value) {
      var _this$getAttributeMan2 = this.getAttributeManager().attributes,
          pickingColors = _this$getAttributeMan2.pickingColors,
          instancePickingColors = _this$getAttributeMan2.instancePickingColors;
      var colors = pickingColors || instancePickingColors;
      colors.update({
        value: value
      });
    }
  }, {
    key: "getNumInstances",
    value: function getNumInstances(props) {
      props = props || this.props;

      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      var data = this.props.data;
      return (0, _count.count)(data);
    }
  }, {
    key: "getBufferLayout",
    value: function getBufferLayout(props) {
      props = props || this.props;

      if (props.bufferLayout !== undefined) {
        return props.bufferLayout;
      }

      if (this.state && this.state.bufferLayout !== undefined) {
        return this.state.bufferLayout;
      }

      return null;
    }
  }, {
    key: "_initialize",
    value: function _initialize() {
      this._initState();

      this.initializeState(this.context);
      this.state.attributeManager = this.getAttributeManager();
      this.setChangeFlags({
        dataChanged: true,
        propsChanged: true,
        viewportChanged: true
      });

      this._updateState();

      var model = this.getSingleModel();

      if (model) {
        model.id = this.props.id;
        model.program.id = "".concat(this.props.id, "-program");
      }
    }
  }, {
    key: "_update",
    value: function _update() {
      var stateNeedsUpdate = this.needsUpdate();

      if (stateNeedsUpdate) {
        this._updateState();
      }
    }
  }, {
    key: "_updateState",
    value: function _updateState() {
      var updateParams = this._getUpdateParams();

      if (this.context.gl) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {}
      }

      if (this.isComposite) {
        this._renderLayers(updateParams);
      } else {
        this.setNeedsRedraw();
        this.updateAttributes(this.props);

        this._updateBaseUniforms();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }

      this.clearChangeFlags();
      this.internalState.resetOldProps();
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      (0, _assert.default)(this.internalState && this.state);
      this.finalizeState(this.context);
      (0, _seerIntegration.removeLayerInSeer)(this.id);
    }
  }, {
    key: "drawLayer",
    value: function drawLayer(_ref6) {
      var _this = this;

      var _ref6$moduleParameter = _ref6.moduleParameters,
          moduleParameters = _ref6$moduleParameter === void 0 ? null : _ref6$moduleParameter,
          _ref6$uniforms = _ref6.uniforms,
          uniforms = _ref6$uniforms === void 0 ? {} : _ref6$uniforms,
          _ref6$parameters = _ref6.parameters,
          parameters = _ref6$parameters === void 0 ? {} : _ref6$parameters;

      if (!uniforms.picking_uActive) {
        this.updateTransition();
      }

      if (moduleParameters) {
        this.setModuleParameters(moduleParameters);
      }

      var animationProps = this.context.animationProps;

      if (animationProps) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var model = _step4.value;

            model._setAnimationProps(animationProps);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      var getPolygonOffset = this.props.getPolygonOffset;
      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      parameters.polygonOffset = offsets;
      (0, _core.withParameters)(this.context.gl, parameters, function () {
        _this.draw({
          moduleParameters: moduleParameters,
          uniforms: uniforms,
          parameters: parameters,
          context: _this.context
        });
      });
    }
  }, {
    key: "pickLayer",
    value: function pickLayer(opts) {
      return this.getPickingInfo(opts);
    }
  }, {
    key: "getChangeFlags",
    value: function getChangeFlags() {
      return this.internalState.changeFlags;
    }
  }, {
    key: "setChangeFlags",
    value: function setChangeFlags(flags) {
      var _this2 = this;

      this.internalState.changeFlags = this.internalState.changeFlags || {};
      var changeFlags = this.internalState.changeFlags;

      if (flags.dataChanged && !changeFlags.dataChanged) {
        changeFlags.dataChanged = flags.dataChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "dataChanged: ".concat(flags.dataChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {
        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return 'updateTriggersChanged: ' + "".concat(Object.keys(flags.updateTriggersChanged).join(', '), " in ").concat(_this2.id);
        })();
      }

      if (flags.propsChanged && !changeFlags.propsChanged) {
        changeFlags.propsChanged = flags.propsChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "propsChanged: ".concat(flags.propsChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.viewportChanged && !changeFlags.viewportChanged) {
        changeFlags.viewportChanged = flags.viewportChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 2, function () {
          return "viewportChanged: ".concat(flags.viewportChanged, " in ").concat(_this2.id);
        })();
      }

      if (flags.stateChanged && !changeFlags.stateChanged) {
        changeFlags.stateChanged = flags.stateChanged;

        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
          return "stateChanged: ".concat(flags.stateChanged, " in ").concat(_this2.id);
        })();
      }

      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged;
      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;
      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged || flags.stateChanged;
    }
  }, {
    key: "clearChangeFlags",
    value: function clearChangeFlags() {
      this.internalState.changeFlags = {
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
  }, {
    key: "printChangeFlags",
    value: function printChangeFlags() {
      var flags = this.internalState.changeFlags;
      return "".concat(flags.dataChanged ? 'data ' : '').concat(flags.propsChanged ? 'props ' : '').concat(flags.updateTriggersChanged ? 'triggers ' : '').concat(flags.viewportChanged ? 'viewport' : '');
    }
  }, {
    key: "diffProps",
    value: function diffProps(newProps, oldProps) {
      var changeFlags = (0, _props.diffProps)(newProps, oldProps);

      if (changeFlags.updateTriggersChanged) {
        for (var key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this._activeUpdateTrigger(key);
          }
        }
      }

      return this.setChangeFlags(changeFlags);
    }
  }, {
    key: "validateProps",
    value: function validateProps() {
      (0, _props.validateProps)(this.props);
    }
  }, {
    key: "setModuleParameters",
    value: function setModuleParameters(moduleParameters) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var model = _step5.value;
          model.updateModuleSettings(moduleParameters);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: "_getUpdateParams",
    value: function _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        changeFlags: this.internalState.changeFlags
      };
    }
  }, {
    key: "_getNeedsRedraw",
    value: function _getNeedsRedraw(opts) {
      if (!this.internalState) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.internalState.needsRedraw && this.id;
      this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
      var attributeManager = this.getAttributeManager();
      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw(opts);
      redraw = redraw || attributeManagerNeedsRedraw;
      return redraw;
    }
  }, {
    key: "_getAttributeManager",
    value: function _getAttributeManager() {
      return new _attributeManager.default(this.context.gl, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  }, {
    key: "_initState",
    value: function _initState() {
      (0, _assert.default)(!this.internalState && !this.state);

      var attributeManager = this._getAttributeManager();

      if (attributeManager) {
        attributeManager.addInstanced({
          instancePickingColors: {
            type: 5121,
            size: 3,
            update: this.calculateInstancePickingColors
          }
        });
      }

      this.internalState = new _layerState.default({
        attributeManager: attributeManager,
        layer: this
      });
      this.state = {};
      this.state.attributeManager = attributeManager;
      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
      this.internalState.setAsyncProps(this.props);
    }
  }, {
    key: "_transferState",
    value: function _transferState(oldLayer) {
      var state = oldLayer.state,
          internalState = oldLayer.internalState;
      (0, _assert.default)(state && internalState);

      if (this === oldLayer) {
        return;
      }

      this.internalState = internalState;
      this.internalState.component = this;
      this.state = state;
      state.layer = this;
      this.internalState.setAsyncProps(this.props);
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var model = _step6.value;
          model.userData.layer = this;
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      this.diffProps(this.props, this.internalState.getOldProps());
    }
  }, {
    key: "_onAsyncPropUpdated",
    value: function _onAsyncPropUpdated() {
      this.diffProps(this.props, this.internalState.getOldProps());
      this.setLayerNeedsUpdate();
    }
  }, {
    key: "_activeUpdateTrigger",
    value: function _activeUpdateTrigger(propName) {
      this.invalidateAttribute(propName);
    }
  }, {
    key: "_updateBaseUniforms",
    value: function _updateBaseUniforms() {
      var _this3 = this;

      var uniforms = {
        opacity: typeof this.props.opacity === 'function' ? function (animationProps) {
          return Math.pow(_this3.props.opacity(animationProps), 1 / 2.2);
        } : Math.pow(this.props.opacity, 1 / 2.2)
      };
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var model = _step7.value;
          model.setUniforms(uniforms);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(uniformMap) {
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = this.getModels()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var model = _step8.value;
          model.setUniforms(uniformMap);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      this.setNeedsRedraw();

      _log.default.deprecated('layer.setUniforms', 'model.setUniforms')();
    }
  }, {
    key: "is64bitEnabled",
    value: function is64bitEnabled() {
      _log.default.deprecated('is64bitEnabled', 'use64bitProjection')();

      return this.use64bitProjection();
    }
  }]);
  return Layer;
}(_component.default);

exports.default = Layer;
Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./constants":"../../../node_modules/@deck.gl/core/dist/esm/lib/constants.js","./attribute-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute-manager.js","./seer-integration":"../../../node_modules/@deck.gl/core/dist/esm/lib/seer-integration.js","../lifecycle/props":"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/props.js","../utils/count":"../../../node_modules/@deck.gl/core/dist/esm/utils/count.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js","../shaderlib/project/project-functions":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js","../lifecycle/component":"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/component.js","./layer-state":"../../../node_modules/@deck.gl/core/dist/esm/lib/layer-state.js","viewport-mercator-project":"../../../node_modules/viewport-mercator-project/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _layer = _interopRequireDefault(require("./layer"));

var _log = _interopRequireDefault(require("../utils/log"));

var _flatten = require("../utils/flatten");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CompositeLayer = function (_Layer) {
  (0, _inherits2.default)(CompositeLayer, _Layer);

  function CompositeLayer() {
    (0, _classCallCheck2.default)(this, CompositeLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CompositeLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(CompositeLayer, [{
    key: "getSubLayers",
    value: function getSubLayers() {
      return this.internalState && this.internalState.subLayers || [];
    }
  }, {
    key: "initializeState",
    value: function initializeState() {}
  }, {
    key: "setState",
    value: function setState(updateObject) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(CompositeLayer.prototype), "setState", this).call(this, updateObject);
      this.setLayerNeedsUpdate();
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref) {
      var info = _ref.info;
      return info;
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      return null;
    }
  }, {
    key: "shouldRenderSubLayer",
    value: function shouldRenderSubLayer(id, data) {
      var overridingProps = this.props._subLayerProps;
      return data && data.length || overridingProps && overridingProps[id];
    }
  }, {
    key: "getSubLayerClass",
    value: function getSubLayerClass(id, DefaultLayerClass) {
      var overridingProps = this.props._subLayerProps;
      return overridingProps && overridingProps[id] && overridingProps[id].type || DefaultLayerClass;
    }
  }, {
    key: "getSubLayerProps",
    value: function getSubLayerProps(sublayerProps) {
      var _this$props = this.props,
          opacity = _this$props.opacity,
          pickable = _this$props.pickable,
          visible = _this$props.visible,
          parameters = _this$props.parameters,
          getPolygonOffset = _this$props.getPolygonOffset,
          highlightedObjectIndex = _this$props.highlightedObjectIndex,
          autoHighlight = _this$props.autoHighlight,
          highlightColor = _this$props.highlightColor,
          coordinateSystem = _this$props.coordinateSystem,
          coordinateOrigin = _this$props.coordinateOrigin,
          wrapLongitude = _this$props.wrapLongitude,
          positionFormat = _this$props.positionFormat,
          modelMatrix = _this$props.modelMatrix,
          overridingProps = _this$props._subLayerProps;
      var newProps = {
        opacity: opacity,
        pickable: pickable,
        visible: visible,
        parameters: parameters,
        getPolygonOffset: getPolygonOffset,
        highlightedObjectIndex: highlightedObjectIndex,
        autoHighlight: autoHighlight,
        highlightColor: highlightColor,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin,
        wrapLongitude: wrapLongitude,
        positionFormat: positionFormat,
        modelMatrix: modelMatrix
      };

      if (sublayerProps) {
        var overridingSublayerProps = overridingProps && overridingProps[sublayerProps.id];
        var overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
        Object.assign(newProps, sublayerProps, overridingSublayerProps, {
          id: "".concat(this.props.id, "-").concat(sublayerProps.id),
          updateTriggers: Object.assign({
            all: this.props.updateTriggers.all
          }, sublayerProps.updateTriggers, overridingSublayerTriggers)
        });
      }

      return newProps;
    }
  }, {
    key: "_getAttributeManager",
    value: function _getAttributeManager() {
      return null;
    }
  }, {
    key: "_renderLayers",
    value: function _renderLayers() {
      var subLayers = this.internalState.subLayers;

      if (subLayers && !this.needsUpdate()) {
        _log.default.log(3, "Composite layer reused subLayers ".concat(this), this.internalState.subLayers)();
      } else {
        subLayers = this.renderLayers();
        subLayers = (0, _flatten.flatten)(subLayers, {
          filter: Boolean
        });
        this.internalState.subLayers = subLayers;

        _log.default.log(2, "Composite layer rendered new subLayers ".concat(this), subLayers)();
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = subLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;
          layer.parent = this;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "isComposite",
    get: function get() {
      return true;
    }
  }]);
  return CompositeLayer;
}(_layer.default);

exports.default = CompositeLayer;
CompositeLayer.layerName = 'CompositeLayer';
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./layer":"../../../node_modules/@deck.gl/core/dist/esm/lib/layer.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/flatten":"../../../node_modules/@deck.gl/core/dist/esm/utils/flatten.js"}],"../../../node_modules/@deck.gl/core/dist/esm/utils/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformVector = transformVector;
exports.createMat4 = createMat4;
exports.extractCameraVectors = extractCameraVectors;
exports.mod = mod;

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function transformVector(matrix, vector) {
  if (!matrix) {
    return null;
  }

  var result = vec4.transformMat4([0, 0, 0, 0], vector, matrix);
  var scale = 1 / result[3];
  vec4.multiply(result, result, [scale, scale, scale, scale]);
  return result;
}

function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

function extractCameraVectors(_ref) {
  var viewMatrix = _ref.viewMatrix,
      viewMatrixInverse = _ref.viewMatrixInverse;
  return {
    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],
    direction: [viewMatrix[2], viewMatrix[6], viewMatrix[10]],
    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]]
  };
}

function mod(value, divisor) {
  (0, _assert.default)(Number.isFinite(value) && Number.isFinite(divisor));
  var modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
},{"gl-matrix/vec4":"../../../node_modules/gl-matrix/esm/vec4.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _log = _interopRequireDefault(require("../utils/log"));

var _mathUtils = require("../utils/math-utils");

var _math = require("math.gl");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var _viewportMercatorProject = require("viewport-mercator-project");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEGREES_TO_RADIANS = Math.PI / 180;
var IDENTITY = (0, _mathUtils.createMat4)();
var ZERO_VECTOR = [0, 0, 0];
var DEFAULT_ZOOM = 0;
var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  function Viewport() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Viewport);
    var _opts$id = opts.id,
        id = _opts$id === void 0 ? null : _opts$id,
        _opts$x = opts.x,
        x = _opts$x === void 0 ? 0 : _opts$x,
        _opts$y = opts.y,
        y = _opts$y === void 0 ? 0 : _opts$y,
        _opts$width = opts.width,
        width = _opts$width === void 0 ? 1 : _opts$width,
        _opts$height = opts.height,
        height = _opts$height === void 0 ? 1 : _opts$height;
    this.id = id || this.constructor.displayName || 'viewport';
    this.x = x;
    this.y = y;
    this.width = width || 1;
    this.height = height || 1;

    this._initViewMatrix(opts);

    this._initProjectionMatrix(opts);

    this._initPixelMatrices();

    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
  }

  (0, _createClass2.default)(Viewport, [{
    key: "equals",
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix);
    }
  }, {
    key: "project",
    value: function project(xyz) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$topLeft = _ref.topLeft,
          topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft;

      var worldPosition = this.projectPosition(xyz);
      var coord = (0, _viewportMercatorProject.worldToPixels)(worldPosition, this.pixelProjectionMatrix);

      var _coord = (0, _slicedToArray2.default)(coord, 2),
          x = _coord[0],
          y = _coord[1];

      var y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
    }
  }, {
    key: "unproject",
    value: function unproject(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft,
          targetZ = _ref2.targetZ;

      var _xyz = (0, _slicedToArray2.default)(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          z = _xyz[2];

      var y2 = topLeft ? y : this.height - y;
      var targetZWorld = targetZ && targetZ * this.distanceScales.pixelsPerMeter[2];
      var coord = (0, _viewportMercatorProject.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);

      var _this$unprojectPositi = this.unprojectPosition(coord),
          _this$unprojectPositi2 = (0, _slicedToArray2.default)(_this$unprojectPositi, 3),
          X = _this$unprojectPositi2[0],
          Y = _this$unprojectPositi2[1],
          Z = _this$unprojectPositi2[2];

      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }

      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
  }, {
    key: "projectPosition",
    value: function projectPosition(xyz) {
      var _this$projectFlat = this.projectFlat(xyz),
          _this$projectFlat2 = (0, _slicedToArray2.default)(_this$projectFlat, 2),
          X = _this$projectFlat2[0],
          Y = _this$projectFlat2[1];

      var Z = (xyz[2] || 0) * this.distanceScales.pixelsPerMeter[2];
      return [X, Y, Z];
    }
  }, {
    key: "unprojectPosition",
    value: function unprojectPosition(xyz) {
      var _this$unprojectFlat = this.unprojectFlat(xyz),
          _this$unprojectFlat2 = (0, _slicedToArray2.default)(_this$unprojectFlat, 2),
          X = _this$unprojectFlat2[0],
          Y = _this$unprojectFlat2[1];

      var Z = (xyz[2] || 0) * this.distanceScales.metersPerPixel[2];
      return [X, Y, Z];
    }
  }, {
    key: "projectFlat",
    value: function projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      if (this.isGeospatial) {
        return (0, _viewportMercatorProject.lngLatToWorld)(xyz, scale);
      }

      var pixelsPerMeter = this.distanceScales.pixelsPerMeter;
      return [xyz[0] * pixelsPerMeter[0], xyz[1] * pixelsPerMeter[1]];
    }
  }, {
    key: "unprojectFlat",
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      if (this.isGeospatial) {
        return (0, _viewportMercatorProject.worldToLngLat)(xyz, scale);
      }

      var metersPerPixel = this.distanceScales.metersPerPixel;
      return [xyz[0] * metersPerPixel[0], xyz[1] * metersPerPixel[1]];
    }
  }, {
    key: "getDistanceScales",
    value: function getDistanceScales() {
      var coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (coordinateOrigin) {
        return (0, _viewportMercatorProject.getDistanceScales)({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          scale: this.scale,
          highPrecision: true
        });
      }

      return this.distanceScales;
    }
  }, {
    key: "getMatrices",
    value: function getMatrices() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$modelMatrix = _ref3.modelMatrix,
          modelMatrix = _ref3$modelMatrix === void 0 ? null : _ref3$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = mat4.multiply([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = mat4.multiply([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = mat4.invert([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,
        width: this.width,
        height: this.height,
        scale: this.scale
      });
      return matrices;
    }
  }, {
    key: "containsPixel",
    value: function containsPixel(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          _ref4$width = _ref4.width,
          width = _ref4$width === void 0 ? 1 : _ref4$width,
          _ref4$height = _ref4.height,
          height = _ref4$height === void 0 ? 1 : _ref4$height;
      return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
    }
  }, {
    key: "getCameraPosition",
    value: function getCameraPosition() {
      return this.cameraPosition;
    }
  }, {
    key: "getCameraDirection",
    value: function getCameraDirection() {
      return this.cameraDirection;
    }
  }, {
    key: "getCameraUp",
    value: function getCameraUp() {
      return this.cameraUp;
    }
  }, {
    key: "_addMetersToLngLat",
    value: function _addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = (0, _slicedToArray2.default)(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;

      var _this$_metersToLngLat = this._metersToLngLatDelta(xyz),
          _this$_metersToLngLat2 = (0, _slicedToArray2.default)(_this$_metersToLngLat, 3),
          deltaLng = _this$_metersToLngLat2[0],
          deltaLat = _this$_metersToLngLat2[1],
          _this$_metersToLngLat3 = _this$_metersToLngLat2[2],
          deltaZ = _this$_metersToLngLat3 === void 0 ? 0 : _this$_metersToLngLat3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }
  }, {
    key: "_metersToLngLatDelta",
    value: function _metersToLngLatDelta(xyz) {
      var _xyz2 = (0, _slicedToArray2.default)(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          z = _xyz2$ === void 0 ? 0 : _xyz2$;

      (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _this$distanceScales = this.distanceScales,
          pixelsPerMeter = _this$distanceScales.pixelsPerMeter,
          degreesPerPixel = _this$distanceScales.degreesPerPixel;
      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }
  }, {
    key: "_createProjectionMatrix",
    value: function _createProjectionMatrix(_ref5) {
      var orthographic = _ref5.orthographic,
          fovyRadians = _ref5.fovyRadians,
          aspect = _ref5.aspect,
          focalDistance = _ref5.focalDistance,
          near = _ref5.near,
          far = _ref5.far;
      (0, _assert.default)(Number.isFinite(fovyRadians));
      return orthographic ? new _math.Matrix4().orthographic({
        fovy: fovyRadians,
        aspect: aspect,
        focalDistance: focalDistance,
        near: near,
        far: far
      }) : new _math.Matrix4().perspective({
        fovy: fovyRadians,
        aspect: aspect,
        near: near,
        far: far
      });
    }
  }, {
    key: "_initViewMatrix",
    value: function _initViewMatrix(opts) {
      var _opts$viewMatrix = opts.viewMatrix,
          viewMatrix = _opts$viewMatrix === void 0 ? IDENTITY : _opts$viewMatrix,
          _opts$longitude = opts.longitude,
          longitude = _opts$longitude === void 0 ? null : _opts$longitude,
          _opts$latitude = opts.latitude,
          latitude = _opts$latitude === void 0 ? null : _opts$latitude,
          _opts$zoom = opts.zoom,
          zoom = _opts$zoom === void 0 ? null : _opts$zoom,
          _opts$position = opts.position,
          position = _opts$position === void 0 ? null : _opts$position,
          _opts$modelMatrix = opts.modelMatrix,
          modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix,
          _opts$focalDistance = opts.focalDistance,
          focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance,
          _opts$distanceScales = opts.distanceScales,
          distanceScales = _opts$distanceScales === void 0 ? null : _opts$distanceScales;
      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
      this.zoom = zoom;

      if (!Number.isFinite(this.zoom)) {
        this.zoom = this.isGeospatial ? (0, _viewportMercatorProject.getMeterZoom)({
          latitude: latitude
        }) + Math.log2(focalDistance) : DEFAULT_ZOOM;
      }

      var scale = Math.pow(2, this.zoom);
      this.scale = scale;
      this.distanceScales = this.isGeospatial ? (0, _viewportMercatorProject.getDistanceScales)({
        latitude: latitude,
        longitude: longitude,
        scale: this.scale
      }) : distanceScales || {
        pixelsPerMeter: [scale, scale, scale],
        metersPerPixel: [1 / scale, 1 / scale, 1 / scale]
      };
      this.focalDistance = focalDistance;
      this.distanceScales.metersPerPixel = new _math.Vector3(this.distanceScales.metersPerPixel);
      this.distanceScales.pixelsPerMeter = new _math.Vector3(this.distanceScales.pixelsPerMeter);
      this.position = ZERO_VECTOR;
      this.meterOffset = ZERO_VECTOR;

      if (position) {
        this.position = position;
        this.modelMatrix = modelMatrix;
        this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
      }

      if (this.isGeospatial) {
        this.longitude = longitude;
        this.latitude = latitude;
        this.center = this._getCenterInWorld({
          longitude: longitude,
          latitude: latitude
        });
        this.viewMatrixUncentered = mat4.scale([], viewMatrix, [1, -1, 1]);
      } else {
        this.center = position ? this.projectPosition(position) : [0, 0, 0];
        this.viewMatrixUncentered = viewMatrix;
      }

      this.viewMatrix = new _math.Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new _math.Vector3(this.center || ZERO_VECTOR).negate());
    }
  }, {
    key: "_getCenterInWorld",
    value: function _getCenterInWorld(_ref6) {
      var longitude = _ref6.longitude,
          latitude = _ref6.latitude;
      var meterOffset = this.meterOffset,
          scale = this.scale,
          distanceScales = this.distanceScales;
      var center2d = this.projectFlat([longitude, latitude], scale);
      var center = new _math.Vector3(center2d[0], center2d[1], 0);

      if (meterOffset) {
        var pixelPosition = new _math.Vector3(meterOffset).scale(distanceScales.pixelsPerMeter);
        center.add(pixelPosition);
      }

      return center;
    }
  }, {
    key: "_initProjectionMatrix",
    value: function _initProjectionMatrix(opts) {
      var _opts$projectionMatri = opts.projectionMatrix,
          projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri,
          _opts$orthographic = opts.orthographic,
          orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic,
          fovyRadians = opts.fovyRadians,
          fovyDegrees = opts.fovyDegrees,
          fovy = opts.fovy,
          _opts$near = opts.near,
          near = _opts$near === void 0 ? 0.1 : _opts$near,
          _opts$far = opts.far,
          far = _opts$far === void 0 ? 1000 : _opts$far,
          _opts$focalDistance2 = opts.focalDistance,
          focalDistance = _opts$focalDistance2 === void 0 ? 1 : _opts$focalDistance2,
          orthographicFocalDistance = opts.orthographicFocalDistance;
      var radians = fovyRadians || (fovyDegrees || fovy || 75) * DEGREES_TO_RADIANS;
      this.projectionMatrix = projectionMatrix || this._createProjectionMatrix({
        orthographic: orthographic,
        fovyRadians: radians,
        aspect: this.width / this.height,
        focalDistance: orthographicFocalDistance || focalDistance,
        near: near,
        far: far
      });
    }
  }, {
    key: "_initPixelMatrices",
    value: function _initPixelMatrices() {
      var vpm = (0, _mathUtils.createMat4)();
      mat4.multiply(vpm, vpm, this.projectionMatrix);
      mat4.multiply(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;
      this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;

      var _extractCameraVectors = (0, _mathUtils.extractCameraVectors)({
        viewMatrix: this.viewMatrix,
        viewMatrixInverse: this.viewMatrixInverse
      }),
          eye = _extractCameraVectors.eye,
          direction = _extractCameraVectors.direction,
          up = _extractCameraVectors.up;

      this.cameraPosition = eye;
      this.cameraDirection = direction;
      this.cameraUp = up;
      var viewportMatrix = (0, _mathUtils.createMat4)();
      var pixelProjectionMatrix = (0, _mathUtils.createMat4)();
      mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
      mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
      mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = pixelProjectionMatrix;
      this.viewportMatrix = viewportMatrix;
      this.pixelUnprojectionMatrix = mat4.invert((0, _mathUtils.createMat4)(), this.pixelProjectionMatrix);

      if (!this.pixelUnprojectionMatrix) {
        _log.default.warn('Pixel project matrix not invertible')();
      }
    }
  }]);
  return Viewport;
}();

exports.default = Viewport;
Viewport.displayName = 'Viewport';
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/math-utils":"../../../node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","gl-matrix/mat4":"../../../node_modules/gl-matrix/esm/mat4.js","viewport-mercator-project":"../../../node_modules/viewport-mercator-project/dist/esm/index.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _core = require("@luma.gl/core");

var _seer = _interopRequireDefault(require("seer"));

var _layer = _interopRequireDefault(require("./layer"));

var _constants = require("../lifecycle/constants");

var _log = _interopRequireDefault(require("../utils/log"));

var _flatten = require("../utils/flatten");

var _probe = require("probe.gl");

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _seerIntegration = require("./seer-integration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 4;
var INITIAL_CONTEXT = Object.seal({
  layerManager: null,
  deck: null,
  gl: null,
  time: -1,
  useDevicePixels: true,
  stats: null,
  shaderCache: null,
  pickingFBO: null,
  animationProps: null,
  userData: {}
});

var layerName = function layerName(layer) {
  return layer instanceof _layer.default ? "".concat(layer) : !layer ? 'null' : 'invalid';
};

var LayerManager = function () {
  function LayerManager(gl) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        deck = _ref.deck,
        stats = _ref.stats,
        _ref$viewport = _ref.viewport,
        viewport = _ref$viewport === void 0 ? null : _ref$viewport;

    (0, _classCallCheck2.default)(this, LayerManager);
    this.lastRenderedLayers = [];
    this.layers = [];
    this.context = Object.assign({}, INITIAL_CONTEXT, {
      layerManager: this,
      deck: deck,
      gl: gl,
      shaderCache: gl && new _core._ShaderCache({
        gl: gl,
        _cachePrograms: true
      }),
      stats: stats || new _probe.Stats({
        id: 'deck.gl'
      }),
      viewport: viewport || new _viewport.default({
        id: 'DEFAULT-INITIAL-VIEWPORT'
      })
    });
    this._needsRedraw = 'Initial render';
    this._needsUpdate = false;
    this._debug = false;
    this.activateViewport = this.activateViewport.bind(this);
    this._initSeer = this._initSeer.bind(this);
    this._editSeer = this._editSeer.bind(this);
    Object.seal(this);
    (0, _seerIntegration.seerInitListener)(this._initSeer);
    (0, _seerIntegration.layerEditListener)(this._editSeer);
  }

  (0, _createClass2.default)(LayerManager, [{
    key: "finalize",
    value: function finalize() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          this._finalizeLayer(layer);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      _seer.default.removeListener(this._initSeer);

      _seer.default.removeListener(this._editSeer);
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      return this._checkIfNeedsRedraw(opts);
    }
  }, {
    key: "needsUpdate",
    value: function needsUpdate() {
      return this._needsUpdate;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }
  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
    }
  }, {
    key: "getLayers",
    value: function getLayers() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;

      return layerIds ? this.layers.filter(function (layer) {
        return layerIds.find(function (layerId) {
          return layer.id.indexOf(layerId) === 0;
        });
      }) : this.layers;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('debug' in props) {
        this._debug = props.debug;
      }

      if ('userData' in props) {
        this.context.userData = props.userData;
      }

      if ('useDevicePixels' in props) {
        this.context.useDevicePixels = props.useDevicePixels;
      }

      if ('layers' in props) {
        this.setLayers(props.layers);
      }
    }
  }, {
    key: "setLayers",
    value: function setLayers(newLayers) {
      if (newLayers === this.lastRenderedLayers) {
        _log.default.log(3, 'Ignoring layer update due to layer array not changed')();

        return this;
      }

      this.lastRenderedLayers = newLayers;
      newLayers = (0, _flatten.flatten)(newLayers, {
        filter: Boolean
      });
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = newLayers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;
          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _this$_updateLayers = this._updateLayers({
        oldLayers: this.layers,
        newLayers: newLayers
      }),
          error = _this$_updateLayers.error,
          generatedLayers = _this$_updateLayers.generatedLayers;

      this.layers = generatedLayers;

      if (error) {
        throw error;
      }

      return this;
    }
  }, {
    key: "updateLayers",
    value: function updateLayers() {
      var animationProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ('time' in animationProps) {
        this.context.time = animationProps.time;
      }

      var reason = this.needsUpdate();

      if (reason) {
        this.setNeedsRedraw("updating layers: ".concat(reason));
        this.setLayers((0, _toConsumableArray2.default)(this.lastRenderedLayers));
      }
    }
  }, {
    key: "_checkIfNeedsRedraw",
    value: function _checkIfNeedsRedraw(opts) {
      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var layer = _step3.value;
          var layerNeedsRedraw = layer.getNeedsRedraw(opts);
          redraw = redraw || layerNeedsRedraw;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return redraw;
    }
  }, {
    key: "activateViewport",
    value: function activateViewport(viewport) {
      var oldViewport = this.context.viewport;
      var viewportChanged = !oldViewport || !viewport.equals(oldViewport);

      if (viewportChanged) {
        _log.default.log(4, 'Viewport changed', viewport)();

        this.context.viewport = viewport;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.layers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var layer = _step4.value;
            layer.setChangeFlags({
              viewportChanged: 'Viewport changed'
            });

            this._updateLayer(layer);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      (0, _assert.default)(this.context.viewport, 'LayerManager: viewport not set');
      return this;
    }
  }, {
    key: "_updateLayers",
    value: function _updateLayers(_ref3) {
      var oldLayers = _ref3.oldLayers,
          newLayers = _ref3.newLayers;
      var oldLayerMap = {};
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var oldLayer = _step5.value;

          if (oldLayerMap[oldLayer.id]) {
            _log.default.warn("Multiple old layers with same id ".concat(layerName(oldLayer)))();
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var generatedLayers = [];

      var error = this._updateSublayersRecursively({
        newLayers: newLayers,
        oldLayerMap: oldLayerMap,
        generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayerMap);

      this._needsUpdate = false;
      var firstError = error || error2;
      return {
        error: firstError,
        generatedLayers: generatedLayers
      };
    }
  }, {
    key: "_updateSublayersRecursively",
    value: function _updateSublayersRecursively(_ref4) {
      var newLayers = _ref4.newLayers,
          oldLayerMap = _ref4.oldLayerMap,
          generatedLayers = _ref4.generatedLayers;
      var error = null;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = newLayers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var newLayer = _step6.value;
          newLayer.context = this.context;
          var oldLayer = oldLayerMap[newLayer.id];

          if (oldLayer === null) {
            _log.default.warn("Multiple new layers with same id ".concat(layerName(newLayer)))();
          }

          oldLayerMap[newLayer.id] = null;
          var sublayers = null;

          try {
            if (this._debug && oldLayer !== newLayer) {
              newLayer.validateProps();
            }

            if (!oldLayer) {
              var err = this._initializeLayer(newLayer);

              error = error || err;
              (0, _seerIntegration.initLayerInSeer)(newLayer);
            } else {
              this._transferLayerState(oldLayer, newLayer);

              var _err = this._updateLayer(newLayer);

              error = error || _err;
              (0, _seerIntegration.updateLayerInSeer)(newLayer);
            }

            generatedLayers.push(newLayer);
            sublayers = newLayer.isComposite && newLayer.getSubLayers();
          } catch (err) {
            _log.default.warn("error during matching of ".concat(layerName(newLayer)), err)();

            error = error || err;
          }

          if (sublayers) {
            var _err2 = this._updateSublayersRecursively({
              newLayers: sublayers,
              oldLayerMap: oldLayerMap,
              generatedLayers: generatedLayers
            });

            error = error || _err2;
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return error;
    }
  }, {
    key: "_finalizeOldLayers",
    value: function _finalizeOldLayers(oldLayerMap) {
      var error = null;

      for (var layerId in oldLayerMap) {
        var layer = oldLayerMap[layerId];

        if (layer) {
          error = error || this._finalizeLayer(layer);
        }
      }

      return error;
    }
  }, {
    key: "_initializeLayer",
    value: function _initializeLayer(layer) {
      _log.default.log(LOG_PRIORITY_LIFECYCLE, "initializing ".concat(layerName(layer)))();

      var error = null;

      try {
        layer._initialize();

        layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
      } catch (err) {
        _log.default.warn("error while initializing ".concat(layerName(layer), "\n"), err)();

        error = error || err;
      }

      layer.internalState.layer = layer;
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = layer.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var model = _step7.value;
          model.userData.layer = layer;
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      return error;
    }
  }, {
    key: "_transferLayerState",
    value: function _transferLayerState(oldLayer, newLayer) {
      newLayer._transferState(oldLayer);

      newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;

      if (newLayer !== oldLayer) {
        _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "matched ".concat(layerName(newLayer)), oldLayer, '->', newLayer)();

        oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
      } else {
        _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "Matching layer is unchanged ".concat(newLayer.id))();
      }
    }
  }, {
    key: "_updateLayer",
    value: function _updateLayer(layer) {
      _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "updating ".concat(layer, " because: ").concat(layer.printChangeFlags()))();

      var error = null;

      try {
        layer._update();
      } catch (err) {
        _log.default.warn("error during update of ".concat(layerName(layer)), err)();

        error = err;
      }

      return error;
    }
  }, {
    key: "_finalizeLayer",
    value: function _finalizeLayer(layer) {
      (0, _assert.default)(layer.lifecycle !== _constants.LIFECYCLE.AWAITING_FINALIZATION);
      layer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;
      var error = null;
      this.setNeedsRedraw("finalized ".concat(layerName(layer)));

      try {
        layer._finalize();
      } catch (err) {
        _log.default.warn("error during finalization of ".concat(layerName(layer)), err)();

        error = err;
      }

      layer.lifecycle = _constants.LIFECYCLE.FINALIZED;

      _log.default.log(LOG_PRIORITY_LIFECYCLE, "finalizing ".concat(layerName(layer)))();

      return error;
    }
  }, {
    key: "_initSeer",
    value: function _initSeer() {
      this.layers.forEach(function (layer) {
        (0, _seerIntegration.initLayerInSeer)(layer);
        (0, _seerIntegration.updateLayerInSeer)(layer);
      });
    }
  }, {
    key: "_editSeer",
    value: function _editSeer(payload) {
      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
        return;
      }

      (0, _seerIntegration.setPropOverrides)(payload.itemKey, payload.valuePath.slice(1), payload.value);
      this.updateLayers();
    }
  }]);
  return LayerManager;
}();

exports.default = LayerManager;
},{"@babel/runtime/helpers/esm/toConsumableArray":"../../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","seer":"../../../node_modules/seer/dist/index.js","./layer":"../../../node_modules/@deck.gl/core/dist/esm/lib/layer.js","../lifecycle/constants":"../../../node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/flatten":"../../../node_modules/@deck.gl/core/dist/esm/utils/flatten.js","probe.gl":"../../../node_modules/probe.gl/dist/esm/index.js","../viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","./seer-integration":"../../../node_modules/@deck.gl/core/dist/esm/lib/seer-integration.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COORDINATE_SYSTEM", {
  enumerable: true,
  get: function () {
    return _constants.COORDINATE_SYSTEM;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function () {
    return _layer.default;
  }
});
Object.defineProperty(exports, "CompositeLayer", {
  enumerable: true,
  get: function () {
    return _compositeLayer.default;
  }
});
Object.defineProperty(exports, "AttributeManager", {
  enumerable: true,
  get: function () {
    return _attributeManager.default;
  }
});
Object.defineProperty(exports, "LayerManager", {
  enumerable: true,
  get: function () {
    return _layerManager.default;
  }
});

require("./init");

var _constants = require("./constants");

var _layer = _interopRequireDefault(require("./layer"));

var _compositeLayer = _interopRequireDefault(require("./composite-layer"));

var _attributeManager = _interopRequireDefault(require("./attribute-manager"));

var _layerManager = _interopRequireDefault(require("./layer-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./init":"../../../node_modules/@deck.gl/core/dist/esm/lib/init.js","./constants":"../../../node_modules/@deck.gl/core/dist/esm/lib/constants.js","./layer":"../../../node_modules/@deck.gl/core/dist/esm/lib/layer.js","./composite-layer":"../../../node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js","./attribute-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute-manager.js","./layer-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js"}],"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@luma.gl/core");

var _projectFunctions = require("../../shaderlib/project/project-functions");

var _lib = require("../../lib");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PointLight = function (_BasePointLight) {
  (0, _inherits2.default)(PointLight, _BasePointLight);

  function PointLight(props) {
    var _this;

    (0, _classCallCheck2.default)(this, PointLight);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PointLight).call(this, props));
    _this.projectedLight = new _core.PointLight(props);
    return _this;
  }

  (0, _createClass2.default)(PointLight, [{
    key: "getProjectedLight",
    value: function getProjectedLight(_ref) {
      var layer = _ref.layer;
      var viewport = layer.context.viewport;
      var _layer$props = layer.props,
          coordinateSystem = _layer$props.coordinateSystem,
          coordinateOrigin = _layer$props.coordinateOrigin;
      var position = (0, _projectFunctions.projectPosition)(this.position, {
        viewport: viewport,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin,
        fromCoordinateSystem: viewport.isGeospatial ? _lib.COORDINATE_SYSTEM.LNGLAT : _lib.COORDINATE_SYSTEM.IDENTITY,
        fromCoordinateOrigin: [0, 0, 0]
      });
      this.projectedLight.color = this.color;
      this.projectedLight.intensity = this.intensity;
      this.projectedLight.position = position;
      return this.projectedLight;
    }
  }]);
  return PointLight;
}(_core.PointLight);

exports.default = PointLight;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","../../shaderlib/project/project-functions":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js","../../lib":"../../../node_modules/@deck.gl/core/dist/esm/lib/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _pointLight = _interopRequireDefault(require("./point-light"));

var _viewportUniforms = require("../../shaderlib/project/viewport-uniforms");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CameraLight = function (_PointLight) {
  (0, _inherits2.default)(CameraLight, _PointLight);

  function CameraLight() {
    (0, _classCallCheck2.default)(this, CameraLight);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CameraLight).apply(this, arguments));
  }

  (0, _createClass2.default)(CameraLight, [{
    key: "getProjectedLight",
    value: function getProjectedLight(_ref) {
      var layer = _ref.layer;
      var viewport = layer.context.viewport;
      var _layer$props = layer.props,
          coordinateSystem = _layer$props.coordinateSystem,
          coordinateOrigin = _layer$props.coordinateOrigin,
          modelMatrix = _layer$props.modelMatrix;

      var _getUniformsFromViewp = (0, _viewportUniforms.getUniformsFromViewport)({
        viewport: viewport,
        modelMatrix: modelMatrix,
        coordinateSystem: coordinateSystem,
        coordinateOrigin: coordinateOrigin
      }),
          project_uCameraPosition = _getUniformsFromViewp.project_uCameraPosition;

      this.projectedLight.color = this.color;
      this.projectedLight.intensity = this.intensity;
      this.projectedLight.position = project_uCameraPosition;
      return this.projectedLight;
    }
  }]);
  return CameraLight;
}(_pointLight.default);

exports.default = CameraLight;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./point-light":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","../../shaderlib/project/viewport-uniforms":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"}],"../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _objectWithoutPropertiesLoose;

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
},{}],"../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _objectWithoutProperties;

var _objectWithoutPropertiesLoose = _interopRequireDefault(require("./objectWithoutPropertiesLoose"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = (0, _objectWithoutPropertiesLoose.default)(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}
},{"./objectWithoutPropertiesLoose":"../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"}],"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/suncalc.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSolarPosition = getSolarPosition;
exports.getSunlightDirection = getSunlightDirection;
var DEGREES_TO_RADIANS = Math.PI / 180;
var DAY_IN_MS = 1000 * 60 * 60 * 24;
var JD1970 = 2440588;
var JD2000 = 2451545;
var e = DEGREES_TO_RADIANS * 23.4397;
var M0 = 357.5291;
var M1 = 0.98560028;
var THETA0 = 280.147;
var THETA1 = 360.9856235;

function getSolarPosition(timestamp, latitude, longitude) {
  var longitudeWestInRadians = DEGREES_TO_RADIANS * -longitude;
  var phi = DEGREES_TO_RADIANS * latitude;
  var d = toDays(timestamp);
  var c = getSunCoords(d);
  var H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
  return {
    azimuth: getAzimuth(H, phi, c.declination),
    altitude: getAltitude(H, phi, c.declination)
  };
}

function getSunlightDirection(timestamp, latitude, longitude) {
  var _getSolarPosition = getSolarPosition(timestamp, latitude, longitude),
      azimuth = _getSolarPosition.azimuth,
      altitude = _getSolarPosition.altitude;

  var azimuthN = azimuth + Math.PI;
  return [-Math.sin(azimuthN), -Math.cos(azimuthN), -Math.sin(altitude)];
}

function toJulianDay(timestamp) {
  return timestamp / DAY_IN_MS - 0.5 + JD1970;
}

function toDays(timestamp) {
  return toJulianDay(timestamp) - JD2000;
}

function getRightAscension(eclipticLongitude, b) {
  var lambda = eclipticLongitude;
  return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
}

function getDeclination(eclipticLongitude, b) {
  var lambda = eclipticLongitude;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
}

function getAzimuth(hourAngle, latitudeInRadians, declination) {
  var H = hourAngle;
  var phi = latitudeInRadians;
  var delta = declination;
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}

function getAltitude(hourAngle, latitudeInRadians, declination) {
  var H = hourAngle;
  var phi = latitudeInRadians;
  var delta = declination;
  return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
}

function getSiderealTime(dates, longitudeWestInRadians) {
  return DEGREES_TO_RADIANS * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}

function getSolarMeanAnomaly(days) {
  return DEGREES_TO_RADIANS * (M0 + M1 * days);
}

function getEclipticLongitude(meanAnomaly) {
  var M = meanAnomaly;
  var C = DEGREES_TO_RADIANS * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));
  var P = DEGREES_TO_RADIANS * 102.9372;
  return M + C + P + Math.PI;
}

function getSunCoords(dates) {
  var M = getSolarMeanAnomaly(dates);
  var L = getEclipticLongitude(M);
  return {
    declination: getDeclination(L, 0),
    rightAscension: getRightAscension(L, 0)
  };
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@luma.gl/core");

var _suncalc = require("./suncalc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SunLight = function (_DirectionalLight) {
  (0, _inherits2.default)(SunLight, _DirectionalLight);

  function SunLight(_ref) {
    var _this;

    var timestamp = _ref.timestamp,
        others = (0, _objectWithoutProperties2.default)(_ref, ["timestamp"]);
    (0, _classCallCheck2.default)(this, SunLight);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SunLight).call(this, others));
    _this.timestamp = timestamp;
    return _this;
  }

  (0, _createClass2.default)(SunLight, [{
    key: "getProjectedLight",
    value: function getProjectedLight(_ref2) {
      var layer = _ref2.layer;
      var _layer$context$viewpo = layer.context.viewport,
          latitude = _layer$context$viewpo.latitude,
          longitude = _layer$context$viewpo.longitude;
      this.direction = (0, _suncalc.getSunlightDirection)(this.timestamp, latitude, longitude);
      return this;
    }
  }]);
  return SunLight;
}(_core.DirectionalLight);

exports.default = SunLight;
},{"@babel/runtime/helpers/esm/objectWithoutProperties":"../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./suncalc":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/suncalc.js"}],"../../../node_modules/@deck.gl/core/dist/esm/passes/pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Pass = function () {
  function Pass(gl) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Pass);
    var _props$id = props.id,
        id = _props$id === void 0 ? 'pass' : _props$id;
    this.id = id;
    this.gl = gl;
    this.props = {};
    Object.assign(this.props, props);
  }

  (0, _createClass2.default)(Pass, [{
    key: "setProps",
    value: function setProps(props) {
      Object.assign(this.props, props);
    }
  }, {
    key: "render",
    value: function render() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
  }]);
  return Pass;
}();

exports.default = Pass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js"}],"../../../node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@luma.gl/core");

var _pass = _interopRequireDefault(require("./pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ScreenPass = function (_Pass) {
  (0, _inherits2.default)(ScreenPass, _Pass);

  function ScreenPass(gl) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, ScreenPass);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ScreenPass).call(this, gl, props));
    var module = props.module,
        fs = props.fs,
        id = props.id,
        moduleProps = props.moduleProps;
    _this.model = _this._getModel(gl, module, fs, id, moduleProps);
    return _this;
  }

  (0, _createClass2.default)(ScreenPass, [{
    key: "render",
    value: function render(params) {
      var _this2 = this;

      var gl = this.gl;
      (0, _core.withParameters)(gl, {
        framebuffer: params.outputBuffer,
        clearColor: [0, 0, 0, 0]
      }, function () {
        return _this2._renderPass(gl, params);
      });
    }
  }, {
    key: "delete",
    value: function _delete() {
      this.model.delete();
      this.model = null;
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl, module, fs, id, userProps) {
      var model = new _core.ClipSpace(gl, {
        id: id,
        fs: fs,
        modules: [module]
      });
      var uniforms = Object.assign(module.getUniforms(), module.getUniforms(userProps));
      model.setUniforms(uniforms);
      return model;
    }
  }, {
    key: "_renderPass",
    value: function _renderPass(gl, _ref) {
      var inputBuffer = _ref.inputBuffer,
          outputBuffer = _ref.outputBuffer;
      (0, _core.clear)(gl, {
        color: true
      });
      this.model.draw({
        uniforms: {
          texture: inputBuffer,
          texSize: [inputBuffer.width, inputBuffer.height]
        },
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }]);
  return ScreenPass;
}(_pass.default);

exports.default = ScreenPass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/pass.js"}],"../../../node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _effect = _interopRequireDefault(require("../lib/effect"));

var _screenPass = _interopRequireDefault(require("../passes/screen-pass"));

var _shadertools = require("@luma.gl/shadertools");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PostProcessEffect = function (_Effect) {
  (0, _inherits2.default)(PostProcessEffect, _Effect);

  function PostProcessEffect(module) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, PostProcessEffect);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PostProcessEffect).call(this, props));
    _this.id = "".concat(module.name, "-pass");
    (0, _shadertools.normalizeShaderModule)(module);
    _this.module = module;
    return _this;
  }

  (0, _createClass2.default)(PostProcessEffect, [{
    key: "prepare",
    value: function prepare(gl) {
      if (!this.passes) {
        this.passes = createPasses(gl, this.module, this.id, this.props);
      }
    }
  }, {
    key: "render",
    value: function render(params) {
      var _params$target = params.target,
          target = _params$target === void 0 ? null : _params$target;
      var switchBuffer = false;

      for (var index = 0; index < this.passes.length; index++) {
        var inputBuffer = switchBuffer ? params.outputBuffer : params.inputBuffer;
        var outputBuffer = switchBuffer ? params.inputBuffer : params.outputBuffer;

        if (target && index === this.passes.length - 1) {
          outputBuffer = target;
        }

        this.passes[index].render({
          inputBuffer: inputBuffer,
          outputBuffer: outputBuffer
        });
        switchBuffer = !switchBuffer;
      }

      return {
        inputBuffer: switchBuffer ? params.outputBuffer : params.inputBuffer,
        outputBuffer: switchBuffer ? params.inputBuffer : params.outputBuffer
      };
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.passes) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var pass = _step.value;
            pass.delete();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.passes = null;
      }
    }
  }]);
  return PostProcessEffect;
}(_effect.default);

exports.default = PostProcessEffect;

function createPasses(gl, module, id, moduleProps) {
  if (module.filter || module.sampler) {
    var fs = getFragmentShaderForRenderPass(module);
    var pass = new _screenPass.default(gl, {
      id: id,
      module: module,
      fs: fs,
      moduleProps: moduleProps
    });
    return [pass];
  }

  var passes = module.passes || [];
  return passes.map(function (pass, index) {
    var fs = getFragmentShaderForRenderPass(module, pass);
    var idn = "".concat(id, "-").concat(index);
    return new _screenPass.default(gl, {
      id: idn,
      module: module,
      fs: fs,
      moduleProps: moduleProps
    });
  });
}

var FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE(func) {
  return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");
};

var SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE(func) {
  return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");
};

function getFragmentShaderForRenderPass(module) {
  var pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;

  if (pass.filter) {
    var func = typeof pass.filter === 'string' ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }

  if (pass.sampler) {
    var _func = typeof pass.sampler === 'string' ? pass.sampler : "".concat(module.name, "_sampleColor");

    return SAMPLER_FS_TEMPLATE(_func);
  }

  return null;
}
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","../lib/effect":"../../../node_modules/@deck.gl/core/dist/esm/lib/effect.js","../passes/screen-pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js","@luma.gl/shadertools":"../../../node_modules/@luma.gl/shadertools/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _pass = _interopRequireDefault(require("./pass"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LayersPass = function (_Pass) {
  (0, _inherits2.default)(LayersPass, _Pass);

  function LayersPass() {
    (0, _classCallCheck2.default)(this, LayersPass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LayersPass).apply(this, arguments));
  }

  (0, _createClass2.default)(LayersPass, [{
    key: "render",
    value: function render(params) {
      var _this = this;

      var gl = this.gl;
      return (0, _core.withParameters)(gl, {
        framebuffer: params.outputBuffer
      }, function () {
        return _this.drawLayers(params);
      });
    }
  }, {
    key: "drawLayers",
    value: function drawLayers(_ref) {
      var _this2 = this;

      var layers = _ref.layers,
          viewports = _ref.viewports,
          views = _ref.views,
          onViewportActive = _ref.onViewportActive,
          _ref$deviceRect = _ref.deviceRect,
          deviceRect = _ref$deviceRect === void 0 ? null : _ref$deviceRect,
          _ref$parameters = _ref.parameters,
          parameters = _ref$parameters === void 0 ? {} : _ref$parameters,
          _ref$pass = _ref.pass,
          pass = _ref$pass === void 0 ? 'draw' : _ref$pass,
          _ref$redrawReason = _ref.redrawReason,
          redrawReason = _ref$redrawReason === void 0 ? '' : _ref$redrawReason,
          _ref$clearCanvas = _ref.clearCanvas,
          clearCanvas = _ref$clearCanvas === void 0 ? true : _ref$clearCanvas,
          effects = _ref.effects,
          effectProps = _ref.effectProps;
      var gl = this.gl;

      if (clearCanvas) {
        this.clearCanvas(gl);
      }

      var renderStats = [];
      viewports.forEach(function (viewportOrDescriptor, i) {
        var viewport = _this2.getViewportFromDescriptor(viewportOrDescriptor);

        var view = views && views[viewport.id];
        onViewportActive(viewport);

        var stats = _this2.drawLayersInViewport(gl, {
          layers: layers,
          viewport: viewport,
          view: view,
          deviceRect: deviceRect,
          parameters: parameters,
          pass: pass,
          redrawReason: redrawReason,
          effects: effects,
          effectProps: effectProps
        });

        renderStats.push(stats);
      });
      return renderStats;
    }
  }, {
    key: "drawLayersInViewport",
    value: function drawLayersInViewport(gl, _ref2) {
      var _this3 = this;

      var layers = _ref2.layers,
          viewport = _ref2.viewport,
          view = _ref2.view,
          _ref2$deviceRect = _ref2.deviceRect,
          deviceRect = _ref2$deviceRect === void 0 ? null : _ref2$deviceRect,
          _ref2$parameters = _ref2.parameters,
          parameters = _ref2$parameters === void 0 ? {} : _ref2$parameters,
          _ref2$pass = _ref2.pass,
          pass = _ref2$pass === void 0 ? 'draw' : _ref2$pass,
          _ref2$redrawReason = _ref2.redrawReason,
          redrawReason = _ref2$redrawReason === void 0 ? '' : _ref2$redrawReason,
          effects = _ref2.effects,
          effectProps = _ref2.effectProps;
      var glViewport = this.getGLViewport(gl, {
        viewport: viewport
      });

      if (view && view.props.clear) {
        var clearOpts = view.props.clear === true ? {
          color: true,
          depth: true
        } : view.props.clear;
        (0, _core.withParameters)(gl, {
          scissorTest: true,
          scissor: glViewport
        }, function () {
          return (0, _core.clear)(gl, clearOpts);
        });
      }

      var renderStatus = {
        totalCount: layers.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      (0, _core.setParameters)(gl, parameters || {});
      layers.forEach(function (layer, layerIndex) {
        var shouldDrawLayer = _this3.shouldDrawLayer(layer, viewport);

        if (shouldDrawLayer && layer.props.pickable) {
          renderStatus.pickableCount++;
        }

        if (layer.isComposite) {
          renderStatus.compositeCount++;
        }

        if (shouldDrawLayer) {
          renderStatus.visibleCount++;

          _this3.drawLayerInViewport({
            gl: gl,
            layer: layer,
            layerIndex: layerIndex,
            glViewport: glViewport,
            parameters: parameters,
            effects: effects,
            effectProps: effectProps
          });
        }
      });
      return renderStatus;
    }
  }, {
    key: "drawLayerInViewport",
    value: function drawLayerInViewport(_ref3) {
      var gl = _ref3.gl,
          layer = _ref3.layer,
          layerIndex = _ref3.layerIndex,
          glViewport = _ref3.glViewport,
          parameters = _ref3.parameters,
          effects = _ref3.effects,
          effectProps = _ref3.effectProps;
      var moduleParameters = this.getModuleParameters(layer, effects, effectProps);
      var uniforms = Object.assign({}, layer.context.uniforms, {
        layerIndex: layerIndex
      });
      var layerParameters = this.getLayerParameters(layer, layerIndex, glViewport, parameters);
      layer.drawLayer({
        moduleParameters: moduleParameters,
        uniforms: uniforms,
        parameters: layerParameters
      });
    }
  }, {
    key: "getViewportFromDescriptor",
    value: function getViewportFromDescriptor(viewportOrDescriptor) {
      return viewportOrDescriptor.viewport ? viewportOrDescriptor.viewport : viewportOrDescriptor;
    }
  }, {
    key: "shouldDrawLayer",
    value: function shouldDrawLayer(layer, viewport) {
      var layerFilter = this.props.layerFilter;
      var shouldDrawLayer = !layer.isComposite && layer.props.visible;

      if (shouldDrawLayer && layerFilter) {
        shouldDrawLayer = layerFilter({
          layer: layer,
          viewport: viewport,
          isPicking: false
        });
      }

      return shouldDrawLayer;
    }
  }, {
    key: "getModuleParameters",
    value: function getModuleParameters(layer) {
      var moduleParameters = Object.assign(Object.create(layer.props), {
        viewport: layer.context.viewport,
        pickingActive: 0,
        devicePixelRatio: this.props.pixelRatio
      });
      return moduleParameters;
    }
  }, {
    key: "getLayerParameters",
    value: function getLayerParameters(layer, layerIndex, glViewport, parameters) {
      var layerParameters = Object.assign({}, layer.props.parameters || {}, parameters);
      Object.assign(layerParameters, {
        viewport: glViewport
      });
      return layerParameters;
    }
  }, {
    key: "getGLViewport",
    value: function getGLViewport(gl, _ref4) {
      var viewport = _ref4.viewport;
      var height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;
      var dimensions = viewport;
      var pixelRatio = this.props.pixelRatio;
      return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
    }
  }, {
    key: "clearCanvas",
    value: function clearCanvas(gl) {
      var width = gl.drawingBufferWidth;
      var height = gl.drawingBufferHeight;
      (0, _core.withParameters)(gl, {
        viewport: [0, 0, width, height]
      }, function () {
        gl.clear(16384 | 256);
      });
    }
  }]);
  return LayersPass;
}(_pass.default);

exports.default = LayersPass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/pass.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepEqual = deepEqual;

function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  return Object.keys(a).every(function (key) {
    if (Array.isArray(a[key]) && Array.isArray(b[key])) {
      return deepEqual(a[key], b[key]);
    }

    return a[key] === b[key];
  });
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/utils/positions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePosition = parsePosition;
exports.getPosition = getPosition;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;

function parsePosition(value) {
  switch ((0, _typeof2.default)(value)) {
    case 'number':
      return {
        position: value,
        relative: false
      };

    case 'string':
      var match = value.match(PERCENT_OR_PIXELS_REGEX);

      if (match && match.length >= 3) {
        var relative = match[2] === '%';
        var position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative: relative
        };
      }

    default:
      throw new Error("Could not parse position string ".concat(value));
  }
}

function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js"}],"../../../node_modules/@deck.gl/core/dist/esm/views/view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _positions = require("../utils/positions");

var _deepEqual = require("../utils/deep-equal");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var View = function () {
  function View() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, View);
    var _props$id = props.id,
        id = _props$id === void 0 ? null : _props$id,
        _props$x = props.x,
        x = _props$x === void 0 ? 0 : _props$x,
        _props$y = props.y,
        y = _props$y === void 0 ? 0 : _props$y,
        _props$width = props.width,
        width = _props$width === void 0 ? '100%' : _props$width,
        _props$height = props.height,
        height = _props$height === void 0 ? '100%' : _props$height,
        _props$projectionMatr = props.projectionMatrix,
        projectionMatrix = _props$projectionMatr === void 0 ? null : _props$projectionMatr,
        _props$fovy = props.fovy,
        fovy = _props$fovy === void 0 ? 50 : _props$fovy,
        _props$near = props.near,
        near = _props$near === void 0 ? 0.1 : _props$near,
        _props$far = props.far,
        far = _props$far === void 0 ? 1000 : _props$far,
        _props$modelMatrix = props.modelMatrix,
        modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix,
        _props$viewportInstan = props.viewportInstance,
        viewportInstance = _props$viewportInstan === void 0 ? null : _props$viewportInstan,
        _props$type = props.type,
        type = _props$type === void 0 ? _viewport.default : _props$type;
    (0, _assert.default)(!viewportInstance || viewportInstance instanceof _viewport.default);
    this.viewportInstance = viewportInstance;
    this.id = id || this.constructor.displayName || 'view';
    this.type = type;
    this.props = Object.assign({}, props, {
      id: this.id,
      projectionMatrix: projectionMatrix,
      fovy: fovy,
      near: near,
      far: far,
      modelMatrix: modelMatrix
    });

    this._parseDimensions({
      x: x,
      y: y,
      width: width,
      height: height
    });

    this.equals = this.equals.bind(this);
    Object.seal(this);
  }

  (0, _createClass2.default)(View, [{
    key: "equals",
    value: function equals(view) {
      if (this === view) {
        return true;
      }

      if (this.viewportInstance) {
        return view.viewportInstance && this.viewportInstance.equals(view.viewportInstance);
      }

      var viewChanged = (0, _deepEqual.deepEqual)(this.props, view.props);
      return viewChanged;
    }
  }, {
    key: "makeViewport",
    value: function makeViewport(_ref) {
      var width = _ref.width,
          height = _ref.height,
          viewState = _ref.viewState;

      if (this.viewportInstance) {
        return this.viewportInstance;
      }

      viewState = this.filterViewState(viewState);
      var viewportDimensions = this.getDimensions({
        width: width,
        height: height
      });
      var props = Object.assign({
        viewState: viewState
      }, viewState, this.props, viewportDimensions);
      return this._getViewport(props);
    }
  }, {
    key: "getViewStateId",
    value: function getViewStateId() {
      switch ((0, _typeof2.default)(this.props.viewState)) {
        case 'string':
          return this.props.viewState;

        case 'object':
          return this.props.viewState && this.props.viewState.id;

        default:
          return this.id;
      }
    }
  }, {
    key: "filterViewState",
    value: function filterViewState(viewState) {
      if (this.props.viewState && (0, _typeof2.default)(this.props.viewState) === 'object') {
        if (!this.props.viewState.id) {
          return this.props.viewState;
        }

        var newViewState = Object.assign({}, viewState);

        for (var key in this.props.viewState) {
          if (key !== 'id') {
            newViewState[key] = this.props.viewState[key];
          }
        }

        return newViewState;
      }

      return viewState;
    }
  }, {
    key: "getDimensions",
    value: function getDimensions(_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return {
        x: (0, _positions.getPosition)(this._x, width),
        y: (0, _positions.getPosition)(this._y, height),
        width: (0, _positions.getPosition)(this._width, width),
        height: (0, _positions.getPosition)(this._height, height)
      };
    }
  }, {
    key: "_getControllerProps",
    value: function _getControllerProps(defaultOpts) {
      var opts = this.props.controller;

      if (!opts) {
        return null;
      }

      if (opts === true) {
        return defaultOpts;
      }

      if (typeof opts === 'function') {
        opts = {
          type: opts
        };
      }

      return Object.assign({}, defaultOpts, opts);
    }
  }, {
    key: "_getViewport",
    value: function _getViewport(props) {
      var ViewportType = this.type;
      return new ViewportType(props);
    }
  }, {
    key: "_parseDimensions",
    value: function _parseDimensions(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          width = _ref3.width,
          height = _ref3.height;
      this._x = (0, _positions.parsePosition)(x);
      this._y = (0, _positions.parsePosition)(y);
      this._width = (0, _positions.parsePosition)(width);
      this._height = (0, _positions.parsePosition)(height);
    }
  }]);
  return View;
}();

exports.default = View;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../utils/positions":"../../../node_modules/@deck.gl/core/dist/esm/utils/positions.js","../utils/deep-equal":"../../../node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/view-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _deepEqual = require("../utils/deep-equal");

var _view = _interopRequireDefault(require("../views/view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _log = _interopRequireDefault(require("../utils/log"));

var _flatten = require("../utils/flatten");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ViewManager = function () {
  function ViewManager() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, ViewManager);
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = 'Initial render';
    this._needsUpdate = true;
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractiveStateChange: props.onInteractiveStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }

  (0, _createClass2.default)(ViewManager, [{
    key: "finalize",
    value: function finalize() {
      for (var key in this.controllers) {
        if (this.controllers[key]) {
          this.controllers[key].finalize();
        }
      }

      this.controllers = {};
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      return redraw;
    }
  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
      this._needsRedraw = this._needsRedraw || reason;
    }
  }, {
    key: "updateViewStates",
    value: function updateViewStates() {
      var animationProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if ('time' in animationProps) {
        for (var viewId in this.controllers) {
          var controller = this.controllers[viewId];

          if (controller) {
            controller.updateTransition(animationProps.time);
          }
        }
      }
    }
  }, {
    key: "getViewports",
    value: function getViewports(rect) {
      if (rect) {
        return this._viewports.filter(function (viewport) {
          return viewport.containsPixel(rect);
        });
      }

      return this._viewports;
    }
  }, {
    key: "getViews",
    value: function getViews() {
      var viewMap = {};
      this.views.forEach(function (view) {
        viewMap[view.id] = view;
      });
      return viewMap;
    }
  }, {
    key: "getView",
    value: function getView(viewOrViewId) {
      return typeof viewOrViewId === 'string' ? this.views.find(function (view) {
        return view.id === viewOrViewId;
      }) : viewOrViewId;
    }
  }, {
    key: "getViewState",
    value: function getViewState(viewId) {
      var view = this.getView(viewId);
      var viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
      return view ? view.filterViewState(viewState) : viewState;
    }
  }, {
    key: "getViewport",
    value: function getViewport(viewId) {
      return this._viewportMap[viewId];
    }
  }, {
    key: "project",
    value: function project(xyz) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        topLeft: true
      };
      var viewports = this.getViewports();

      for (var i = viewports.length - 1; i >= 0; --i) {
        var viewport = viewports[i];

        if (viewport.contains(xyz, opts)) {
          return viewport.project(xyz, opts);
        }
      }

      return null;
    }
  }, {
    key: "unproject",
    value: function unproject(xyz, opts) {
      var viewports = this.getViewports();

      for (var i = viewports.length - 1; i >= 0; --i) {
        var viewport = viewports[i];

        if (viewport.containsPixel(xyz, opts)) {
          return viewport.unproject(xyz);
        }
      }

      return null;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('views' in props) {
        this._setViews(props.views);
      }

      if ('viewState' in props) {
        this._setViewState(props.viewState);
      }

      if ('width' in props || 'height' in props) {
        this._setSize(props.width, props.height);
      }

      if (!this._isUpdating) {
        this._update();
      }
    }
  }, {
    key: "_update",
    value: function _update() {
      this._isUpdating = true;

      if (this._needsUpdate) {
        this._needsUpdate = false;

        this._rebuildViewports();
      }

      if (this._needsUpdate) {
        this._needsUpdate = false;

        this._rebuildViewports();
      }

      this._isUpdating = false;
    }
  }, {
    key: "_setSize",
    value: function _setSize(width, height) {
      (0, _assert.default)(Number.isFinite(width) && Number.isFinite(height));

      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        this.setNeedsUpdate('Size changed');
      }
    }
  }, {
    key: "_setViews",
    value: function _setViews(views) {
      views = (0, _flatten.flatten)(views, {
        filter: Boolean
      }).map(function (view) {
        return view instanceof _viewport.default ? new _view.default({
          viewportInstance: view
        }) : view;
      });

      var viewsChanged = this._diffViews(views, this.views);

      if (viewsChanged) {
        this.setNeedsUpdate('views changed');
      }

      this.views = views;
    }
  }, {
    key: "_setViewState",
    value: function _setViewState(viewState) {
      if (viewState) {
        var viewStateChanged = !(0, _deepEqual.deepEqual)(viewState, this.viewState);

        if (viewStateChanged) {
          this.setNeedsUpdate('viewState changed');
        }

        this.viewState = viewState;
      } else {
        _log.default.warn('setting null viewState')();
      }
    }
  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(viewId, event) {
      event.viewId = viewId;

      this._eventCallbacks.onViewStateChange(event);
    }
  }, {
    key: "_createController",
    value: function _createController(props) {
      var Controller = props.type;
      var controller = new Controller(Object.assign({
        eventManager: this._eventManager,
        onViewStateChange: this._onViewStateChange.bind(this, props.id),
        onStateChange: this._eventCallbacks.onInteractiveStateChange
      }, props));
      return controller;
    }
  }, {
    key: "_updateController",
    value: function _updateController(view, viewState, viewport, controller) {
      if (view.controller) {
        var controllerProps = Object.assign({}, view.controller, viewState, {
          id: view.id,
          x: viewport.x,
          y: viewport.y,
          width: viewport.width,
          height: viewport.height
        });

        if (controller) {
          controller.setProps(controllerProps);
        } else {
          controller = this._createController(controllerProps);
        }

        return controller;
      }

      return null;
    }
  }, {
    key: "_rebuildViewports",
    value: function _rebuildViewports() {
      var width = this.width,
          height = this.height,
          views = this.views;
      var oldControllers = this.controllers;
      this._viewports = [];
      this.controllers = {};

      for (var i = views.length; i--;) {
        var view = views[i];
        var viewState = this.getViewState(view);
        var viewport = view.makeViewport({
          width: width,
          height: height,
          viewState: viewState
        });
        this.controllers[view.id] = this._updateController(view, viewState, viewport, oldControllers[view.id]);

        this._viewports.unshift(viewport);
      }

      for (var id in oldControllers) {
        if (oldControllers[id] && !this.controllers[id]) {
          oldControllers[id].finalize();
        }
      }

      this._buildViewportMap();
    }
  }, {
    key: "_buildViewportMap",
    value: function _buildViewportMap() {
      var _this = this;

      this._viewportMap = {};

      this._viewports.forEach(function (viewport) {
        if (viewport.id) {
          _this._viewportMap[viewport.id] = _this._viewportMap[viewport.id] || viewport;
        }
      });
    }
  }, {
    key: "_diffViews",
    value: function _diffViews(newViews, oldViews) {
      if (newViews.length !== oldViews.length) {
        return true;
      }

      return newViews.some(function (_, i) {
        return !newViews[i].equals(oldViews[i]);
      });
    }
  }]);
  return ViewManager;
}();

exports.default = ViewManager;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js","../utils/deep-equal":"../../../node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../views/view":"../../../node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/flatten":"../../../node_modules/@deck.gl/core/dist/esm/utils/flatten.js"}],"../../../node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/assertThisInitialized"));

var _viewport = _interopRequireDefault(require("./viewport"));

var _viewportMercatorProject = require("viewport-mercator-project");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  (0, _inherits2.default)(WebMercatorViewport, _Viewport);

  function WebMercatorViewport() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, WebMercatorViewport);
    var _opts$latitude = opts.latitude,
        latitude = _opts$latitude === void 0 ? 0 : _opts$latitude,
        _opts$longitude = opts.longitude,
        longitude = _opts$longitude === void 0 ? 0 : _opts$longitude,
        _opts$zoom = opts.zoom,
        zoom = _opts$zoom === void 0 ? 11 : _opts$zoom,
        _opts$pitch = opts.pitch,
        pitch = _opts$pitch === void 0 ? 0 : _opts$pitch,
        _opts$bearing = opts.bearing,
        bearing = _opts$bearing === void 0 ? 0 : _opts$bearing,
        _opts$nearZMultiplier = opts.nearZMultiplier,
        nearZMultiplier = _opts$nearZMultiplier === void 0 ? 0.1 : _opts$nearZMultiplier,
        _opts$farZMultiplier = opts.farZMultiplier,
        farZMultiplier = _opts$farZMultiplier === void 0 ? 10 : _opts$farZMultiplier,
        _opts$orthographic = opts.orthographic,
        orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic;
    var width = opts.width,
        height = opts.height,
        _opts$altitude = opts.altitude,
        altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude;
    width = width || 1;
    height = height || 1;
    altitude = Math.max(0.75, altitude);

    var _getProjectionParamet = (0, _viewportMercatorProject.getProjectionParameters)({
      width: width,
      height: height,
      pitch: pitch,
      altitude: altitude,
      nearZMultiplier: nearZMultiplier,
      farZMultiplier: farZMultiplier
    }),
        fov = _getProjectionParamet.fov,
        aspect = _getProjectionParamet.aspect,
        focalDistance = _getProjectionParamet.focalDistance,
        near = _getProjectionParamet.near,
        far = _getProjectionParamet.far;

    var viewMatrixUncentered = (0, _viewportMercatorProject.getViewMatrix)({
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });
    var viewportOpts = Object.assign({}, opts, {
      width: width,
      height: height,
      viewMatrix: viewMatrixUncentered,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      orthographic: orthographic,
      fovyRadians: fov,
      aspect: aspect,
      orthographicFocalDistance: focalDistance,
      near: near,
      far: far
    });
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(WebMercatorViewport).call(this, viewportOpts));
    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;
    _this.orthographic = orthographic;
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    Object.freeze((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    return _this;
  }

  (0, _createClass2.default)(WebMercatorViewport, [{
    key: "metersToLngLatDelta",
    value: function metersToLngLatDelta(xyz) {
      var _xyz = (0, _slicedToArray2.default)(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === void 0 ? 0 : _xyz$;

      (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _this$distanceScales = this.distanceScales,
          pixelsPerMeter = _this$distanceScales.pixelsPerMeter,
          degreesPerPixel = _this$distanceScales.degreesPerPixel;
      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }
  }, {
    key: "lngLatDeltaToMeters",
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = (0, _slicedToArray2.default)(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === void 0 ? 0 : _deltaLngLatZ$;

      (0, _assert.default)(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _this$distanceScales2 = this.distanceScales,
          pixelsPerDegree = _this$distanceScales2.pixelsPerDegree,
          metersPerPixel = _this$distanceScales2.metersPerPixel;
      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }
  }, {
    key: "addMetersToLngLat",
    value: function addMetersToLngLat(lngLatZ, xyz) {
      return (0, _viewportMercatorProject.addMetersToLngLat)(lngLatZ, xyz);
    }
  }, {
    key: "getMapCenterByLngLatPosition",
    value: function getMapCenterByLngLatPosition(_ref) {
      var lngLat = _ref.lngLat,
          pos = _ref.pos;
      var fromLocation = (0, _viewportMercatorProject.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
      var toLocation = this.projectFlat(lngLat);
      var translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
      var newCenter = vec2.add([], this.center, translate);
      return this.unprojectFlat(newCenter);
    }
  }, {
    key: "getLocationAtPoint",
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;
      return this.getMapCenterByLngLatPosition({
        lngLat: lngLat,
        pos: pos
      });
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = (0, _viewportMercatorProject.fitBounds)(Object.assign({
        width: width,
        height: height,
        bounds: bounds
      }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({
        width: width,
        height: height,
        longitude: longitude,
        latitude: latitude,
        zoom: zoom
      });
    }
  }]);
  return WebMercatorViewport;
}(_viewport.default);

exports.default = WebMercatorViewport;
WebMercatorViewport.displayName = 'WebMercatorViewport';
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@babel/runtime/helpers/esm/assertThisInitialized":"../../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","./viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","viewport-mercator-project":"../../../node_modules/viewport-mercator-project/dist/esm/index.js","gl-matrix/vec2":"../../../node_modules/gl-matrix/esm/vec2.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _math = require("math.gl");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TransitionInterpolator = function () {
  function TransitionInterpolator() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, TransitionInterpolator);

    if (Array.isArray(opts)) {
      opts = {
        compare: opts,
        extract: opts,
        required: opts
      };
    }

    var _opts = opts,
        compare = _opts.compare,
        extract = _opts.extract,
        required = _opts.required;
    this._propsToCompare = compare;
    this._propsToExtract = extract;
    this._requiredProps = required;
  }

  (0, _createClass2.default)(TransitionInterpolator, [{
    key: "arePropsEqual",
    value: function arePropsEqual(currentProps, nextProps) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (this._propsToCompare || Object.keys(nextProps))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!(0, _math.equals)(currentProps[key], nextProps[key])) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return true;
    }
  }, {
    key: "initializeProps",
    value: function initializeProps(startProps, endProps) {
      var result;

      if (this._propsToExtract) {
        var startViewStateProps = {};
        var endViewStateProps = {};
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._propsToExtract[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var key = _step2.value;
            startViewStateProps[key] = startProps[key];
            endViewStateProps[key] = endProps[key];
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        result = {
          start: startViewStateProps,
          end: endViewStateProps
        };
      } else {
        result = {
          start: startProps,
          end: endProps
        };
      }

      this._checkRequiredProps(result.start);

      this._checkRequiredProps(result.end);

      return result;
    }
  }, {
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      (0, _assert.default)(false, 'interpolateProps is not implemented');
    }
  }, {
    key: "_checkRequiredProps",
    value: function _checkRequiredProps(props) {
      if (!this._requiredProps) {
        return;
      }

      this._requiredProps.forEach(function (propName) {
        var value = props[propName];
        (0, _assert.default)(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
      });
    }
  }]);
  return TransitionInterpolator;
}();

exports.default = TransitionInterpolator;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));

var _math = require("math.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];

var LinearInterpolator = function (_TransitionInterpolat) {
  (0, _inherits2.default)(LinearInterpolator, _TransitionInterpolat);

  function LinearInterpolator() {
    var transitionProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : VIEWPORT_TRANSITION_PROPS;
    (0, _classCallCheck2.default)(this, LinearInterpolator);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LinearInterpolator).call(this, transitionProps));
  }

  (0, _createClass2.default)(LinearInterpolator, [{
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      var viewport = {};

      for (var key in endProps) {
        viewport[key] = (0, _math.lerp)(startProps[key], endProps[key], t);
      }

      return viewport;
    }
  }]);
  return LinearInterpolator;
}(_transitionInterpolator.default);

exports.default = LinearInterpolator;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./transition-interpolator":"../../../node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRANSITION_EVENTS = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transition = _interopRequireDefault(require("../transitions/transition"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var noop = function noop() {};

var TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
exports.TRANSITION_EVENTS = TRANSITION_EVENTS;
var DEFAULT_PROPS = {
  transitionDuration: 0,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(),
  transitionInterruption: TRANSITION_EVENTS.BREAK,
  onTransitionStart: noop,
  onTransitionInterrupt: noop,
  onTransitionEnd: noop
};

var TransitionManager = function () {
  function TransitionManager(ControllerState) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, TransitionManager);
    (0, _assert.default)(ControllerState);
    this.ControllerState = ControllerState;
    this.props = Object.assign({}, DEFAULT_PROPS, props);
    this.propsInTransition = null;
    this.time = 0;
    this.transition = new _transition.default();
    this.onViewStateChange = props.onViewStateChange;
    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);
  }

  (0, _createClass2.default)(TransitionManager, [{
    key: "finalize",
    value: function finalize() {}
  }, {
    key: "getViewportInTransition",
    value: function getViewportInTransition() {
      return this.propsInTransition;
    }
  }, {
    key: "processViewStateChange",
    value: function processViewStateChange(nextProps) {
      var transitionTriggered = false;
      var currentProps = this.props;
      nextProps = Object.assign({}, DEFAULT_PROPS, nextProps);
      this.props = nextProps;

      if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return transitionTriggered;
      }

      if (this._isTransitionEnabled(nextProps)) {
        var startProps = Object.assign({}, currentProps, this.transition.interruption === TRANSITION_EVENTS.SNAP_TO_END ? this.transition.endProps : this.propsInTransition || currentProps);

        this._triggerTransition(startProps, nextProps);

        transitionTriggered = true;
      } else {
        this.transition.cancel();
      }

      return transitionTriggered;
    }
  }, {
    key: "updateTransition",
    value: function updateTransition(timestamp) {
      this.time = timestamp;

      this._updateTransition();
    }
  }, {
    key: "_isTransitionEnabled",
    value: function _isTransitionEnabled(props) {
      return props.transitionDuration > 0 && props.transitionInterpolator;
    }
  }, {
    key: "_isUpdateDueToCurrentTransition",
    value: function _isUpdateDueToCurrentTransition(props) {
      if (this.transition.inProgress) {
        return this.transition.interpolator.arePropsEqual(props, this.propsInTransition);
      }

      return false;
    }
  }, {
    key: "_shouldIgnoreViewportChange",
    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (this.transition.inProgress) {
        return this.transition.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
      } else if (this._isTransitionEnabled(nextProps)) {
        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
      }

      return true;
    }
  }, {
    key: "_triggerTransition",
    value: function _triggerTransition(startProps, endProps) {
      (0, _assert.default)(this._isTransitionEnabled(endProps), 'Transition is not enabled');
      var startViewstate = new this.ControllerState(startProps);
      var endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);
      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);
      this.propsInTransition = {};
      this.transition.start({
        duration: endProps.transitionDuration,
        easing: endProps.transitionEasing,
        interpolator: endProps.transitionInterpolator,
        interruption: endProps.transitionInterruption,
        startProps: initialProps.start,
        endProps: initialProps.end,
        onStart: endProps.onTransitionStart,
        onUpdate: this._onTransitionUpdate,
        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
      });

      this._updateTransition();
    }
  }, {
    key: "_updateTransition",
    value: function _updateTransition() {
      this.transition.update(this.time);
    }
  }, {
    key: "_onTransitionEnd",
    value: function _onTransitionEnd(callback) {
      var _this = this;

      return function (transition) {
        _this.propsInTransition = null;
        callback(transition);
      };
    }
  }, {
    key: "_onTransitionUpdate",
    value: function _onTransitionUpdate(transition) {
      var interpolator = transition.interpolator,
          startProps = transition.startProps,
          endProps = transition.endProps,
          time = transition.time;
      var viewport = interpolator.interpolateProps(startProps, endProps, time);
      this.propsInTransition = new this.ControllerState(Object.assign({}, this.props, viewport)).getViewportProps();

      if (this.onViewStateChange) {
        this.onViewStateChange({
          viewState: this.propsInTransition,
          interactionState: {
            inTransition: true
          }
        });
      }
    }
  }]);
  return TransitionManager;
}();

exports.default = TransitionManager;
TransitionManager.defaultProps = DEFAULT_PROPS;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../transitions/linear-interpolator":"../../../node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","../transitions/transition":"../../../node_modules/@deck.gl/core/dist/esm/transitions/transition.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/controllers/controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _transitionManager = _interopRequireDefault(require("./transition-manager"));

var _log = _interopRequireDefault(require("../utils/log"));

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
var ZOOM_ACCEL = 0.01;
var EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown']
};

var Controller = function () {
  function Controller(ControllerState) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Controller);
    (0, _assert.default)(ControllerState);
    this.ControllerState = ControllerState;
    this.controllerState = null;
    this.controllerStateProps = null;
    this.eventManager = null;
    this.transitionManager = new _transitionManager.default(ControllerState, options);
    this._events = null;
    this._state = {
      isDragging: false
    };
    this.events = [];
    this.onViewStateChange = null;
    this.onStateChange = null;
    this.invertPan = false;
    this.handleEvent = this.handleEvent.bind(this);
    this.setProps(options);
  }

  (0, _createClass2.default)(Controller, [{
    key: "finalize",
    value: function finalize() {
      for (var eventName in this._events) {
        if (this._events[eventName]) {
          this.eventManager.off(eventName, this.handleEvent);
        }
      }

      this.transitionManager.finalize();
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      var ControllerState = this.ControllerState;
      this.controllerState = new ControllerState(Object.assign({}, this.controllerStateProps, this._state));

      switch (event.type) {
        case 'panstart':
          return this._onPanStart(event);

        case 'panmove':
          return this._onPan(event);

        case 'panend':
          return this._onPanEnd(event);

        case 'pinchstart':
          return this._onPinchStart(event);

        case 'pinchmove':
          return this._onPinch(event);

        case 'pinchend':
          return this._onPinchEnd(event);

        case 'doubletap':
          return this._onDoubleTap(event);

        case 'wheel':
          return this._onWheel(event);

        case 'keydown':
          return this._onKeyDown(event);

        default:
          return false;
      }
    }
  }, {
    key: "getCenter",
    value: function getCenter(event) {
      var _this$controllerState = this.controllerStateProps,
          x = _this$controllerState.x,
          y = _this$controllerState.y;
      var offsetCenter = event.offsetCenter;
      return [offsetCenter.x - x, offsetCenter.y - y];
    }
  }, {
    key: "isPointInBounds",
    value: function isPointInBounds(pos, event) {
      var _this$controllerState2 = this.controllerStateProps,
          width = _this$controllerState2.width,
          height = _this$controllerState2.height;

      if (event && event.handled) {
        return false;
      }

      var inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;

      if (inside && event) {
        event.stopPropagation();
      }

      return inside;
    }
  }, {
    key: "isFunctionKeyPressed",
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;
      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: "isDragging",
    value: function isDragging() {
      return this._state.isDragging;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      if ('onViewportChange' in props) {
        _log.default.removed('onViewportChange')();
      }

      if ('onViewStateChange' in props) {
        this.onViewStateChange = props.onViewStateChange;
      }

      if ('onStateChange' in props) {
        this.onStateChange = props.onStateChange;
      }

      this.controllerStateProps = props;

      if ('eventManager' in props && this.eventManager !== props.eventManager) {
        this.eventManager = props.eventManager;
        this._events = {};
        this.toggleEvents(this.events, true);
      }

      this.transitionManager.processViewStateChange(this.controllerStateProps);
      var _props$scrollZoom = props.scrollZoom,
          scrollZoom = _props$scrollZoom === void 0 ? true : _props$scrollZoom,
          _props$dragPan = props.dragPan,
          dragPan = _props$dragPan === void 0 ? true : _props$dragPan,
          _props$dragRotate = props.dragRotate,
          dragRotate = _props$dragRotate === void 0 ? true : _props$dragRotate,
          _props$doubleClickZoo = props.doubleClickZoom,
          doubleClickZoom = _props$doubleClickZoo === void 0 ? true : _props$doubleClickZoo,
          _props$touchZoom = props.touchZoom,
          touchZoom = _props$touchZoom === void 0 ? true : _props$touchZoom,
          _props$touchRotate = props.touchRotate,
          touchRotate = _props$touchRotate === void 0 ? false : _props$touchRotate,
          _props$keyboard = props.keyboard,
          keyboard = _props$keyboard === void 0 ? true : _props$keyboard;
      var isInteractive = Boolean(this.onViewStateChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoom = touchZoom;
      this.touchRotate = touchRotate;
      this.keyboard = keyboard;
    }
  }, {
    key: "updateTransition",
    value: function updateTransition(timestamp) {
      this.transitionManager.updateTransition(timestamp);
    }
  }, {
    key: "toggleEvents",
    value: function toggleEvents(eventNames, enabled) {
      var _this = this;

      if (this.eventManager) {
        eventNames.forEach(function (eventName) {
          if (_this._events[eventName] !== enabled) {
            _this._events[eventName] = enabled;

            if (enabled) {
              _this.eventManager.on(eventName, _this.handleEvent);
            } else {
              _this.eventManager.off(eventName, _this.handleEvent);
            }
          }
        });
      }
    }
  }, {
    key: "setOptions",
    value: function setOptions(props) {
      return this.setProps(props);
    }
  }, {
    key: "updateViewport",
    value: function updateViewport(newControllerState) {
      var extraProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var interactionState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var viewState = Object.assign({}, newControllerState.getViewportProps(), extraProps);
      var changed = this.controllerState !== newControllerState;

      if (changed) {
        var oldViewState = this.controllerState ? this.controllerState.getViewportProps() : null;

        if (this.onViewStateChange) {
          this.onViewStateChange({
            viewState: viewState,
            interactionState: interactionState,
            oldViewState: oldViewState
          });
        }
      }

      Object.assign(this._state, Object.assign({}, newControllerState.getInteractiveState(), interactionState));

      if (this.onStateChange) {
        this.onStateChange(this._state);
      }
    }
  }, {
    key: "_onPanStart",
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);

      if (!this.isPointInBounds(pos, event)) {
        return false;
      }

      var newControllerState = this.controllerState.panStart({
        pos: pos
      }).rotateStart({
        pos: pos
      });
      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
    }
  }, {
    key: "_onPan",
    value: function _onPan(event) {
      var alternateMode = this.isFunctionKeyPressed(event) || event.rightButton;
      alternateMode = this.invertPan ? !alternateMode : alternateMode;
      return alternateMode ? this._onPanMove(event) : this._onPanRotate(event);
    }
  }, {
    key: "_onPanEnd",
    value: function _onPanEnd(event) {
      var newControllerState = this.controllerState.panEnd().rotateEnd();
      return this.updateViewport(newControllerState, null, {
        isDragging: false
      });
    }
  }, {
    key: "_onPanMove",
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }

      var pos = this.getCenter(event);

      if (!this.isDragging()) {
        return false;
      }

      var newControllerState = this.controllerState.pan({
        pos: pos
      });
      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
    }
  }, {
    key: "_onPanRotate",
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _this$controllerState3 = this.controllerState.getViewportProps(),
          width = _this$controllerState3.width,
          height = _this$controllerState3.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = deltaY / height;
      var newControllerState = this.controllerState.rotate({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY
      });
      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
    }
  }, {
    key: "_onWheel",
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }

      event.preventDefault();
      var pos = this.getCenter(event);

      if (!this.isPointInBounds(pos, event)) {
        return false;
      }

      var delta = event.delta;
      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));

      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }

      var newControllerState = this.controllerState.zoom({
        pos: pos,
        scale: scale
      });
      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS);
    }
  }, {
    key: "_onPinchStart",
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);

      if (!this.isPointInBounds(pos, event)) {
        return false;
      }

      var newControllerState = this.controllerState.zoomStart({
        pos: pos
      }).rotateStart({
        pos: pos
      });
      this._state.startPinchRotation = event.rotation;
      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
    }
  }, {
    key: "_onPinch",
    value: function _onPinch(event) {
      if (!this.touchZoom && !this.touchRotate) {
        return false;
      }

      var newControllerState = this.controllerState;

      if (this.touchZoom) {
        var scale = event.scale;
        var pos = this.getCenter(event);
        newControllerState = newControllerState.zoom({
          pos: pos,
          scale: scale
        });
      }

      if (this.touchRotate) {
        var rotation = event.rotation;
        var startPinchRotation = this._state.startPinchRotation;
        newControllerState = newControllerState.rotate({
          deltaScaleX: -(rotation - startPinchRotation) / 180
        });
      }

      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
    }
  }, {
    key: "_onPinchEnd",
    value: function _onPinchEnd(event) {
      var newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this._state.startPinchRotation = 0;
      return this.updateViewport(newControllerState, null, {
        isDragging: false
      });
    }
  }, {
    key: "_onDoubleTap",
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }

      var pos = this.getCenter(event);

      if (!this.isPointInBounds(pos, event)) {
        return false;
      }

      var isZoomOut = this.isFunctionKeyPressed(event);
      var newControllerState = this.controllerState.zoom({
        pos: pos,
        scale: isZoomOut ? 0.5 : 2
      });
      return this.updateViewport(newControllerState, this._getTransitionProps());
    }
  }, {
    key: "_onKeyDown",
    value: function _onKeyDown(event) {
      if (!this.keyboard) {
        return false;
      }

      var funcKey = this.isFunctionKeyPressed(event);
      var controllerState = this.controllerState;
      var newControllerState;

      switch (event.srcEvent.keyCode) {
        case 189:
          newControllerState = funcKey ? controllerState.zoomOut().zoomOut() : controllerState.zoomOut();
          break;

        case 187:
          newControllerState = funcKey ? controllerState.zoomIn().zoomIn() : controllerState.zoomIn();
          break;

        case 37:
          newControllerState = funcKey ? controllerState.rotateLeft() : controllerState.moveLeft();
          break;

        case 39:
          newControllerState = funcKey ? controllerState.rotateRight() : controllerState.moveRight();
          break;

        case 38:
          newControllerState = funcKey ? controllerState.rotateUp() : controllerState.moveUp();
          break;

        case 40:
          newControllerState = funcKey ? controllerState.rotateDown() : controllerState.moveDown();
          break;

        default:
          return false;
      }

      return this.updateViewport(newControllerState, this._getTransitionProps());
    }
  }, {
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      return NO_TRANSITION_PROPS;
    }
  }]);
  return Controller;
}();

exports.default = Controller;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./transition-manager":"../../../node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/controllers/view-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _math = require("math.gl");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultState = {
  position: [0, 0, 0],
  lookAt: [0, 0, 0],
  up: [0, 0, 1],
  rotationX: 0,
  rotationY: 0,
  fov: 50,
  near: 1,
  far: 100
};

var ViewState = function () {
  function ViewState(opts) {
    (0, _classCallCheck2.default)(this, ViewState);
    var width = opts.width,
        height = opts.height,
        _opts$position = opts.position,
        position = _opts$position === void 0 ? defaultState.position : _opts$position;
    (0, _assert.default)(Number.isFinite(width), '`width` must be supplied');
    (0, _assert.default)(Number.isFinite(height), '`height` must be supplied');
    this._viewportProps = this._applyConstraints(Object.assign({}, opts, {
      position: new _math.Vector3(position)
    }));
  }

  (0, _createClass2.default)(ViewState, [{
    key: "getViewportProps",
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: "getDirection",
    value: function getDirection() {
      var spherical = new _math._SphericalCoordinates({
        bearing: this._viewportProps.bearing,
        pitch: this._viewportProps.pitch
      });
      var direction = spherical.toVector3().normalize();
      return direction;
    }
  }, {
    key: "getDirectionFromBearing",
    value: function getDirectionFromBearing(bearing) {
      var spherical = new _math._SphericalCoordinates({
        bearing: bearing,
        pitch: 90
      });
      var direction = spherical.toVector3().normalize();
      return direction;
    }
  }, {
    key: "shortestPathFrom",
    value: function shortestPathFrom(viewState) {
      return this._viewportProps;
    }
  }, {
    key: "_applyConstraints",
    value: function _applyConstraints(props) {
      return props;
    }
  }]);
  return ViewState;
}();

exports.default = ViewState;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testExports = exports.default = exports.MAPBOX_LIMITS = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _math = require("math.gl");

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _viewportMercatorProject = _interopRequireWildcard(require("viewport-mercator-project"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transitionManager = require("./transition-manager");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;
var LINEAR_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(),
  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
};
var NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
var MAPBOX_LIMITS = {
  minZoom: 0,
  maxZoom: 20,
  minPitch: 0,
  maxPitch: 60
};
exports.MAPBOX_LIMITS = MAPBOX_LIMITS;
var DEFAULT_STATE = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var MapState = function (_ViewState) {
  (0, _inherits2.default)(MapState, _ViewState);

  function MapState() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude,
        _ref$maxZoom = _ref.maxZoom,
        maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,
        _ref$minZoom = _ref.minZoom,
        minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom,
        _ref$maxPitch = _ref.maxPitch,
        maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,
        _ref$minPitch = _ref.minPitch,
        minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch,
        startPanLngLat = _ref.startPanLngLat,
        startZoomLngLat = _ref.startZoomLngLat,
        startBearing = _ref.startBearing,
        startPitch = _ref.startPitch,
        startZoom = _ref.startZoom;

    (0, _classCallCheck2.default)(this, MapState);
    (0, _assert.default)(Number.isFinite(longitude), '`longitude` must be supplied');
    (0, _assert.default)(Number.isFinite(latitude), '`latitude` must be supplied');
    (0, _assert.default)(Number.isFinite(zoom), '`zoom` must be supplied');
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MapState).call(this, {
      width: width,
      height: height,
      latitude: latitude,
      longitude: longitude,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch,
      altitude: altitude,
      maxZoom: maxZoom,
      minZoom: minZoom,
      maxPitch: maxPitch,
      minPitch: minPitch
    }));
    _this._interactiveState = {
      startPanLngLat: startPanLngLat,
      startZoomLngLat: startZoomLngLat,
      startBearing: startBearing,
      startPitch: startPitch,
      startZoom: startZoom
    };
    return _this;
  }

  (0, _createClass2.default)(MapState, [{
    key: "getViewportProps",
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: "getInteractiveState",
    value: function getInteractiveState() {
      return this._interactiveState;
    }
  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }
  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);

      if (!startPanLngLat) {
        return this;
      }

      var _this$_calculateNewLn = this._calculateNewLngLat({
        startPanLngLat: startPanLngLat,
        pos: pos
      }),
          _this$_calculateNewLn2 = (0, _slicedToArray2.default)(_this$_calculateNewLn, 2),
          longitude = _this$_calculateNewLn2[0],
          latitude = _this$_calculateNewLn2[1];

      return this._getUpdatedState({
        longitude: longitude,
        latitude: latitude
      });
    }
  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }
  }, {
    key: "rotateStart",
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;
      return this._getUpdatedState({
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }
  }, {
    key: "rotate",
    value: function rotate(_ref5) {
      var _ref5$deltaScaleX = _ref5.deltaScaleX,
          deltaScaleX = _ref5$deltaScaleX === void 0 ? 0 : _ref5$deltaScaleX,
          _ref5$deltaScaleY = _ref5.deltaScaleY,
          deltaScaleY = _ref5$deltaScaleY === void 0 ? 0 : _ref5$deltaScaleY;
      var _this$_interactiveSta = this._interactiveState,
          startBearing = _this$_interactiveSta.startBearing,
          startPitch = _this$_interactiveSta.startPitch;

      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
        return this;
      }

      var _this$_calculateNewPi = this._calculateNewPitchAndBearing({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _this$_calculateNewPi.pitch,
          bearing = _this$_calculateNewPi.bearing;

      return this._getUpdatedState({
        bearing: bearing,
        pitch: pitch
      });
    }
  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }
  }, {
    key: "zoomStart",
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;
      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this._viewportProps.zoom
      });
    }
  }, {
    key: "zoom",
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;
      (0, _assert.default)(scale > 0, '`scale` must be a positive number');
      var _this$_interactiveSta2 = this._interactiveState,
          startZoom = _this$_interactiveSta2.startZoom,
          startZoomLngLat = _this$_interactiveSta2.startZoomLngLat;

      if (!Number.isFinite(startZoom)) {
        startZoom = this._viewportProps.zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }

      (0, _assert.default)(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');

      var zoom = this._calculateNewZoom({
        scale: scale,
        startZoom: startZoom
      });

      var zoomedViewport = new _viewportMercatorProject.default(Object.assign({}, this._viewportProps, {
        zoom: zoom
      }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({
        lngLat: startZoomLngLat,
        pos: pos
      }),
          _zoomedViewport$getLo2 = (0, _slicedToArray2.default)(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      return this._getUpdatedState({
        zoom: zoom,
        longitude: longitude,
        latitude: latitude
      });
    }
  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      return this._zoomFromCenter(2);
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      return this._zoomFromCenter(0.5);
    }
  }, {
    key: "moveLeft",
    value: function moveLeft() {
      return this._panFromCenter([100, 0]);
    }
  }, {
    key: "moveRight",
    value: function moveRight() {
      return this._panFromCenter([-100, 0]);
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      return this._panFromCenter([0, 100]);
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      return this._panFromCenter([0, -100]);
    }
  }, {
    key: "rotateLeft",
    value: function rotateLeft() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing - 15
      });
    }
  }, {
    key: "rotateRight",
    value: function rotateRight() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing + 15
      });
    }
  }, {
    key: "rotateUp",
    value: function rotateUp() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch + 10
      });
    }
  }, {
    key: "rotateDown",
    value: function rotateDown() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch - 10
      });
    }
  }, {
    key: "shortestPathFrom",
    value: function shortestPathFrom(viewState) {
      var fromProps = viewState.getViewportProps();
      var props = Object.assign({}, this._viewportProps);
      var bearing = props.bearing,
          longitude = props.longitude;

      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }

      if (Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }

      return props;
    }
  }, {
    key: "_zoomFromCenter",
    value: function _zoomFromCenter(scale) {
      var _this$_viewportProps = this._viewportProps,
          width = _this$_viewportProps.width,
          height = _this$_viewportProps.height;
      return this.zoom({
        pos: [width / 2, height / 2],
        scale: scale
      });
    }
  }, {
    key: "_panFromCenter",
    value: function _panFromCenter(offset) {
      var _this$_viewportProps2 = this._viewportProps,
          width = _this$_viewportProps2.width,
          height = _this$_viewportProps2.height;
      return this.pan({
        startPos: [width / 2, height / 2],
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
  }, {
    key: "_getUpdatedState",
    value: function _getUpdatedState(newProps) {
      return new MapState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }
  }, {
    key: "_applyConstraints",
    value: function _applyConstraints(props) {
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;
      props.zoom = (0, _math.clamp)(zoom, minZoom, maxZoom);
      var maxPitch = props.maxPitch,
          minPitch = props.minPitch,
          pitch = props.pitch;
      props.pitch = (0, _math.clamp)(pitch, minPitch, maxPitch);
      Object.assign(props, (0, _viewportMercatorProject.normalizeViewportProps)(props));
      return props;
    }
  }, {
    key: "_unproject",
    value: function _unproject(pos) {
      var viewport = new _viewportMercatorProject.default(this._viewportProps);
      return pos && viewport.unproject(pos);
    }
  }, {
    key: "_calculateNewLngLat",
    value: function _calculateNewLngLat(_ref8) {
      var startPanLngLat = _ref8.startPanLngLat,
          pos = _ref8.pos;
      var viewport = new _viewportMercatorProject.default(this._viewportProps);
      return viewport.getMapCenterByLngLatPosition({
        lngLat: startPanLngLat,
        pos: pos
      });
    }
  }, {
    key: "_calculateNewZoom",
    value: function _calculateNewZoom(_ref9) {
      var scale = _ref9.scale,
          startZoom = _ref9.startZoom;
      var _this$_viewportProps3 = this._viewportProps,
          maxZoom = _this$_viewportProps3.maxZoom,
          minZoom = _this$_viewportProps3.minZoom;
      var zoom = startZoom + Math.log2(scale);
      return (0, _math.clamp)(zoom, minZoom, maxZoom);
    }
  }, {
    key: "_calculateNewPitchAndBearing",
    value: function _calculateNewPitchAndBearing(_ref10) {
      var deltaScaleX = _ref10.deltaScaleX,
          deltaScaleY = _ref10.deltaScaleY,
          startBearing = _ref10.startBearing,
          startPitch = _ref10.startPitch;
      deltaScaleY = (0, _math.clamp)(deltaScaleY, -1, 1);
      var _this$_viewportProps4 = this._viewportProps,
          minPitch = _this$_viewportProps4.minPitch,
          maxPitch = _this$_viewportProps4.maxPitch;
      var bearing = startBearing + 180 * deltaScaleX;
      var pitch = startPitch;

      if (deltaScaleY > 0) {
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }
  }]);
  return MapState;
}(_viewState.default);

var MapController = function (_Controller) {
  (0, _inherits2.default)(MapController, _Controller);

  function MapController(props) {
    var _this2;

    (0, _classCallCheck2.default)(this, MapController);
    _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MapController).call(this, MapState, props));
    _this2.invertPan = true;
    return _this2;
  }

  (0, _createClass2.default)(MapController, [{
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      return LINEAR_TRANSITION_PROPS;
    }
  }, {
    key: "_onPanRotate",
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _this$getCenter = this.getCenter(event),
          _this$getCenter2 = (0, _slicedToArray2.default)(_this$getCenter, 2),
          centerY = _this$getCenter2[1];

      var startY = centerY - deltaY;

      var _this$controllerState = this.controllerState.getViewportProps(),
          width = _this$controllerState.width,
          height = _this$controllerState.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = 0;

      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = 1 - centerY / startY;
        }
      }

      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));
      var newControllerState = this.controllerState.rotate({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY
      });
      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
    }
  }]);
  return MapController;
}(_controller.default);

exports.default = MapController;
var testExports = {
  MapState: MapState
};
exports.testExports = testExports;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","./controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"../../../node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","viewport-mercator-project":"../../../node_modules/viewport-mercator-project/dist/esm/index.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js","../transitions/linear-interpolator":"../../../node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","./transition-manager":"../../../node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js"}],"../../../node_modules/@deck.gl/core/dist/esm/views/map-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _webMercatorViewport = _interopRequireDefault(require("../viewports/web-mercator-viewport"));

var _mapController = _interopRequireDefault(require("../controllers/map-controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MapView = function (_View) {
  (0, _inherits2.default)(MapView, _View);

  function MapView(props) {
    (0, _classCallCheck2.default)(this, MapView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MapView).call(this, Object.assign({}, props, {
      type: _webMercatorViewport.default
    })));
  }

  (0, _createClass2.default)(MapView, [{
    key: "controller",
    get: function get() {
      return this._getControllerProps({
        type: _mapController.default
      });
    }
  }]);
  return MapView;
}(_view.default);

exports.default = MapView;
MapView.displayName = 'MapView';
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./view":"../../../node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/web-mercator-viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","../controllers/map-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _deepEqual = require("../utils/deep-equal");

var _lightingEffect = _interopRequireDefault(require("../effects/lighting/lighting-effect"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EffectManager = function () {
  function EffectManager() {
    (0, _classCallCheck2.default)(this, EffectManager);
    this.effects = [];
    this._needsRedraw = 'Initial render';
    this.defaultLightingEffect = new _lightingEffect.default();
    this.needApplyDefaultLighting = false;
  }

  (0, _createClass2.default)(EffectManager, [{
    key: "setProps",
    value: function setProps(props) {
      if ('effects' in props) {
        if (props.effects.length !== this.effects.length || !(0, _deepEqual.deepEqual)(props.effects, this.effects)) {
          this.setEffects(props.effects);
          this._needsRedraw = 'effects changed';
        }
      }

      this.checkLightingEffect();
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      return redraw;
    }
  }, {
    key: "getEffects",
    value: function getEffects() {
      var effects = this.effects;

      if (this.needApplyDefaultLighting) {
        effects = this.effects.slice();
        effects.push(this.defaultLightingEffect);
      }

      return effects;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      this.cleanup();
    }
  }, {
    key: "setEffects",
    value: function setEffects() {
      var effects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.cleanup();
      this.effects = effects;
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          effect.cleanup();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.effects.length = 0;
    }
  }, {
    key: "checkLightingEffect",
    value: function checkLightingEffect() {
      var hasEffect = false;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var effect = _step2.value;

          if (effect instanceof _lightingEffect.default) {
            hasEffect = true;
            break;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.needApplyDefaultLighting = !hasEffect;
    }
  }]);
  return EffectManager;
}();

exports.default = EffectManager;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils/deep-equal":"../../../node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../effects/lighting/lighting-effect":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js"}],"../../../node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _layersPass = _interopRequireDefault(require("./layers-pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DrawLayersPass = function (_LayersPass) {
  (0, _inherits2.default)(DrawLayersPass, _LayersPass);

  function DrawLayersPass() {
    (0, _classCallCheck2.default)(this, DrawLayersPass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(DrawLayersPass).apply(this, arguments));
  }

  (0, _createClass2.default)(DrawLayersPass, [{
    key: "getModuleParameters",
    value: function getModuleParameters(layer, effects, effectProps) {
      var moduleParameters = (0, _get2.default)((0, _getPrototypeOf2.default)(DrawLayersPass.prototype), "getModuleParameters", this).call(this, layer);
      Object.assign(moduleParameters, this.getObjectHighlightParameters(layer), effectProps);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          Object.assign(moduleParameters, effect.getParameters(layer));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return moduleParameters;
    }
  }, {
    key: "getObjectHighlightParameters",
    value: function getObjectHighlightParameters(layer) {
      var _layer$props = layer.props,
          highlightedObjectIndex = _layer$props.highlightedObjectIndex,
          highlightColor = _layer$props.highlightColor;
      var parameters = {
        pickingHighlightColor: [highlightColor[0], highlightColor[1], highlightColor[2], highlightColor[3] || 255]
      };

      if (Number.isInteger(highlightedObjectIndex)) {
        parameters.pickingSelectedColor = highlightedObjectIndex >= 0 ? layer.encodePickingColor(highlightedObjectIndex) : null;
      }

      return parameters;
    }
  }]);
  return DrawLayersPass;
}(_layersPass.default);

exports.default = DrawLayersPass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./layers-pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js"}],"../../../node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _layersPass = _interopRequireDefault(require("./layers-pass"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PickLayersPass = function (_LayersPass) {
  (0, _inherits2.default)(PickLayersPass, _LayersPass);

  function PickLayersPass() {
    (0, _classCallCheck2.default)(this, PickLayersPass);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PickLayersPass).apply(this, arguments));
  }

  (0, _createClass2.default)(PickLayersPass, [{
    key: "render",
    value: function render(props) {
      if (props.pickingFBO) {
        this.drawPickingBuffer(props);
      } else {
        (0, _get2.default)((0, _getPrototypeOf2.default)(PickLayersPass.prototype), "render", this).call(this, props);
      }
    }
  }, {
    key: "drawPickingBuffer",
    value: function drawPickingBuffer(_ref) {
      var _this = this;

      var layers = _ref.layers,
          viewports = _ref.viewports,
          onViewportActive = _ref.onViewportActive,
          pickingFBO = _ref.pickingFBO,
          effectProps = _ref.effectProps,
          _ref$deviceRect = _ref.deviceRect,
          x = _ref$deviceRect.x,
          y = _ref$deviceRect.y,
          width = _ref$deviceRect.width,
          height = _ref$deviceRect.height,
          _ref$redrawReason = _ref.redrawReason,
          redrawReason = _ref$redrawReason === void 0 ? '' : _ref$redrawReason;
      var gl = this.gl;
      return (0, _core.withParameters)(gl, {
        framebuffer: pickingFBO,
        scissorTest: true,
        scissor: [x, y, width, height],
        clearColor: [0, 0, 0, 0]
      }, function () {
        _this.drawLayers({
          layers: layers,
          viewports: viewports,
          onViewportActive: onViewportActive,
          pass: 'picking',
          redrawReason: redrawReason,
          effectProps: effectProps,
          parameters: {
            blend: true,
            blendFunc: [1, 0, 32771, 0],
            blendEquation: 32774,
            blendColor: [0, 0, 0, 0],
            depthMask: true,
            depthTest: true,
            depthRange: [0, 1],
            colorMask: [true, true, true, true]
          }
        });
      });
    }
  }, {
    key: "shouldDrawLayer",
    value: function shouldDrawLayer(layer, viewport) {
      var layerFilter = this.props.layerFilter;
      var shouldDrawLayer = !layer.isComposite && layer.props.visible && layer.props.pickable;

      if (shouldDrawLayer && layerFilter) {
        shouldDrawLayer = layerFilter({
          layer: layer,
          viewport: viewport,
          isPicking: true
        });
      }

      return shouldDrawLayer;
    }
  }, {
    key: "getModuleParameters",
    value: function getModuleParameters(layer, effects, effectProps) {
      var moduleParameters = Object.assign(Object.create(layer.props), {
        viewport: layer.context.viewport,
        pickingActive: 1,
        devicePixelRatio: this.props.pixelRatio
      });
      Object.assign(moduleParameters, effectProps);
      return moduleParameters;
    }
  }, {
    key: "getLayerParameters",
    value: function getLayerParameters(layer, layerIndex, glViewport, parameters) {
      var layerParameters = Object.assign({}, layer.props.parameters || {}, parameters);
      Object.assign(layerParameters, {
        viewport: glViewport,
        blendColor: [0, 0, 0, (layerIndex + 1) / 255]
      });
      return layerParameters;
    }
  }]);
  return PickLayersPass;
}(_layersPass.default);

exports.default = PickLayersPass;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./layers-pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/utils/get-pixel-ratio.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getPixelRatio;

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getPixelRatio(useDevicePixels) {
  (0, _assert.default)(typeof useDevicePixels === 'boolean', 'Invalid useDevicePixels');
  return useDevicePixels && typeof window !== 'undefined' ? window.devicePixelRatio : 1;
}
},{"../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _log = _interopRequireDefault(require("../utils/log"));

var _drawLayersPass = _interopRequireDefault(require("../passes/draw-layers-pass"));

var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));

var _getPixelRatio = _interopRequireDefault(require("../utils/get-pixel-ratio"));

var _postProcessEffect = _interopRequireDefault(require("../effects/post-process-effect"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOG_PRIORITY_DRAW = 2;

var DeckRenderer = function () {
  function DeckRenderer(gl) {
    (0, _classCallCheck2.default)(this, DeckRenderer);
    this.gl = gl;
    this.pixelRatio = null;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new _drawLayersPass.default(gl);
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.renderCount = 0;
    this._needsRedraw = 'Initial render';
    this.screenBuffer = null;
    this.offscreenBuffer = null;
    this.lastPostProcessEffect = null;
  }

  (0, _createClass2.default)(DeckRenderer, [{
    key: "setProps",
    value: function setProps(props) {
      if ('useDevicePixels' in props) {
        this.pixelRatio = (0, _getPixelRatio.default)(props.useDevicePixels);
      }

      if ('layerFilter' in props) {
        if (this.layerFilter !== props.layerFilter) {
          this.layerFilter = props.layerFilter;
          this._needsRedraw = 'layerFilter changed';
        }
      }

      if ('drawPickingColors' in props) {
        if (this.drawPickingColors !== props.drawPickingColors) {
          this.drawPickingColors = props.drawPickingColors;
          this._needsRedraw = 'drawPickingColors changed';
        }
      }

      var pixelRatio = this.pixelRatio,
          layerFilter = this.layerFilter;
      this.drawLayersPass.setProps({
        pixelRatio: pixelRatio,
        layerFilter: layerFilter
      });
      this.pickLayersPass.setProps({
        pixelRatio: pixelRatio,
        layerFilter: layerFilter
      });
    }
  }, {
    key: "renderLayers",
    value: function renderLayers(_ref) {
      var _this = this;

      var layers = _ref.layers,
          viewports = _ref.viewports,
          activateViewport = _ref.activateViewport,
          views = _ref.views,
          _ref$redrawReason = _ref.redrawReason,
          redrawReason = _ref$redrawReason === void 0 ? 'unknown reason' : _ref$redrawReason,
          _ref$clearCanvas = _ref.clearCanvas,
          clearCanvas = _ref$clearCanvas === void 0 ? true : _ref$clearCanvas,
          _ref$effects = _ref.effects,
          effects = _ref$effects === void 0 ? [] : _ref$effects,
          pass = _ref.pass,
          stats = _ref.stats;
      var layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
      var effectProps = this.prepareEffects({
        layers: layers,
        viewports: viewports,
        onViewportActive: activateViewport,
        views: views,
        effects: effects
      });
      var outputBuffer = this.lastPostProcessEffect ? this.screenBuffer : _core.Framebuffer.getDefaultFramebuffer(this.gl);
      var renderStats = layerPass.render({
        layers: layers,
        viewports: viewports,
        views: views,
        onViewportActive: activateViewport,
        redrawReason: redrawReason,
        clearCanvas: clearCanvas,
        effects: effects,
        effectProps: effectProps,
        outputBuffer: outputBuffer
      });
      this.postRender(effects);
      this.renderCount++;

      if (_log.default.priority >= LOG_PRIORITY_DRAW) {
        renderStats.forEach(function (status) {
          _this.logRenderStats({
            status: status,
            pass: pass,
            redrawReason: redrawReason,
            stats: stats,
            renderStats: renderStats
          });
        });
      }
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };
      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      return redraw;
    }
  }, {
    key: "finalize",
    value: function finalize() {
      if (this.screenBuffer) {
        this.screenBuffer.delete();
        this.screenBuffer = null;
      }

      if (this.offscreenBuffer) {
        this.offscreenBuffer.delete();
        this.offscreenBuffer = null;
      }
    }
  }, {
    key: "prepareEffects",
    value: function prepareEffects(params) {
      var effects = params.effects;
      var effectProps = {};
      this.lastPostProcessEffect = null;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;
          Object.assign(effectProps, effect.prepare(this.gl, params));

          if (effect instanceof _postProcessEffect.default) {
            this.lastPostProcessEffect = effect;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (this.lastPostProcessEffect) {
        this.prepareRenderBuffers();
      }

      return effectProps;
    }
  }, {
    key: "prepareRenderBuffers",
    value: function prepareRenderBuffers() {
      if (!this.screenBuffer) {
        this.screenBuffer = new _core.Framebuffer(this.gl);
      }

      this.screenBuffer.resize();

      if (!this.offscreenBuffer) {
        this.offscreenBuffer = new _core.Framebuffer(this.gl);
      }

      this.offscreenBuffer.resize();
    }
  }, {
    key: "postRender",
    value: function postRender(effects) {
      var params = {
        inputBuffer: this.screenBuffer,
        outputBuffer: this.offscreenBuffer,
        target: null
      };
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var effect = _step2.value;

          if (effect instanceof _postProcessEffect.default) {
            if (effect === this.lastPostProcessEffect) {
              Object.assign(params, {
                target: _core.Framebuffer.getDefaultFramebuffer(this.gl)
              });
              params = effect.render(params);
              break;
            }

            params = effect.render(params);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "logRenderStats",
    value: function logRenderStats(_ref2) {
      var renderStats = _ref2.renderStats,
          pass = _ref2.pass,
          redrawReason = _ref2.redrawReason,
          stats = _ref2.stats;
      var totalCount = renderStats.totalCount,
          visibleCount = renderStats.visibleCount,
          compositeCount = renderStats.compositeCount,
          pickableCount = renderStats.pickableCount;
      var primitiveCount = totalCount - compositeCount;
      var hiddenCount = primitiveCount - visibleCount;
      var message = '';
      message += "RENDER #".concat(this.renderCount, " ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, " ");

      if (_log.default.priority > LOG_PRIORITY_DRAW) {
        message += "(".concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)");
      }

      _log.default.log(LOG_PRIORITY_DRAW, message)();

      if (stats) {
        stats.get('Redraw Layers').add(visibleCount);
      }
    }
  }]);
  return DeckRenderer;
}();

exports.default = DeckRenderer;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","../passes/draw-layers-pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js","../passes/pick-layers-pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","../utils/get-pixel-ratio":"../../../node_modules/@deck.gl/core/dist/esm/utils/get-pixel-ratio.js","../effects/post-process-effect":"../../../node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClosestObject = getClosestObject;
exports.getUniqueObjects = getUniqueObjects;

var _log = _interopRequireDefault(require("../../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedLayer: null,
  pickedObjectIndex: -1
};

function getClosestObject(_ref) {
  var pickedColors = _ref.pickedColors,
      layers = _ref.layers,
      deviceX = _ref.deviceX,
      deviceY = _ref.deviceY,
      deviceRadius = _ref.deviceRadius,
      deviceRect = _ref.deviceRect;

  if (pickedColors) {
    var x = deviceRect.x,
        y = deviceRect.y,
        width = deviceRect.width,
        height = deviceRect.height;
    var minSquareDistanceToCenter = deviceRadius * deviceRadius;
    var closestPixelIndex = -1;
    var i = 0;

    for (var row = 0; row < height; row++) {
      var dy = row + y - deviceY;
      var dy2 = dy * dy;

      if (dy2 > minSquareDistanceToCenter) {
        i += 4 * width;
      } else {
        for (var col = 0; col < width; col++) {
          var pickedLayerIndex = pickedColors[i + 3] - 1;

          if (pickedLayerIndex >= 0) {
            var dx = col + x - deviceX;
            var d2 = dx * dx + dy2;

            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i;
            }
          }

          i += 4;
        }
      }
    }

    if (closestPixelIndex >= 0) {
      var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;

      var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      var pickedLayer = layers[_pickedLayerIndex];

      if (pickedLayer) {
        var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
        return {
          pickedColor: pickedColor,
          pickedLayer: pickedLayer,
          pickedObjectIndex: pickedObjectIndex
        };
      }

      _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
    }
  }

  return NO_PICKED_OBJECT;
}

function getUniqueObjects(_ref2) {
  var pickedColors = _ref2.pickedColors,
      layers = _ref2.layers;
  var uniqueColors = new Map();

  if (pickedColors) {
    for (var i = 0; i < pickedColors.length; i += 4) {
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var pickedColor = pickedColors.slice(i, i + 4);
        var colorKey = pickedColor.join(',');

        if (!uniqueColors.has(colorKey)) {
          var pickedLayer = layers[pickedLayerIndex];

          if (pickedLayer) {
            uniqueColors.set(colorKey, {
              pickedColor: pickedColor,
              pickedLayer: pickedLayer,
              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
            });
          } else {
            _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
          }
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
}
},{"../../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processPickInfo = processPickInfo;
exports.getLayerPickingInfo = getLayerPickingInfo;

function processPickInfo(_ref) {
  var pickInfo = _ref.pickInfo,
      lastPickedInfo = _ref.lastPickedInfo,
      mode = _ref.mode,
      layers = _ref.layers,
      viewports = _ref.viewports,
      x = _ref.x,
      y = _ref.y,
      deviceX = _ref.deviceX,
      deviceY = _ref.deviceY,
      pixelRatio = _ref.pixelRatio;
  var pickedColor = pickInfo.pickedColor,
      pickedLayer = pickInfo.pickedLayer,
      pickedObjectIndex = pickInfo.pickedObjectIndex;
  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });

        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }

  var viewport = getViewportFromCoordinates({
    viewports: viewports
  });
  var coordinate = viewport && viewport.unproject([x, y]);
  var baseInfo = {
    color: null,
    layer: null,
    index: -1,
    picked: false,
    x: x,
    y: y,
    pixel: [x, y],
    coordinate: coordinate,
    lngLat: coordinate,
    devicePixel: [deviceX, deviceY],
    pixelRatio: pixelRatio
  };
  var infos = new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({
      layer: layer,
      info: info,
      mode: mode
    });

    if (layer === pickedLayer && mode === 'hover') {
      lastPickedInfo.info = info;
    }

    if (info) {
      infos.set(info.layer.id, info);
    }

    if (mode === 'hover') {
      var pickingSelectedColor = layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;
      layer.setModuleParameters({
        pickingSelectedColor: pickingSelectedColor
      });
      layer.setNeedsRedraw();
    }
  });
  return infos;
}

function getLayerPickingInfo(_ref2) {
  var layer = _ref2.layer,
      info = _ref2.info,
      mode = _ref2.mode;

  while (layer && info) {
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    info = layer.pickLayer({
      info: info,
      mode: mode,
      sourceLayer: sourceLayer
    });
    layer = layer.parent;
  }

  return info;
}

function getViewportFromCoordinates(_ref3) {
  var viewports = _ref3.viewports;
  var viewport = viewports[0];
  return viewport;
}
},{}],"../../../node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _core = require("@luma.gl/core");

var _getPixelRatio = _interopRequireDefault(require("../utils/get-pixel-ratio"));

var _assert = _interopRequireDefault(require("../utils/assert"));

var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));

var _queryObject = require("./picking/query-object");

var _pickInfo = require("./picking/pick-info");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DeckPicker = function () {
  function DeckPicker(gl) {
    (0, _classCallCheck2.default)(this, DeckPicker);
    this.gl = gl;
    this.pickingFBO = null;
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.pixelRatio = null;
    this.layerFilter = null;
    this.pickingEvent = null;
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }

  (0, _createClass2.default)(DeckPicker, [{
    key: "setProps",
    value: function setProps(props) {
      if ('useDevicePixels' in props) {
        this.pixelRatio = (0, _getPixelRatio.default)(props.useDevicePixels);
      }

      if ('layerFilter' in props) {
        this.layerFilter = props.layerFilter;
      }

      this.pickLayersPass.setProps({
        pixelRatio: this.pixelRatio,
        layerFilter: this.layerFilter
      });
    }
  }, {
    key: "pickObject",
    value: function pickObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          mode = _ref.mode,
          _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 0 : _ref$radius,
          layers = _ref.layers,
          viewports = _ref.viewports,
          activateViewport = _ref.activateViewport,
          _ref$depth = _ref.depth,
          depth = _ref$depth === void 0 ? 1 : _ref$depth,
          _ref$event = _ref.event,
          event = _ref$event === void 0 ? null : _ref$event;
      this.pickingEvent = event;
      var result = this.pickClosestObject({
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        mode: mode,
        depth: depth,
        viewports: viewports,
        onViewportActive: activateViewport
      });
      this.pickingEvent = null;
      return result;
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          width = _ref2.width,
          height = _ref2.height,
          layers = _ref2.layers,
          viewports = _ref2.viewports,
          activateViewport = _ref2.activateViewport;
      return this.pickVisibleObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        mode: 'pickObjects',
        viewports: viewports,
        onViewportActive: activateViewport
      });
    }
  }, {
    key: "getLastPickedObject",
    value: function getLastPickedObject(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          layers = _ref3.layers,
          viewports = _ref3.viewports;
      var lastPickedInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lastPickedInfo.info;
      var lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
      var layer = lastPickedLayerId ? layers.find(function (l) {
        return l.id === lastPickedLayerId;
      }) : null;
      var coordinate = viewports[0] && viewports[0].unproject([x, y]);
      var info = {
        x: x,
        y: y,
        coordinate: coordinate,
        lngLat: coordinate,
        layer: layer
      };

      if (layer) {
        return Object.assign({}, lastPickedInfo, info);
      }

      return Object.assign(info, {
        color: null,
        object: null,
        index: -1
      });
    }
  }, {
    key: "updatePickingBuffer",
    value: function updatePickingBuffer() {
      var gl = this.gl;

      if (!this.pickingFBO) {
        this.pickingFBO = new _core.Framebuffer(gl);
      }

      this.pickingFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
      return this.pickingFBO;
    }
  }, {
    key: "pickClosestObject",
    value: function pickClosestObject(_ref4) {
      var layers = _ref4.layers,
          viewports = _ref4.viewports,
          x = _ref4.x,
          y = _ref4.y,
          radius = _ref4.radius,
          _ref4$depth = _ref4.depth,
          depth = _ref4$depth === void 0 ? 1 : _ref4$depth,
          mode = _ref4.mode,
          onViewportActive = _ref4.onViewportActive;
      this.updatePickingBuffer();
      var pixelRatio = this.pixelRatio;
      var deviceX = Math.round(x * pixelRatio);
      var deviceY = Math.round(this.gl.canvas.height - y * pixelRatio);
      var deviceRadius = Math.round(radius * pixelRatio);
      var _this$pickingFBO = this.pickingFBO,
          width = _this$pickingFBO.width,
          height = _this$pickingFBO.height;
      var deviceRect = this.getPickingRect({
        deviceX: deviceX,
        deviceY: deviceY,
        deviceRadius: deviceRadius,
        deviceWidth: width,
        deviceHeight: height
      });
      var infos;
      var result = [];
      var affectedLayers = {};

      for (var i = 0; i < depth; i++) {
        var pickedColors = deviceRect && this.drawAndSamplePickingBuffer({
          layers: layers,
          viewports: viewports,
          onViewportActive: onViewportActive,
          deviceRect: deviceRect,
          redrawReason: mode
        });
        var pickInfo = (0, _queryObject.getClosestObject)({
          pickedColors: pickedColors,
          layers: layers,
          deviceX: deviceX,
          deviceY: deviceY,
          deviceRadius: deviceRadius,
          deviceRect: deviceRect
        });

        if (pickInfo.pickedColor && i + 1 < depth) {
          var layerId = pickInfo.pickedColor[3] - 1;

          if (!affectedLayers[layerId]) {
            affectedLayers[layerId] = layers[layerId].copyPickingColors();
          }

          layers[layerId].clearPickingColor(pickInfo.pickedColor);
        }

        infos = (0, _pickInfo.processPickInfo)({
          pickInfo: pickInfo,
          lastPickedInfo: this.lastPickedInfo,
          mode: mode,
          layers: layers,
          viewports: viewports,
          x: x,
          y: y,
          deviceX: deviceX,
          deviceY: deviceY,
          pixelRatio: pixelRatio
        });
        var processedPickInfos = this.callLayerPickingCallbacks(infos, mode);

        if (processedPickInfos) {
          processedPickInfos.forEach(function (info) {
            return result.push(info);
          });
        }

        if (!pickInfo.pickedColor) {
          break;
        }
      }

      Object.keys(affectedLayers).forEach(function (layerId) {
        return layers[layerId].restorePickingColors(affectedLayers[layerId]);
      });
      return {
        result: result,
        emptyInfo: infos && infos.get(null)
      };
    }
  }, {
    key: "pickVisibleObjects",
    value: function pickVisibleObjects(_ref5) {
      var layers = _ref5.layers,
          viewports = _ref5.viewports,
          x = _ref5.x,
          y = _ref5.y,
          width = _ref5.width,
          height = _ref5.height,
          mode = _ref5.mode,
          onViewportActive = _ref5.onViewportActive;
      this.updatePickingBuffer();
      var pixelRatio = this.pixelRatio;
      var deviceLeft = Math.round(x * pixelRatio);
      var deviceBottom = Math.round(this.gl.canvas.height - y * pixelRatio);
      var deviceRight = Math.round((x + width) * pixelRatio);
      var deviceTop = Math.round(this.gl.canvas.height - (y + height) * pixelRatio);
      var deviceRect = {
        x: deviceLeft,
        y: deviceTop,
        width: deviceRight - deviceLeft,
        height: deviceBottom - deviceTop
      };
      var pickedColors = this.drawAndSamplePickingBuffer({
        layers: layers,
        viewports: viewports,
        onViewportActive: onViewportActive,
        deviceRect: deviceRect,
        redrawReason: mode
      });
      var pickInfos = (0, _queryObject.getUniqueObjects)({
        pickedColors: pickedColors,
        layers: layers
      });
      var uniqueInfos = new Map();
      pickInfos.forEach(function (pickInfo) {
        var info = {
          color: pickInfo.pickedColor,
          layer: null,
          index: pickInfo.pickedObjectIndex,
          picked: true,
          x: x,
          y: y,
          width: width,
          height: height,
          pixelRatio: pixelRatio
        };
        info = (0, _pickInfo.getLayerPickingInfo)({
          layer: pickInfo.pickedLayer,
          info: info,
          mode: mode
        });

        if (!uniqueInfos.has(info.object)) {
          uniqueInfos.set(info.object, info);
        }
      });
      return Array.from(uniqueInfos.values());
    }
  }, {
    key: "drawAndSamplePickingBuffer",
    value: function drawAndSamplePickingBuffer(_ref6) {
      var layers = _ref6.layers,
          viewports = _ref6.viewports,
          onViewportActive = _ref6.onViewportActive,
          deviceRect = _ref6.deviceRect,
          redrawReason = _ref6.redrawReason;
      (0, _assert.default)(deviceRect);
      (0, _assert.default)(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');
      (0, _assert.default)(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');
      var pickableLayers = layers.filter(function (layer) {
        return layer.isPickable();
      });

      if (pickableLayers.length < 1) {
        return null;
      }

      var pickingFBO = this.pickingFBO;
      var effectProps = {
        lightSources: {}
      };
      this.pickLayersPass.render({
        layers: layers,
        viewports: viewports,
        onViewportActive: onViewportActive,
        pickingFBO: pickingFBO,
        deviceRect: deviceRect,
        redrawReason: redrawReason,
        effectProps: effectProps
      });
      var x = deviceRect.x,
          y = deviceRect.y,
          width = deviceRect.width,
          height = deviceRect.height;
      var pickedColors = new Uint8Array(width * height * 4);
      (0, _core.readPixelsToArray)(pickingFBO, {
        sourceX: x,
        sourceY: y,
        sourceWidth: width,
        sourceHeight: height,
        target: pickedColors
      });
      return pickedColors;
    }
  }, {
    key: "getPickingRect",
    value: function getPickingRect(_ref7) {
      var deviceX = _ref7.deviceX,
          deviceY = _ref7.deviceY,
          deviceRadius = _ref7.deviceRadius,
          deviceWidth = _ref7.deviceWidth,
          deviceHeight = _ref7.deviceHeight;
      var valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight;

      if (!valid) {
        return null;
      }

      var x = Math.max(0, deviceX - deviceRadius);
      var y = Math.max(0, deviceY - deviceRadius);
      var width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;
      var height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    }
  }, {
    key: "callLayerPickingCallbacks",
    value: function callLayerPickingCallbacks(infos, mode) {
      var unhandledPickInfos = [];
      var pickingEvent = this.pickingEvent;
      infos.forEach(function (info) {
        if (!info.layer) {
          return;
        }

        var handled = false;

        switch (mode) {
          case 'hover':
            handled = info.layer.onHover(info, pickingEvent);
            break;

          case 'query':
            break;

          default:
            throw new Error('unknown pick type');
        }

        if (!handled) {
          unhandledPickInfos.push(info);
        }
      });
      return unhandledPickInfos;
    }
  }]);
  return DeckPicker;
}();

exports.default = DeckPicker;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","../utils/get-pixel-ratio":"../../../node_modules/@deck.gl/core/dist/esm/utils/get-pixel-ratio.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js","../passes/pick-layers-pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","./picking/query-object":"../../../node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js","./picking/pick-info":"../../../node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js"}],"../../../node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enhancePointerEventInput = enhancePointerEventInput;
exports.enhanceMouseInput = enhanceMouseInput;

/**
 * This file contains overrides the default
 * hammer.js functions to add our own utility
 */

/* Hammer.js constants */
var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};
/**
 * Helper function that returns true if any element in an array meets given criteria.
 * Because older browsers do not support `Array.prototype.some`
 * @params array {Array}
 * @params predict {Function}
 */

function some(array, predict) {
  for (var i = 0; i < array.length; i++) {
    if (predict(array[i])) {
      return true;
    }
  }

  return false;
}
/* eslint-disable no-invalid-this */


function enhancePointerEventInput(PointerEventInput) {
  var oldHandler = PointerEventInput.prototype.handler; // overrides PointerEventInput.handler to accept right mouse button

  PointerEventInput.prototype.handler = function handler(ev) {
    var store = this.store; // Allow non-left mouse buttons through

    if (ev.button > 0) {
      if (!some(store, function (e) {
        return e.pointerId === ev.pointerId;
      })) {
        store.push(ev);
      }
    }

    oldHandler.call(this, ev);
  };
} // overrides MouseInput.handler to accept right mouse button


function enhanceMouseInput(MouseInput) {
  MouseInput.prototype.handler = function handler(ev) {
    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the mouse button down

    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }

    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    } // mouse must be down


    if (!this.pressed) {
      return;
    }

    if (eventType & INPUT_END) {
      this.pressed = false;
    }

    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: 'mouse',
      srcEvent: ev
    });
  };
}
},{}],"../../../node_modules/hammerjs/hammer.js":[function(require,module,exports) {
var define;
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function (window, document, exportName, undefined) {
  'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;
  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */

  function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
  }
  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */


  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }

    return false;
  }
  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */


  function each(obj, iterator, context) {
    var i;

    if (!obj) {
      return;
    }

    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;

      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }
  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */


  function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function () {
      var e = new Error('get-stack-trace');
      var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
      var log = window.console && (window.console.warn || window.console.log);

      if (log) {
        log.call(window.console, deprecationMessage, stack);
      }

      return method.apply(this, arguments);
    };
  }
  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */


  var assign;

  if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];

        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }

      return output;
    };
  } else {
    assign = Object.assign;
  }
  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */


  var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;

    while (i < keys.length) {
      if (!merge || merge && dest[keys[i]] === undefined) {
        dest[keys[i]] = src[keys[i]];
      }

      i++;
    }

    return dest;
  }, 'extend', 'Use `assign`.');
  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */

  var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');
  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */

  function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
      assign(childP, properties);
    }
  }
  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */


  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }
  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */


  function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }

    return val;
  }
  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */


  function ifUndefined(val1, val2) {
    return val1 === undefined ? val2 : val1;
  }
  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.addEventListener(type, handler, false);
    });
  }
  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.removeEventListener(type, handler, false);
    });
  }
  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */


  function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }

      node = node.parentNode;
    }

    return false;
  }
  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */


  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }
  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */


  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }
  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */


  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;

      while (i < src.length) {
        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
          return i;
        }

        i++;
      }

      return -1;
    }
  }
  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */


  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }
  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */


  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
      var val = key ? src[i][key] : src[i];

      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }

      values[i] = val;
      i++;
    }

    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function sortUniqueArray(a, b) {
          return a[key] > b[key];
        });
      }
    }

    return results;
  }
  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */


  function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;

    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = prefix ? prefix + camelProp : property;

      if (prop in obj) {
        return prop;
      }

      i++;
    }

    return undefined;
  }
  /**
   * get a unique id
   * @returns {number} uniqueId
   */


  var _uniqueId = 1;

  function uniqueId() {
    return _uniqueId++;
  }
  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */


  function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return doc.defaultView || doc.parentWindow || window;
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = 'ontouchstart' in window;
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];
  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */

  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.

    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }

  Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function () {},

    /**
     * bind the events
     */
    init: function () {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function () {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };
  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */

  function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }

    return new Type(manager, inputHandler);
  }
  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */


  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
      manager.session = {};
    } // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'


    input.eventType = eventType; // compute scale, rotation etc

    computeInputData(manager, input); // emit secret event

    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }
  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */


  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length; // store the first input to calculate the distance and direction

    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    } // to compute scale and rotation we need to store the multiple touches


    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    computeIntervalInputData(session, input); // find the correct target

    var target = manager.element;

    if (hasParent(input.srcEvent.target, target)) {
      target = input.srcEvent.target;
    }

    input.target = target;
  }

  function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }
  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */


  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity,
        velocityX,
        velocityY,
        direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = input.deltaX - last.deltaX;
      var deltaY = input.deltaY - last.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }
  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */


  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;

    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }

    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }
  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */


  function getCenter(pointers) {
    var pointersLength = pointers.length; // no need to loop when only one touch

    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }

    var x = 0,
        y = 0,
        i = 0;

    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }

    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }
  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */


  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }
  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */


  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }

    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }
  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */


  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */


  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }
  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */


  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }
  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */


  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */

  function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }

      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      } // mouse must be down


      if (!this.pressed) {
        return;
      }

      if (eventType & INPUT_END) {
        this.pressed = false;
      }

      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }
  });
  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  }; // in IE10 the pointer types is defined as an enum

  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

  };
  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

  if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }
  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */


  function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    Input.apply(this, arguments);
    this.store = this.manager.session.pointerEvents = [];
  }

  inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store

      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      } // it not found, so the pointer hasn't been down (so it's probably a hover)


      if (storeIndex < 0) {
        return;
      } // update the event in the store


      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });

      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    }
  });
  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * Touch events input
   * @constructor
   * @extends Input
   */

  function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;
    Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

      if (type === INPUT_START) {
        this.started = true;
      }

      if (!this.started) {
        return;
      }

      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });
  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */

  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */

  function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
    Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);

      if (!touches) {
        return;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });
  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */

  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target; // get target touches from touches

    targetTouches = allTouches.filter(function (touch) {
      return hasParent(touch.target, target);
    }); // collect touches

    if (type === INPUT_START) {
      i = 0;

      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    } // filter changed touches to only contain touches that exist in the collected target ids


    i = 0;

    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      } // cleanup removed touches


      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }

      i++;
    }

    if (!changedTargetTouches.length) {
      return;
    }

    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }
  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */


  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function TouchMouseInput() {
    Input.apply(this, arguments);
    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
    this.primaryTouch = null;
    this.lastTouches = [];
  }

  inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
        return;
      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


      if (isTouch) {
        recordTouches.call(this, inputEvent, inputData);
      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
        return;
      }

      this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  });

  function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
      this.primaryTouch = eventData.changedPointers[0].identifier;
      setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      setLastTouch.call(this, eventData);
    }
  }

  function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
      var lastTouch = {
        x: touch.clientX,
        y: touch.clientY
      };
      this.lastTouches.push(lastTouch);
      var lts = this.lastTouches;

      var removeLastTouch = function () {
        var i = lts.indexOf(lastTouch);

        if (i > -1) {
          lts.splice(i, 1);
        }
      };

      setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
  }

  function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX,
        y = eventData.srcEvent.clientY;

    for (var i = 0; i < this.lastTouches.length; i++) {
      var t = this.lastTouches[i];
      var dx = Math.abs(x - t.x),
          dy = Math.abs(y - t.y);

      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
        return true;
      }
    }

    return false;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value

  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();
  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */

  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }

  TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function (value) {
      // find out the touch-action by the event handlers
      if (value == TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }

      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }

      this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function () {
      this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function () {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function (input) {
      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection; // if the touch action did prevented once this session

      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }

      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

      if (hasNone) {
        //do not prevent defaults if this is a tap gesture
        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;

        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }

      if (hasPanX && hasPanY) {
        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
        return;
      }

      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function (srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  };
  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */

  function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning

    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    } // pan-x OR pan-y


    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    } // manipulation


    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
  }

  function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
      return false;
    }

    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
      // If css.supports is not supported but there is native touch-action assume it supports
      // all values. This is the case for IE 10 and 11.
      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
  }
  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */


  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;
  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */

  function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});
    this.id = uniqueId();
    this.manager = null; // default is enable true

    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }

  Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function (options) {
      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

      this.manager && this.manager.touchAction.update();
      return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }

      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }

      return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }

      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }

      return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);

      if (index > -1) {
        this.requireFail.splice(index, 1);
      }

      return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function () {
      return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function (otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function (input) {
      var self = this;
      var state = this.state;

      function emit(event) {
        self.manager.emit(event, input);
      } // 'panstart' and 'panmove'


      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }

      emit(self.options.event); // simple 'eventName' events

      if (input.additionalEvent) {
        // additional event(panleft, panright, pinchin, pinchout...)
        emit(input.additionalEvent);
      } // panend and pancancel


      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function (input) {
      if (this.canEmit()) {
        return this.emit(input);
      } // it's failing anyway


      this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function () {
      var i = 0;

      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }

        i++;
      }

      return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function (inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?

      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      } // reset when we've reached the end


      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }

      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
      // so trigger an event

      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function (inputData) {},
    // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function () {},

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function () {}
  };
  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */

  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }

    return '';
  }
  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */


  function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
      return 'down';
    } else if (direction == DIRECTION_UP) {
      return 'up';
    } else if (direction == DIRECTION_LEFT) {
      return 'left';
    } else if (direction == DIRECTION_RIGHT) {
      return 'right';
    }

    return '';
  }
  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */


  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;

    if (manager) {
      return manager.get(otherRecognizer);
    }

    return otherRecognizer;
  }
  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */


  function AttrRecognizer() {
    Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
      /**
       * @type {Number}
       * @default 1
       */
      pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function (input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function (input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }

        return state | STATE_CHANGED;
      }

      return STATE_FAILED;
    }
  });
  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */

  function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);
    this.pX = null;
    this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    },
    getTouchAction: function () {
      var direction = this.options.direction;
      var actions = [];

      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }

      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }

      return actions;
    },
    directionTest: function (input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY; // lock to axis?

      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x != this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y != this.pY;
          distance = Math.abs(input.deltaY);
        }
      }

      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    },
    attrTest: function (input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    },
    emit: function (input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);

      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }

      this._super.emit.call(this, input);
    }
  });
  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */

  function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'pinch',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },
    emit: function (input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }

      this._super.emit.call(this, input);
    }
  });
  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */

  function PressRecognizer() {
    Recognizer.apply(this, arguments);
    this._timer = null;
    this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9 // a minimal movement is ok, but keep it low

    },
    getTouchAction: function () {
      return [TOUCH_ACTION_AUTO];
    },
    process: function (input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input; // we only allow little movement
      // and we've reached an end event, so a tap is possible

      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function () {
          this.state = STATE_RECOGNIZED;
          this.tryEmit();
        }, options.time, this);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }

      return STATE_FAILED;
    },
    reset: function () {
      clearTimeout(this._timer);
    },
    emit: function (input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }

      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */

  function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
      event: 'rotate',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  });
  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */

  function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    },
    getTouchAction: function () {
      return PanRecognizer.prototype.getTouchAction.call(this);
    },
    attrTest: function (input) {
      var direction = this.options.direction;
      var velocity;

      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }

      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },
    emit: function (input) {
      var direction = directionStr(input.offsetDirection);

      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this.manager.emit(this.options.event, input);
    }
  });
  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */

  function TapRecognizer() {
    Recognizer.apply(this, arguments); // previous time and center,
    // used for tap counting

    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10 // a multi-tap can be a bit off the initial position

    },
    getTouchAction: function () {
      return [TOUCH_ACTION_MANIPULATION];
    },
    process: function (input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();

      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      } // we only allow little movement
      // and we've reached an end event, so a tap is possible


      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType != INPUT_END) {
          return this.failTimeout();
        }

        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;

        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }

        this._input = input; // if tap count matches we have recognized it,
        // else it has began recognizing...

        var tapCount = this.count % options.taps;

        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }

      return STATE_FAILED;
    },
    failTimeout: function () {
      this._timer = setTimeoutContext(function () {
        this.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    },
    reset: function () {
      clearTimeout(this._timer);
    },
    emit: function () {
      if (this.state == STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */

  function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
  }
  /**
   * @const {string}
   */


  Hammer.VERSION = '2.0.7';
  /**
   * default settings
   * @namespace
   */

  Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
    [RotateRecognizer, {
      enable: false
    }], [PinchRecognizer, {
      enable: false
    }, ['rotate']], [SwipeRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }], [PanRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }, ['swipe']], [TapRecognizer], [TapRecognizer, {
      event: 'doubletap',
      taps: 2
    }, ['tap']], [PressRecognizer]],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: 'none',

      /**
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: 'none',

      /**
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: 'none',

      /**
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: 'none',

      /**
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: 'none',

      /**
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: 'rgba(0,0,0,0)'
    }
  };
  var STOP = 1;
  var FORCED_STOP = 2;
  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */

  function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }

  Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function (options) {
      assign(this.options, options); // Options that need a little more setup

      if (options.touchAction) {
        this.touchAction.update();
      }

      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }

      return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function (force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function (inputData) {
      var session = this.session;

      if (session.stopped) {
        return;
      } // run the touch-action polyfill


      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`

      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
      // or when we're in a new session

      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        curRecognizer = session.curRecognizer = null;
      }

      var i = 0;

      while (i < recognizers.length) {
        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.

        if (session.stopped !== FORCED_STOP && ( // 1
        !curRecognizer || recognizer == curRecognizer || // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer


        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }

        i++;
      }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function (recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }

      var recognizers = this.recognizers;

      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event == recognizer) {
          return recognizers[i];
        }
      }

      return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function (recognizer) {
      if (invokeArrayArg(recognizer, 'add', this)) {
        return this;
      } // remove existing


      var existing = this.get(recognizer.options.event);

      if (existing) {
        this.remove(existing);
      }

      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function (recognizer) {
      if (invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }

      recognizer = this.get(recognizer); // let's make sure this recognizer exists

      if (recognizer) {
        var recognizers = this.recognizers;
        var index = inArray(recognizers, recognizer);

        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }

      return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function (events, handler) {
      if (events === undefined) {
        return;
      }

      if (handler === undefined) {
        return;
      }

      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function (events, handler) {
      if (events === undefined) {
        return;
      }

      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function (event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      } // no handlers, so skip it all


      var handlers = this.handlers[event] && this.handlers[event].slice();

      if (!handlers || !handlers.length) {
        return;
      }

      data.type = event;

      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };

      var i = 0;

      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function () {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  };
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */

  function toggleCssProps(manager, add) {
    var element = manager.element;

    if (!element.style) {
      return;
    }

    var prop;
    each(manager.options.cssProps, function (value, name) {
      prop = prefixed(element.style, name);

      if (add) {
        manager.oldCssProps[prop] = element.style[prop];
        element.style[prop] = value;
      } else {
        element.style[prop] = manager.oldCssProps[prop] || '';
      }
    });

    if (!add) {
      manager.oldCssProps = {};
    }
  }
  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */


  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,
    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,
    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,
    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,
    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,
    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,
    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
  }); // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.

  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line

  freeGlobal.Hammer = Hammer;

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return Hammer;
    });
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
  } else {
    window[exportName] = Hammer;
  }
})(window, document, 'Hammer');
},{}],"../../../node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _hammerOverrides = require("./hammer-overrides");

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var hammerjs = null;

if (typeof document !== 'undefined') {
  // Avoid crash if imported in a web worker
  hammerjs = require('hammerjs');
  (0, _hammerOverrides.enhancePointerEventInput)(hammerjs.PointerEventInput);
  (0, _hammerOverrides.enhanceMouseInput)(hammerjs.MouseInput);
}

var _default = hammerjs;
exports.default = _default;
},{"./hammer-overrides":"../../../node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js","hammerjs":"../../../node_modules/hammerjs/hammer.js"}],"../../../node_modules/mjolnir.js/dist/esm/utils/hammer-manager-mock.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = HammerManagerMock;

// Hammer.Manager mock for use in environments without `document` / `window`.
function HammerManagerMock(m) {
  var instance = {};

  var chainedNoop = function chainedNoop() {
    return instance;
  };

  instance.get = function () {
    return null;
  };

  instance.set = chainedNoop;
  instance.on = chainedNoop;
  instance.off = chainedNoop;
  instance.destroy = chainedNoop;
  instance.emit = chainedNoop;
  return instance;
}
},{}],"../../../node_modules/mjolnir.js/dist/esm/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GESTURE_EVENT_ALIASES = exports.EVENT_RECOGNIZER_MAP = exports.INPUT_EVENT_TYPES = exports.BASIC_EVENT_ALIASES = exports.RECOGNIZER_FALLBACK_MAP = exports.RECOGNIZER_COMPATIBLE_MAP = exports.RECOGNIZERS = void 0;

var _hammer = _interopRequireDefault(require("./utils/hammer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// This module contains constants that must be conditionally required
// due to `window`/`document` references downstream.
var RECOGNIZERS = _hammer.default ? [[_hammer.default.Rotate, {
  enable: false
}], [_hammer.default.Pinch, {
  enable: false
}], [_hammer.default.Swipe, {
  enable: false
}], [_hammer.default.Pan, {
  threshold: 0,
  enable: false
}], [_hammer.default.Press, {
  enable: false
}], [_hammer.default.Tap, {
  event: 'doubletap',
  taps: 2,
  enable: false
}], // TODO - rename to 'tap' and 'singletap' in the next major release
[_hammer.default.Tap, {
  event: 'anytap',
  enable: false
}], [_hammer.default.Tap, {
  enable: false
}]] : null; // Recognize the following gestures even if a given recognizer succeeds

exports.RECOGNIZERS = RECOGNIZERS;
var RECOGNIZER_COMPATIBLE_MAP = {
  rotate: ['pinch'],
  pan: ['press', 'doubletap', 'anytap', 'tap'],
  doubletap: ['anytap'],
  anytap: ['tap']
}; // Recognize the folling gestures only if a given recognizer fails

exports.RECOGNIZER_COMPATIBLE_MAP = RECOGNIZER_COMPATIBLE_MAP;
var RECOGNIZER_FALLBACK_MAP = {
  doubletap: ['tap']
};
/**
 * Only one set of basic input events will be fired by Hammer.js:
 * either pointer, touch, or mouse, depending on system support.
 * In order to enable an application to be agnostic of system support,
 * alias basic input events into "classes" of events: down, move, and up.
 * See `_onBasicInput()` for usage of these aliases.
 */

exports.RECOGNIZER_FALLBACK_MAP = RECOGNIZER_FALLBACK_MAP;
var BASIC_EVENT_ALIASES = {
  pointerdown: 'pointerdown',
  pointermove: 'pointermove',
  pointerup: 'pointerup',
  touchstart: 'pointerdown',
  touchmove: 'pointermove',
  touchend: 'pointerup',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup'
};
exports.BASIC_EVENT_ALIASES = BASIC_EVENT_ALIASES;
var INPUT_EVENT_TYPES = {
  KEY_EVENTS: ['keydown', 'keyup'],
  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],
  WHEEL_EVENTS: [// Chrome, Safari
  'wheel', // IE
  'mousewheel', // legacy Firefox
  'DOMMouseScroll']
};
/**
 * "Gestural" events are those that have semantic meaning beyond the basic input event,
 * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.
 * Hammer.js handles these with its Recognizer system;
 * this block maps event names to the Recognizers required to detect the events.
 */

exports.INPUT_EVENT_TYPES = INPUT_EVENT_TYPES;
var EVENT_RECOGNIZER_MAP = {
  tap: 'tap',
  anytap: 'anytap',
  doubletap: 'doubletap',
  press: 'press',
  pinch: 'pinch',
  pinchin: 'pinch',
  pinchout: 'pinch',
  pinchstart: 'pinch',
  pinchmove: 'pinch',
  pinchend: 'pinch',
  pinchcancel: 'pinch',
  rotate: 'rotate',
  rotatestart: 'rotate',
  rotatemove: 'rotate',
  rotateend: 'rotate',
  rotatecancel: 'rotate',
  pan: 'pan',
  panstart: 'pan',
  panmove: 'pan',
  panup: 'pan',
  pandown: 'pan',
  panleft: 'pan',
  panright: 'pan',
  panend: 'pan',
  pancancel: 'pan',
  swipe: 'swipe',
  swipeleft: 'swipe',
  swiperight: 'swipe',
  swipeup: 'swipe',
  swipedown: 'swipe'
};
/**
 * Map gestural events typically provided by browsers
 * that are not reported in 'hammer.input' events
 * to corresponding Hammer.js gestures.
 */

exports.EVENT_RECOGNIZER_MAP = EVENT_RECOGNIZER_MAP;
var GESTURE_EVENT_ALIASES = {
  click: 'tap',
  anyclick: 'anytap',
  dblclick: 'doubletap',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup',
  mouseover: 'pointerover',
  mouseout: 'pointerout',
  mouseleave: 'pointerleave'
};
exports.GESTURE_EVENT_ALIASES = GESTURE_EVENT_ALIASES;
},{"./utils/hammer":"../../../node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js"}],"../../../node_modules/mjolnir.js/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.passiveSupported = exports.document = exports.global = exports.window = exports.userAgent = void 0;
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global'

/* global window, global, document, navigator */
var userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';
exports.userAgent = userAgent;
var window_ = typeof window !== 'undefined' ? window : global;
exports.window = window_;
var global_ = typeof global !== 'undefined' ? global : window;
exports.global = global_;
var document_ = typeof document !== 'undefined' ? document : {};
exports.document = document_;

/*
 * Detect whether passive option is supported by the current browser.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   #Safely_detecting_option_support
 */
var passiveSupported = false;
/* eslint-disable accessor-pairs, no-empty */

exports.passiveSupported = passiveSupported;

try {
  var options = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      exports.passiveSupported = passiveSupported = true;
    }

  };
  window_.addEventListener('test', options, options);
  window_.removeEventListener('test', options, options);
} catch (err) {}
},{}],"../../../node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _constants = require("../constants");

var _globals = require("../utils/globals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var firefox = _globals.userAgent.indexOf('firefox') !== -1;
var WHEEL_EVENTS = _constants.INPUT_EVENT_TYPES.WHEEL_EVENTS;
var EVENT_TYPE = 'wheel'; // Constants for normalizing input delta

var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
var WHEEL_DELTA_PER_LINE = 40; // Slow down zoom if shift key is held for more precise zooming

var SHIFT_MULTIPLIER = 0.25;

var WheelInput =
/*#__PURE__*/
function () {
  function WheelInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2.default)(this, WheelInput);
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.events = WHEEL_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    this.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent, _globals.passiveSupported ? {
        passive: false
      } : false);
    });
  }

  (0, _createClass2.default)(WheelInput, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: "enableEventType",
    value: function enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }
    /* eslint-disable complexity, max-statements */

  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (!this.options.enable) {
        return;
      }

      var value = event.deltaY;

      if (_globals.window.WheelEvent) {
        // Firefox doubles the values on retina screens...
        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
          value /= _globals.window.devicePixelRatio;
        }

        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
          value *= WHEEL_DELTA_PER_LINE;
        }
      }

      var wheelPosition = {
        x: event.clientX,
        y: event.clientY
      };

      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
        // This one is definitely a mouse wheel event.
        // Normalize this value to match trackpad.
        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
      }

      if (event.shiftKey && value) {
        value = value * SHIFT_MULTIPLIER;
      }

      this._onWheel(event, -value, wheelPosition);
    }
  }, {
    key: "_onWheel",
    value: function _onWheel(srcEvent, delta, position) {
      this.callback({
        type: EVENT_TYPE,
        center: position,
        delta: delta,
        srcEvent: srcEvent,
        pointerType: 'mouse',
        target: srcEvent.target
      });
    }
  }]);
  return WheelInput;
}();

exports.default = WheelInput;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../constants":"../../../node_modules/mjolnir.js/dist/esm/constants.js","../utils/globals":"../../../node_modules/mjolnir.js/dist/esm/utils/globals.js"}],"../../../node_modules/mjolnir.js/dist/esm/inputs/move-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _constants = require("../constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var MOUSE_EVENTS = _constants.INPUT_EVENT_TYPES.MOUSE_EVENTS;
var MOVE_EVENT_TYPE = 'pointermove';
var OVER_EVENT_TYPE = 'pointerover';
var OUT_EVENT_TYPE = 'pointerout';
var LEAVE_EVENT_TYPE = 'pointerleave';
/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */

var MoveInput =
/*#__PURE__*/
function () {
  function MoveInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2.default)(this, MoveInput);
    this.element = element;
    this.callback = callback;
    this.pressed = false;
    this.options = Object.assign({
      enable: true
    }, options);
    this.enableMoveEvent = this.options.enable;
    this.enableLeaveEvent = this.options.enable;
    this.enableOutEvent = this.options.enable;
    this.enableOverEvent = this.options.enable;
    this.events = MOUSE_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    this.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  (0, _createClass2.default)(MoveInput, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: "enableEventType",
    value: function enableEventType(eventType, enabled) {
      if (eventType === MOVE_EVENT_TYPE) {
        this.enableMoveEvent = enabled;
      }

      if (eventType === OVER_EVENT_TYPE) {
        this.enableOverEvent = enabled;
      }

      if (eventType === OUT_EVENT_TYPE) {
        this.enableOutEvent = enabled;
      }

      if (eventType === LEAVE_EVENT_TYPE) {
        this.enableLeaveEvent = enabled;
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      this.handleOverEvent(event);
      this.handleOutEvent(event);
      this.handleLeaveEvent(event);
      this.handleMoveEvent(event);
    }
  }, {
    key: "handleOverEvent",
    value: function handleOverEvent(event) {
      if (this.enableOverEvent) {
        if (event.type === 'mouseover') {
          this.callback({
            type: OVER_EVENT_TYPE,
            srcEvent: event,
            pointerType: 'mouse',
            target: event.target
          });
        }
      }
    }
  }, {
    key: "handleOutEvent",
    value: function handleOutEvent(event) {
      if (this.enableOutEvent) {
        if (event.type === 'mouseout') {
          this.callback({
            type: OUT_EVENT_TYPE,
            srcEvent: event,
            pointerType: 'mouse',
            target: event.target
          });
        }
      }
    }
  }, {
    key: "handleLeaveEvent",
    value: function handleLeaveEvent(event) {
      if (this.enableLeaveEvent) {
        if (event.type === 'mouseleave') {
          this.callback({
            type: LEAVE_EVENT_TYPE,
            srcEvent: event,
            pointerType: 'mouse',
            target: event.target
          });
        }
      }
    }
  }, {
    key: "handleMoveEvent",
    value: function handleMoveEvent(event) {
      if (this.enableMoveEvent) {
        switch (event.type) {
          case 'mousedown':
            if (event.button >= 0) {
              // Button is down
              this.pressed = true;
            }

            break;

          case 'mousemove':
            // Move events use `which` to track the button being pressed
            if (event.which === 0) {
              // Button is not down
              this.pressed = false;
            }

            if (!this.pressed) {
              // Drag events are emitted by hammer already
              // we just need to emit the move event on hover
              this.callback({
                type: MOVE_EVENT_TYPE,
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
              });
            }

            break;

          case 'mouseup':
            this.pressed = false;
            break;

          default:
        }
      }
    }
  }]);
  return MoveInput;
}();

exports.default = MoveInput;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../constants":"../../../node_modules/mjolnir.js/dist/esm/constants.js"}],"../../../node_modules/mjolnir.js/dist/esm/inputs/key-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _constants = require("../constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var KEY_EVENTS = _constants.INPUT_EVENT_TYPES.KEY_EVENTS;
var DOWN_EVENT_TYPE = 'keydown';
var UP_EVENT_TYPE = 'keyup';

var KeyInput =
/*#__PURE__*/
function () {
  function KeyInput(element, callback) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2.default)(this, KeyInput);
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    this.events = KEY_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    element.tabIndex = 1;
    element.style.outline = 'none';
    this.events.forEach(function (event) {
      return element.addEventListener(event, _this.handleEvent);
    });
  }

  (0, _createClass2.default)(KeyInput, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      this.events.forEach(function (event) {
        return _this2.element.removeEventListener(event, _this2.handleEvent);
      });
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: "enableEventType",
    value: function enableEventType(eventType, enabled) {
      if (eventType === DOWN_EVENT_TYPE) {
        this.enableDownEvent = enabled;
      }

      if (eventType === UP_EVENT_TYPE) {
        this.enableUpEvent = enabled;
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      // Ignore if focused on text input
      var targetElement = event.target || event.srcElement;

      if (targetElement.tagName === 'INPUT' && targetElement.type === 'text' || targetElement.tagName === 'TEXTAREA') {
        return;
      }

      if (this.enableDownEvent && event.type === 'keydown') {
        this.callback({
          type: DOWN_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }

      if (this.enableUpEvent && event.type === 'keyup') {
        this.callback({
          type: UP_EVENT_TYPE,
          srcEvent: event,
          key: event.key,
          target: event.target
        });
      }
    }
  }]);
  return KeyInput;
}();

exports.default = KeyInput;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","../constants":"../../../node_modules/mjolnir.js/dist/esm/constants.js"}],"../../../node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var EVENT_TYPE = 'contextmenu';

var ContextmenuInput =
/*#__PURE__*/
function () {
  function ContextmenuInput(element, callback) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2.default)(this, ContextmenuInput);
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.handleEvent = this.handleEvent.bind(this);
    element.addEventListener('contextmenu', this.handleEvent);
  }

  (0, _createClass2.default)(ContextmenuInput, [{
    key: "destroy",
    value: function destroy() {
      this.element.removeEventListener('contextmenu', this.handleEvent);
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */

  }, {
    key: "enableEventType",
    value: function enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (!this.options.enable) {
        return;
      }

      this.callback({
        type: EVENT_TYPE,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: 'mouse',
        target: event.target
      });
    }
  }]);
  return ContextmenuInput;
}();

exports.default = ContextmenuInput;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js"}],"../../../node_modules/mjolnir.js/dist/esm/utils/event-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.whichButtons = whichButtons;
exports.getOffsetPosition = getOffsetPosition;

/* Constants */
var DOWN_EVENT = 1;
var MOVE_EVENT = 2;
var UP_EVENT = 4;
var MOUSE_EVENTS = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
}; // MouseEvent.which https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which

var MOUSE_EVENT_WHICH_LEFT = 1;
var MOUSE_EVENT_WHICH_MIDDLE = 2;
var MOUSE_EVENT_WHICH_RIGHT = 3; // MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button

var MOUSE_EVENT_BUTTON_LEFT = 0;
var MOUSE_EVENT_BUTTON_MIDDLE = 1;
var MOUSE_EVENT_BUTTON_RIGHT = 2; // MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons

var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
/**
 * Extract the involved mouse button
 */

function whichButtons(event) {
  var eventType = MOUSE_EVENTS[event.srcEvent.type];

  if (!eventType) {
    // Not a mouse evet
    return null;
  }

  var _event$srcEvent = event.srcEvent,
      buttons = _event$srcEvent.buttons,
      button = _event$srcEvent.button,
      which = _event$srcEvent.which;
  var leftButton = false;
  var middleButton = false;
  var rightButton = false;

  if ( // button is up, need to find out which one was pressed before
  eventType === UP_EVENT || // moving but does not support `buttons` API
  eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }

  return {
    leftButton: leftButton,
    middleButton: middleButton,
    rightButton: rightButton
  };
}
/**
 * Calculate event position relative to the root element
 */


function getOffsetPosition(event, rootElement) {
  var srcEvent = event.srcEvent; // `center` is a hammer.js event property

  if (!event.center && !Number.isFinite(srcEvent.clientX)) {
    // Not a gestural event
    return null;
  }

  var center = event.center || {
    x: srcEvent.clientX,
    y: srcEvent.clientY
  };
  var rect = rootElement.getBoundingClientRect(); // Fix scale for map affected by a CSS transform.
  // See https://stackoverflow.com/a/26893663/3528533

  var scaleX = rect.width / rootElement.offsetWidth;
  var scaleY = rect.height / rootElement.offsetHeight; // Calculate center relative to the root element

  var offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY
  };
  return {
    center: center,
    offsetCenter: offsetCenter
  };
}
},{}],"../../../node_modules/mjolnir.js/dist/esm/utils/event-registrar.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _eventUtils = require("./event-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EventRegistrar =
/*#__PURE__*/
function () {
  function EventRegistrar(eventManager) {
    (0, _classCallCheck2.default)(this, EventRegistrar);
    this.eventManager = eventManager;
    this.handlers = []; // Element -> handler map

    this.handlersByElement = new Map();
    this.handleEvent = this.handleEvent.bind(this);
  }

  (0, _createClass2.default)(EventRegistrar, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.handlers.length === 0;
    }
  }, {
    key: "add",
    value: function add(type, handler) {
      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'root';
      var handlers = this.handlers,
          handlersByElement = this.handlersByElement;

      if (!handlersByElement.has(srcElement)) {
        handlersByElement.set(srcElement, []);
      }

      var entry = {
        type: type,
        handler: handler,
        srcElement: srcElement
      };
      handlers.push(entry);
      handlersByElement.get(srcElement).push(entry);
    }
  }, {
    key: "remove",
    value: function remove(type, handler) {
      var handlers = this.handlers,
          handlersByElement = this.handlersByElement;

      for (var i = handlers.length - 1; i >= 0; i--) {
        var entry = handlers[i];

        if (entry.type === type && entry.handler === handler) {
          handlers.splice(i, 1);
          var entries = handlersByElement.get(entry.srcElement);
          entries.splice(entries.indexOf(entry), 1);

          if (entries.length === 0) {
            handlersByElement.delete(entry.srcElement);
          }
        }
      }
    }
    /**
     * Handles hammerjs event
     */

  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      if (this.isEmpty()) {
        return;
      }

      var mjolnirEvent = this._normalizeEvent(event);

      var target = event.srcEvent.target;

      while (target && target !== mjolnirEvent.rootElement) {
        this._emit(mjolnirEvent, target);

        if (mjolnirEvent.handled) {
          return;
        }

        target = target.parentNode;
      }

      this._emit(mjolnirEvent, 'root');
    }
    /**
     * Invoke handlers on a particular element
     */

  }, {
    key: "_emit",
    value: function _emit(event, srcElement) {
      var entries = this.handlersByElement.get(srcElement);

      if (entries) {
        var immediatePropagationStopped = false; // Prevents the current event from bubbling up

        var stopPropagation = function stopPropagation() {
          event.handled = true;
        }; // Prevent any remaining listeners from being called


        var stopImmediatePropagation = function stopImmediatePropagation() {
          event.handled = true;
          immediatePropagationStopped = true;
        };

        for (var i = 0; i < entries.length; i++) {
          var _entries$i = entries[i],
              type = _entries$i.type,
              handler = _entries$i.handler;
          handler(Object.assign({}, event, {
            type: type,
            stopPropagation: stopPropagation,
            stopImmediatePropagation: stopImmediatePropagation
          }));

          if (immediatePropagationStopped) {
            break;
          }
        }
      }
    }
    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */

  }, {
    key: "_normalizeEvent",
    value: function _normalizeEvent(event) {
      var rootElement = this.eventManager.element;
      return Object.assign({}, event, (0, _eventUtils.whichButtons)(event), (0, _eventUtils.getOffsetPosition)(event, rootElement), {
        handled: false,
        rootElement: rootElement
      });
    }
  }]);
  return EventRegistrar;
}();

exports.default = EventRegistrar;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./event-utils":"../../../node_modules/mjolnir.js/dist/esm/utils/event-utils.js"}],"../../../node_modules/mjolnir.js/dist/esm/event-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _hammer = _interopRequireDefault(require("./utils/hammer"));

var _hammerManagerMock = _interopRequireDefault(require("./utils/hammer-manager-mock"));

var _wheelInput = _interopRequireDefault(require("./inputs/wheel-input"));

var _moveInput = _interopRequireDefault(require("./inputs/move-input"));

var _keyInput = _interopRequireDefault(require("./inputs/key-input"));

var _contextmenuInput = _interopRequireDefault(require("./inputs/contextmenu-input"));

var _eventRegistrar = _interopRequireDefault(require("./utils/event-registrar"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var DEFAULT_OPTIONS = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: _hammer.default ? _hammer.default.Manager : _hammerManagerMock.default,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: 'none'
}; // Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.

var EventManager =
/*#__PURE__*/
function () {
  function EventManager() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, EventManager);
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    this.events = new Map();
    this._onBasicInput = this._onBasicInput.bind(this);
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.setElement(element); // Register all passed events.

    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  (0, _createClass2.default)(EventManager, [{
    key: "setElement",
    value: function setElement(element) {
      var _this = this;

      if (this.element) {
        // unregister all events
        this.destroy();
      }

      this.element = element;

      if (!element) {
        return;
      }

      var options = this.options;
      var ManagerClass = options.Manager;
      this.manager = new ManagerClass(element, {
        touchAction: options.touchAction,
        recognizers: options.recognizers || _constants.RECOGNIZERS
      }).on('hammer.input', this._onBasicInput);

      if (!options.recognizers) {
        // Set default recognize withs
        // http://hammerjs.github.io/recognize-with/
        Object.keys(_constants.RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {
          var recognizer = _this.manager.get(name);

          if (recognizer) {
            _constants.RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      } // Set recognizer options


      for (var recognizerName in options.recognizerOptions) {
        var recognizer = this.manager.get(recognizerName);

        if (recognizer) {
          var recognizerOption = options.recognizerOptions[recognizerName]; // `enable` is managed by the event registrations

          delete recognizerOption.enable;
          recognizer.set(recognizerOption);
        }
      } // Handle events not handled by Hammer.js:
      // - mouse wheel
      // - pointer/touch/mouse move


      this.wheelInput = new _wheelInput.default(element, this._onOtherEvent, {
        enable: false
      });
      this.moveInput = new _moveInput.default(element, this._onOtherEvent, {
        enable: false
      });
      this.keyInput = new _keyInput.default(element, this._onOtherEvent, {
        enable: false
      });
      this.contextmenuInput = new _contextmenuInput.default(element, this._onOtherEvent, {
        enable: false
      }); // Register all existing events

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
              eventAlias = _step$value[0],
              eventRegistrar = _step$value[1];

          if (!eventRegistrar.isEmpty()) {
            // Enable recognizer for this event.
            this._toggleRecognizer(eventRegistrar.recognizerName, true);

            this.manager.on(eventAlias, eventRegistrar.handleEvent);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } // Tear down internal event management implementations.

  }, {
    key: "destroy",
    value: function destroy() {
      if (this.element) {
        // wheelInput etc. are created in setElement() and therefore
        // cannot exist if there is no element
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.contextmenuInput.destroy();
        this.manager.destroy();
        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.contextmenuInput = null;
        this.manager = null;
        this.element = null;
      }
    } // Register an event handler function to be called on `event`.

  }, {
    key: "on",
    value: function on(event, handler, srcElement) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler, srcElement);
      } else {
        srcElement = handler; // If `event` is a map, call `on()` for each entry.

        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName], srcElement);
        }
      }
    }
    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: "off",
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }
    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: "_toggleRecognizer",
    value: function _toggleRecognizer(name, enabled) {
      var manager = this.manager;

      if (!manager) {
        return;
      }

      var recognizer = manager.get(name);

      if (recognizer && recognizer.options.enable !== enabled) {
        recognizer.set({
          enable: enabled
        });
        var fallbackRecognizers = _constants.RECOGNIZER_FALLBACK_MAP[name];

        if (fallbackRecognizers && !this.options.recognizers) {
          // Set default require failures
          // http://hammerjs.github.io/require-failure/
          fallbackRecognizers.forEach(function (otherName) {
            var otherRecognizer = manager.get(otherName);

            if (enabled) {
              // Wait for this recognizer to fail
              otherRecognizer.requireFailure(name);
              /**
               * This seems to be a bug in hammerjs:
               * requireFailure() adds both ways
               * dropRequireFailure() only drops one way
               * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/
                 recognizer-constructor.js#L136
               */

              recognizer.dropRequireFailure(otherName);
            } else {
              // Do not wait for this recognizer to fail
              otherRecognizer.dropRequireFailure(name);
            }
          });
        }
      }

      this.wheelInput.enableEventType(name, enabled);
      this.moveInput.enableEventType(name, enabled);
      this.keyInput.enableEventType(name, enabled);
      this.contextmenuInput.enableEventType(name, enabled);
    }
    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: "_addEventHandler",
    value: function _addEventHandler(event, handler, srcElement) {
      var manager = this.manager,
          events = this.events; // Alias to a recognized gesture as necessary.

      var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
      var eventRegistrar = events.get(eventAlias);

      if (!eventRegistrar) {
        eventRegistrar = new _eventRegistrar.default(this);
        events.set(eventAlias, eventRegistrar); // Enable recognizer for this event.

        eventRegistrar.recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias; // Listen to the event

        if (manager) {
          manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }

      this._toggleRecognizer(eventRegistrar.recognizerName, true);

      eventRegistrar.add(event, handler, srcElement);
    }
    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: "_removeEventHandler",
    value: function _removeEventHandler(event, handler) {
      var events = this.events; // Alias to a recognized gesture as necessary.

      var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
      var eventRegistrar = events.get(eventAlias);

      if (!eventRegistrar) {
        return;
      }

      eventRegistrar.remove(event, handler);

      if (eventRegistrar.isEmpty()) {
        var recognizerName = eventRegistrar.recognizerName; // Disable recognizer if no more handlers are attached to its events

        var isRecognizerUsed = false;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = events.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var eh = _step2.value;

            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
              isRecognizerUsed = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }
    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: "_onBasicInput",
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;
      var alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];

      if (alias) {
        // fire all events aliased to srcEvent.type
        this.manager.emit(alias, event);
      }
    }
    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: "_onOtherEvent",
    value: function _onOtherEvent(event) {
      // console.log('onotherevent', event.type, event)
      this.manager.emit(event.type, event);
    }
  }]);
  return EventManager;
}();

exports.default = EventManager;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./utils/hammer":"../../../node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js","./utils/hammer-manager-mock":"../../../node_modules/mjolnir.js/dist/esm/utils/hammer-manager-mock.js","./inputs/wheel-input":"../../../node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js","./inputs/move-input":"../../../node_modules/mjolnir.js/dist/esm/inputs/move-input.js","./inputs/key-input":"../../../node_modules/mjolnir.js/dist/esm/inputs/key-input.js","./inputs/contextmenu-input":"../../../node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js","./utils/event-registrar":"../../../node_modules/mjolnir.js/dist/esm/utils/event-registrar.js","./constants":"../../../node_modules/mjolnir.js/dist/esm/constants.js"}],"../../../node_modules/mjolnir.js/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "EventManager", {
  enumerable: true,
  get: function () {
    return _eventManager.default;
  }
});

var _eventManager = _interopRequireDefault(require("./event-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./event-manager":"../../../node_modules/mjolnir.js/dist/esm/event-manager.js"}],"../../../node_modules/@deck.gl/core/dist/esm/lib/deck.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _layerManager = _interopRequireDefault(require("./layer-manager"));

var _viewManager = _interopRequireDefault(require("./view-manager"));

var _mapView = _interopRequireDefault(require("../views/map-view"));

var _effectManager = _interopRequireDefault(require("./effect-manager"));

var _effect = _interopRequireDefault(require("./effect"));

var _deckRenderer = _interopRequireDefault(require("./deck-renderer"));

var _deckPicker = _interopRequireDefault(require("./deck-picker"));

var _log = _interopRequireDefault(require("../utils/log"));

var _core = require("@luma.gl/core");

var _probe = require("probe.gl");

var _mjolnir = require("mjolnir.js");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function noop() {}

var getCursor = function getCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? 'grabbing' : 'grab';
};

function getPropTypes(PropTypes) {
  return {
    id: PropTypes.string,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    layerFilter: PropTypes.func,
    views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    viewState: PropTypes.object,
    effects: PropTypes.arrayOf(PropTypes.instanceOf(_effect.default)),
    controller: PropTypes.oneOfType([PropTypes.func, PropTypes.bool, PropTypes.object]),
    gl: PropTypes.object,
    glOptions: PropTypes.object,
    parameters: PropTypes.object,
    pickingRadius: PropTypes.number,
    useDevicePixels: PropTypes.bool,
    touchAction: PropTypes.string,
    onWebGLInitialized: PropTypes.func,
    onResize: PropTypes.func,
    onViewStateChange: PropTypes.func,
    onBeforeRender: PropTypes.func,
    onAfterRender: PropTypes.func,
    onLoad: PropTypes.func,
    debug: PropTypes.bool,
    drawPickingColors: PropTypes.bool,
    _animate: PropTypes.bool
  };
}

var defaultProps = {
  id: 'deckgl-overlay',
  width: '100%',
  height: '100%',
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  gl: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: true,
  touchAction: 'none',
  _animate: false,
  onWebGLInitialized: noop,
  onResize: noop,
  onViewStateChange: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLoad: noop,
  _onMetrics: null,
  getCursor: getCursor,
  debug: false,
  drawPickingColors: false
};

var Deck = function () {
  function Deck(props) {
    (0, _classCallCheck2.default)(this, Deck);
    props = Object.assign({}, defaultProps, props);
    this.width = 0;
    this.height = 0;
    this.viewManager = null;
    this.layerManager = null;
    this.effectManager = null;
    this.deckRenderer = null;
    this.deckPicker = null;
    this._needsRedraw = true;
    this._pickRequest = {};
    this._lastPointerDownInfo = null;
    this.viewState = props.initialViewState || null;
    this.interactiveState = {
      isDragging: false
    };
    this._onEvent = this._onEvent.bind(this);
    this._onPointerDown = this._onPointerDown.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerLeave = this._onPointerLeave.bind(this);
    this._pickAndCallback = this._pickAndCallback.bind(this);
    this._onRendererInitialized = this._onRendererInitialized.bind(this);
    this._onRenderFrame = this._onRenderFrame.bind(this);
    this._onViewStateChange = this._onViewStateChange.bind(this);
    this._onInteractiveStateChange = this._onInteractiveStateChange.bind(this);

    if (!props.gl) {
      if (typeof document !== 'undefined') {
        this.canvas = this._createCanvas(props);
      }
    }

    this.animationLoop = this._createAnimationLoop(props);
    this.stats = new _probe.Stats({
      id: 'deck.gl'
    });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this.setProps(props);
    this.animationLoop.start();
  }

  (0, _createClass2.default)(Deck, [{
    key: "finalize",
    value: function finalize() {
      this.animationLoop.stop();
      this.animationLoop = null;
      this._lastPointerDownInfo = null;

      if (this.layerManager) {
        this.layerManager.finalize();
        this.layerManager = null;
      }

      if (this.viewManager) {
        this.viewManager.finalize();
        this.viewManager = null;
      }

      if (this.effectManager) {
        this.effectManager.finalize();
        this.effectManager = null;
      }

      if (this.deckRenderer) {
        this.deckRenderer.finalize();
        this.deckRenderer = null;
      }

      if (this.eventManager) {
        this.eventManager.destroy();
      }

      if (!this.props.canvas && !this.props.gl && this.canvas) {
        this.canvas.parentElement.removeChild(this.canvas);
        this.canvas = null;
      }
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.stats.get('setProps Time').timeStart();

      if ('onLayerHover' in props) {
        _log.default.removed('onLayerHover', 'onHover')();
      }

      if ('onLayerClick' in props) {
        _log.default.removed('onLayerClick', 'onClick')();
      }

      props = Object.assign({}, this.props, props);
      this.props = props;

      this._setCanvasSize(props);

      var newProps = Object.assign({}, props, {
        views: this._getViews(this.props),
        width: this.width,
        height: this.height
      });

      var viewState = this._getViewState(props);

      if (viewState) {
        newProps.viewState = viewState;
      }

      if (this.viewManager) {
        this.viewManager.setProps(newProps);
      }

      if (this.layerManager) {
        this.layerManager.setProps(newProps);
      }

      if (this.effectManager) {
        this.effectManager.setProps(newProps);
      }

      if (this.animationLoop) {
        this.animationLoop.setProps(newProps);
      }

      if (this.deckRenderer) {
        this.deckRenderer.setProps(newProps);
      }

      if (this.deckPicker) {
        this.deckPicker.setProps(newProps);
      }

      this.stats.get('setProps Time').timeEnd();
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        clearRedrawFlags: false
      };

      if (this.props._animate) {
        return 'Deck._animate';
      }

      var redraw = this._needsRedraw;

      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }

      var viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
      var layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
      var effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
      var deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
      redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
      return redraw;
    }
  }, {
    key: "redraw",
    value: function redraw(force) {
      if (!this.layerManager) {
        return;
      }

      var redrawReason = force || this.needsRedraw({
        clearRedrawFlags: true
      });

      if (!redrawReason) {
        return;
      }

      this.stats.get('Redraw Count').incrementCount();

      if (this.props._customRender) {
        this.props._customRender(redrawReason);
      } else {
        this._drawLayers(redrawReason);
      }
    }
  }, {
    key: "getViews",
    value: function getViews() {
      return this.viewManager.views;
    }
  }, {
    key: "getViewports",
    value: function getViewports(rect) {
      return this.viewManager.getViewports(rect);
    }
  }, {
    key: "pickObject",
    value: function pickObject(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;
      this.stats.get('Pick Count').incrementCount();
      this.stats.get('pickObject Time').timeStart();
      var layers = this.layerManager.getLayers({
        layerIds: layerIds
      });
      var activateViewport = this.layerManager.activateViewport;
      var selectedInfos = this.deckPicker.pickObject({
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        viewports: this.getViewports({
          x: x,
          y: y
        }),
        activateViewport: activateViewport,
        mode: 'query',
        depth: 1
      }).result;
      this.stats.get('pickObject Time').timeEnd();
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: "pickMultipleObjects",
    value: function pickMultipleObjects(_ref3) {
      var x = _ref3.x,
          y = _ref3.y,
          _ref3$radius = _ref3.radius,
          radius = _ref3$radius === void 0 ? 0 : _ref3$radius,
          _ref3$layerIds = _ref3.layerIds,
          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds,
          _ref3$depth = _ref3.depth,
          depth = _ref3$depth === void 0 ? 10 : _ref3$depth;
      this.stats.get('Pick Count').incrementCount();
      this.stats.get('pickMultipleObjects Time').timeStart();
      var layers = this.layerManager.getLayers({
        layerIds: layerIds
      });
      var activateViewport = this.layerManager.activateViewport;
      var selectedInfos = this.deckPicker.pickObject({
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        viewports: this.getViewports({
          x: x,
          y: y
        }),
        activateViewport: activateViewport,
        mode: 'query',
        depth: depth
      }).result;
      this.stats.get('pickMultipleObjects Time').timeEnd();
      return selectedInfos;
    }
  }, {
    key: "pickObjects",
    value: function pickObjects(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          _ref4$width = _ref4.width,
          width = _ref4$width === void 0 ? 1 : _ref4$width,
          _ref4$height = _ref4.height,
          height = _ref4$height === void 0 ? 1 : _ref4$height,
          _ref4$layerIds = _ref4.layerIds,
          layerIds = _ref4$layerIds === void 0 ? null : _ref4$layerIds;
      this.stats.get('Pick Count').incrementCount();
      this.stats.get('pickObjects Time').timeStart();
      var layers = this.layerManager.getLayers({
        layerIds: layerIds
      });
      var activateViewport = this.layerManager.activateViewport;
      var infos = this.deckPicker.pickObjects({
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        viewports: this.getViewports({
          x: x,
          y: y,
          width: width,
          height: height
        }),
        activateViewport: activateViewport
      });
      this.stats.get('pickObjects Time').timeEnd();
      return infos;
    }
  }, {
    key: "_createCanvas",
    value: function _createCanvas(props) {
      var canvas = props.canvas;

      if (typeof canvas === 'string') {
        canvas = document.getElementById(canvas);
        (0, _assert.default)(canvas);
      }

      if (!canvas) {
        canvas = document.createElement('canvas');
        var parent = props.parent || document.body;
        parent.appendChild(canvas);
      }

      var id = props.id,
          style = props.style;
      canvas.id = id;
      Object.assign(canvas.style, style);
      return canvas;
    }
  }, {
    key: "_setCanvasSize",
    value: function _setCanvasSize(props) {
      if (!this.canvas) {
        return;
      }

      var width = props.width,
          height = props.height;

      if (width || width === 0) {
        width = Number.isFinite(width) ? "".concat(width, "px") : width;
        this.canvas.style.width = width;
      }

      if (height || height === 0) {
        height = Number.isFinite(height) ? "".concat(height, "px") : height;
        this.canvas.style.position = 'absolute';
        this.canvas.style.height = height;
      }
    }
  }, {
    key: "_updateCanvasSize",
    value: function _updateCanvasSize() {
      if (this._checkForCanvasSizeChange()) {
        var width = this.width,
            height = this.height;
        this.viewManager.setProps({
          width: width,
          height: height
        });
        this.props.onResize({
          width: this.width,
          height: this.height
        });
      }
    }
  }, {
    key: "_checkForCanvasSizeChange",
    value: function _checkForCanvasSizeChange() {
      var canvas = this.canvas;

      if (!canvas) {
        return false;
      }

      var newWidth = canvas.clientWidth || canvas.width;
      var newHeight = canvas.clientHeight || canvas.height;

      if (newWidth !== this.width || newHeight !== this.height) {
        this.width = newWidth;
        this.height = newHeight;
        return true;
      }

      return false;
    }
  }, {
    key: "_createAnimationLoop",
    value: function _createAnimationLoop(props) {
      var _this = this;

      var width = props.width,
          height = props.height,
          gl = props.gl,
          glOptions = props.glOptions,
          debug = props.debug,
          useDevicePixels = props.useDevicePixels,
          autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      return new _core.AnimationLoop({
        width: width,
        height: height,
        useDevicePixels: useDevicePixels,
        autoResizeDrawingBuffer: autoResizeDrawingBuffer,
        gl: gl,
        onCreateContext: function onCreateContext(opts) {
          return (0, _core.createGLContext)(Object.assign({}, glOptions, opts, {
            canvas: _this.canvas,
            debug: debug
          }));
        },
        onInitialize: this._onRendererInitialized,
        onRender: this._onRenderFrame,
        onBeforeRender: props.onBeforeRender,
        onAfterRender: props.onAfterRender
      });
    }
  }, {
    key: "_getViewState",
    value: function _getViewState(props) {
      return props.viewState || this.viewState;
    }
  }, {
    key: "_getViews",
    value: function _getViews(props) {
      var views = props.views || [new _mapView.default({
        id: 'default-view'
      })];
      views = Array.isArray(views) ? views : [views];

      if (views.length && props.controller) {
        views[0].props.controller = props.controller;
      }

      return views;
    }
  }, {
    key: "_requestPick",
    value: function _requestPick(_ref5) {
      var event = _ref5.event,
          callback = _ref5.callback,
          mode = _ref5.mode;
      var _pickRequest = this._pickRequest;

      if (event.type === 'pointerleave') {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else {
        var pos = event.offsetCenter;

        if (!pos) {
          return;
        }

        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }

      _pickRequest.callback = callback;
      _pickRequest.event = event;
      _pickRequest.mode = mode;
    }
  }, {
    key: "_pickAndCallback",
    value: function _pickAndCallback() {
      var _pickRequest = this._pickRequest;

      if (_pickRequest.mode) {
        var _this$deckPicker$pick = this.deckPicker.pickObject(Object.assign({
          layers: this.layerManager.getLayers(),
          viewports: this.getViewports(_pickRequest),
          activateViewport: this.layerManager.activateViewport,
          depth: 1
        }, _pickRequest)),
            result = _this$deckPicker$pick.result,
            emptyInfo = _this$deckPicker$pick.emptyInfo;

        if (_pickRequest.callback) {
          var pickedInfo = result.find(function (info) {
            return info.index >= 0;
          }) || emptyInfo;

          _pickRequest.callback(pickedInfo, _pickRequest.event);
        }

        _pickRequest.mode = null;
      }
    }
  }, {
    key: "_updateCursor",
    value: function _updateCursor() {
      if (this.canvas) {
        this.canvas.style.cursor = this.props.getCursor(this.interactiveState);
      }
    }
  }, {
    key: "_updateAnimationProps",
    value: function _updateAnimationProps(animationProps) {
      this.layerManager.context.animationProps = animationProps;
    }
  }, {
    key: "_setGLContext",
    value: function _setGLContext(gl) {
      if (this.layerManager) {
        return;
      }

      if (!this.canvas) {
        this.canvas = gl.canvas;
        (0, _core.trackContextState)(gl, {
          enable: true,
          copyState: true
        });
      }

      (0, _core.setParameters)(gl, {
        blend: true,
        blendFunc: [770, 771, 1, 771],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: 515
      });
      this.props.onWebGLInitialized(gl);
      this.eventManager = new _mjolnir.EventManager(gl.canvas, {
        touchAction: this.props.touchAction,
        events: {
          pointerdown: this._onPointerDown,
          pointermove: this._onPointerMove,
          pointerleave: this._onPointerLeave
        }
      });

      for (var eventType in _constants.EVENTS) {
        this.eventManager.on(eventType, this._onEvent);
      }

      this.viewManager = new _viewManager.default({
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange,
        onInteractiveStateChange: this._onInteractiveStateChange,
        views: this._getViews(this.props),
        viewState: this._getViewState(this.props),
        width: this.width,
        height: this.height
      });
      (0, _assert.default)(this.viewManager);
      var viewport = this.viewManager.getViewports()[0];
      this.layerManager = new _layerManager.default(gl, {
        deck: this,
        stats: this.stats,
        viewport: viewport
      });
      this.effectManager = new _effectManager.default();
      this.deckRenderer = new _deckRenderer.default(gl);
      this.deckPicker = new _deckPicker.default(gl);
      this.setProps(this.props);

      this._updateCanvasSize();

      this.props.onLoad();
    }
  }, {
    key: "_drawLayers",
    value: function _drawLayers(redrawReason, renderOptions) {
      var gl = this.layerManager.context.gl;
      (0, _core.setParameters)(gl, this.props.parameters);
      this.props.onBeforeRender({
        gl: gl
      });
      var layers = this.layerManager.getLayers();
      var activateViewport = this.layerManager.activateViewport;
      this.deckRenderer.renderLayers(Object.assign({
        layers: layers,
        viewports: this.viewManager.getViewports(),
        activateViewport: activateViewport,
        views: this.viewManager.getViews(),
        pass: 'screen',
        redrawReason: redrawReason,
        effects: this.effectManager.getEffects()
      }, renderOptions));
      this.props.onAfterRender({
        gl: gl
      });
    }
  }, {
    key: "_onRendererInitialized",
    value: function _onRendererInitialized(_ref6) {
      var gl = _ref6.gl;

      this._setGLContext(gl);
    }
  }, {
    key: "_onRenderFrame",
    value: function _onRenderFrame(animationProps) {
      this._getFrameStats();

      if (this._metricsCounter++ % 60 === 0) {
        this._getMetrics();

        this.stats.reset();

        _log.default.table(3, this.metrics)();

        if (this.props._onMetrics) {
          this.props._onMetrics(this.metrics);
        }
      }

      this._updateCanvasSize();

      this._updateCursor();

      this.layerManager.updateLayers(animationProps);

      this._updateAnimationProps(animationProps);

      this._pickAndCallback();

      this.redraw(false);

      if (this.viewManager) {
        this.viewManager.updateViewStates(animationProps);
      }
    }
  }, {
    key: "_onViewStateChange",
    value: function _onViewStateChange(params) {
      var viewState = this.props.onViewStateChange(params) || params.viewState;

      if (this.viewState) {
        this.viewState[params.viewId] = viewState;
        this.viewManager.setProps({
          viewState: viewState
        });
      }
    }
  }, {
    key: "_onInteractiveStateChange",
    value: function _onInteractiveStateChange(_ref7) {
      var _ref7$isDragging = _ref7.isDragging,
          isDragging = _ref7$isDragging === void 0 ? false : _ref7$isDragging;

      if (isDragging !== this.interactiveState.isDragging) {
        this.interactiveState.isDragging = isDragging;
      }
    }
  }, {
    key: "_onEvent",
    value: function _onEvent(event) {
      var eventOptions = _constants.EVENTS[event.type];
      var pos = event.offsetCenter;

      if (!eventOptions || !pos) {
        return;
      }

      var layers = this.layerManager.getLayers();
      var info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers: layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      var layer = info.layer;
      var layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
      var rootHandler = this.props[eventOptions.handler];
      var handled = false;

      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }

      if (!handled && rootHandler) {
        rootHandler(info, event);
      }
    }
  }, {
    key: "_onPointerDown",
    value: function _onPointerDown(event) {
      var pos = event.offsetCenter;
      this._lastPointerDownInfo = this.pickObject({
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });
    }
  }, {
    key: "_onPointerMove",
    value: function _onPointerMove(event) {
      if (event.leftButton || event.rightButton) {
        return;
      }

      this._requestPick({
        callback: this.props.onHover,
        event: event,
        mode: 'hover'
      });
    }
  }, {
    key: "_onPointerLeave",
    value: function _onPointerLeave(event) {
      this._requestPick({
        callback: this.props.onHover,
        event: event,
        mode: 'hover'
      });
    }
  }, {
    key: "_getFrameStats",
    value: function _getFrameStats() {
      this.stats.get('frameRate').timeEnd();
      this.stats.get('frameRate').timeStart();
      var animationLoopStats = this.animationLoop.stats;
      this.stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);
      this.stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);
    }
  }, {
    key: "_getMetrics",
    value: function _getMetrics() {
      this.metrics.fps = this.stats.get('frameRate').getHz();
      this.metrics.setPropsTime = this.stats.get('setProps Time').time;
      this.metrics.updateAttributesTime = this.stats.get('Update Attributes').time;
      this.metrics.framesRedrawn = this.stats.get('Redraw Count').count;
      this.metrics.pickTime = this.stats.get('pickObject Time').time + this.stats.get('pickMultipleObjects Time').time + this.stats.get('pickObjects Time').time;
      this.metrics.pickCount = this.stats.get('Pick Count').count;
      this.metrics.gpuTime = this.stats.get('GPU Time').time;
      this.metrics.cpuTime = this.stats.get('CPU Time').time;
      this.metrics.gpuTimePerFrame = this.stats.get('GPU Time').getAverageTime();
      this.metrics.cpuTimePerFrame = this.stats.get('CPU Time').getAverageTime();

      var memoryStats = _core.lumaStats.get('Memory Usage');

      this.metrics.bufferMemory = memoryStats.get('Buffer Memory').count;
      this.metrics.textureMemory = memoryStats.get('Texture Memory').count;
      this.metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;
      this.metrics.gpuMemory = memoryStats.get('GPU Memory').count;
    }
  }]);
  return Deck;
}();

exports.default = Deck;
Deck.getPropTypes = getPropTypes;
Deck.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./layer-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js","./view-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/view-manager.js","../views/map-view":"../../../node_modules/@deck.gl/core/dist/esm/views/map-view.js","./effect-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js","./effect":"../../../node_modules/@deck.gl/core/dist/esm/lib/effect.js","./deck-renderer":"../../../node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./deck-picker":"../../../node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js","../utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","probe.gl":"../../../node_modules/probe.gl/dist/esm/index.js","mjolnir.js":"../../../node_modules/mjolnir.js/dist/esm/index.js","../utils/assert":"../../../node_modules/@deck.gl/core/dist/esm/utils/assert.js","./constants":"../../../node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"../../../node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _math = require("math.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MOVEMENT_SPEED = 1;
var ROTATION_STEP_DEGREES = 2;

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var FirstPersonState = function (_ViewState) {
  (0, _inherits2.default)(FirstPersonState, _ViewState);

  function FirstPersonState(_ref) {
    var _this;

    var width = _ref.width,
        height = _ref.height,
        position = _ref.position,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        longitude = _ref.longitude,
        latitude = _ref.latitude,
        zoom = _ref.zoom,
        _ref$syncBearing = _ref.syncBearing,
        syncBearing = _ref$syncBearing === void 0 ? true : _ref$syncBearing,
        bounds = _ref.bounds,
        startPanEventPosition = _ref.startPanEventPosition,
        startPanPosition = _ref.startPanPosition,
        startRotateCenter = _ref.startRotateCenter,
        startRotateViewport = _ref.startRotateViewport,
        startZoomPos = _ref.startZoomPos,
        startZoom = _ref.startZoom;
    (0, _classCallCheck2.default)(this, FirstPersonState);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FirstPersonState).call(this, {
      width: width,
      height: height,
      position: position,
      bearing: bearing,
      pitch: pitch,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom
    }));
    _this._interactiveState = {
      startPanEventPosition: startPanEventPosition,
      startPanPosition: startPanPosition,
      startRotateCenter: startRotateCenter,
      startRotateViewport: startRotateViewport,
      startZoomPos: startZoomPos,
      startZoom: startZoom
    };
    return _this;
  }

  (0, _createClass2.default)(FirstPersonState, [{
    key: "getInteractiveState",
    value: function getInteractiveState() {
      return this._interactiveState;
    }
  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var _this$_viewportProps = this._viewportProps,
          translationX = _this$_viewportProps.translationX,
          translationY = _this$_viewportProps.translationY;
      return this._getUpdatedState({
        startPanPosition: [translationX, translationY],
        startPanEventPosition: pos
      });
    }
  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;
      var startPanEventPosition = this._interactiveState.startPanEventPosition || startPos;

      if (!startPanEventPosition) {
        return this;
      }

      var _ref4 = this._interactiveState.startPanPosition || [],
          _ref5 = (0, _slicedToArray2.default)(_ref4, 2),
          translationX = _ref5[0],
          translationY = _ref5[1];

      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);
      var deltaX = pos[0] - startPanEventPosition[0];
      var deltaY = pos[1] - startPanEventPosition[1];
      return this._getUpdatedState({
        translationX: translationX + deltaX,
        translationY: translationY - deltaY
      });
    }
  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedState({
        startPanPosition: null,
        startPanPos: null
      });
    }
  }, {
    key: "rotateStart",
    value: function rotateStart(_ref6) {
      var pos = _ref6.pos;
      return this._getUpdatedState({
        startRotateCenter: this._viewportProps.position,
        startRotateViewport: this._viewportProps
      });
    }
  }, {
    key: "rotate",
    value: function rotate(_ref7) {
      var deltaScaleX = _ref7.deltaScaleX,
          deltaScaleY = _ref7.deltaScaleY;

      if (!this._interactiveState.startRotateCenter) {
        return this;
      }

      var _this$_viewportProps2 = this._viewportProps,
          bearing = _this$_viewportProps2.bearing,
          pitch = _this$_viewportProps2.pitch;
      return this._getUpdatedState({
        bearing: bearing + deltaScaleX * 10,
        pitch: pitch - deltaScaleY * 10
      });
    }
  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this._getUpdatedState({
        startRotateCenter: null,
        startRotateViewport: null
      });
    }
  }, {
    key: "zoomStart",
    value: function zoomStart(_ref8) {
      var pos = _ref8.pos;
      return this._getUpdatedState({
        startZoomPos: pos,
        startZoom: this._viewportProps.zoom
      });
    }
  }, {
    key: "zoom",
    value: function zoom(_ref9) {
      var pos = _ref9.pos,
          startPos = _ref9.startPos,
          scale = _ref9.scale;
      var _this$_viewportProps3 = this._viewportProps,
          zoom = _this$_viewportProps3.zoom,
          minZoom = _this$_viewportProps3.minZoom,
          maxZoom = _this$_viewportProps3.maxZoom,
          width = _this$_viewportProps3.width,
          height = _this$_viewportProps3.height,
          translationX = _this$_viewportProps3.translationX,
          translationY = _this$_viewportProps3.translationY;
      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;
      var newZoom = (0, _math.clamp)(zoom * scale, minZoom, maxZoom);
      var deltaX = pos[0] - startZoomPos[0];
      var deltaY = pos[1] - startZoomPos[1];
      var cx = startZoomPos[0] - width / 2;
      var cy = height / 2 - startZoomPos[1];
      var newTranslationX = cx - (cx - translationX) * newZoom / zoom + deltaX;
      var newTranslationY = cy - (cy - translationY) * newZoom / zoom - deltaY;
      return newZoom / zoom < 1 ? this.moveBackward() : this.moveForward();
    }
  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomPos: null,
        startZoom: null
      });
    }
  }, {
    key: "moveLeft",
    value: function moveLeft() {
      var bearing = this._viewportProps.bearing;
      var newBearing = bearing - ROTATION_STEP_DEGREES;
      return this._getUpdatedState({
        bearing: newBearing
      });
    }
  }, {
    key: "moveRight",
    value: function moveRight() {
      var bearing = this._viewportProps.bearing;
      var newBearing = bearing + ROTATION_STEP_DEGREES;
      return this._getUpdatedState({
        bearing: newBearing
      });
    }
  }, {
    key: "moveForward",
    value: function moveForward() {
      var position = this._viewportProps.position;
      var direction = this.getDirection();
      var delta = new _math.Vector3(direction).normalize().scale(MOVEMENT_SPEED);
      return this._getUpdatedState({
        position: new _math.Vector3(position).add(delta)
      });
    }
  }, {
    key: "moveBackward",
    value: function moveBackward() {
      var position = this._viewportProps.position;
      var direction = this.getDirection();
      var delta = new _math.Vector3(direction).normalize().scale(-MOVEMENT_SPEED);
      return this._getUpdatedState({
        position: new _math.Vector3(position).add(delta)
      });
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      var position = this._viewportProps.position;
      var delta = [0, 0, 1];
      return this._getUpdatedState({
        position: new _math.Vector3(position).add(delta)
      });
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      var position = this._viewportProps.position;
      var delta = position[2] >= 1 ? [0, 0, -1] : [0, 0, 0];
      return this._getUpdatedState({
        position: new _math.Vector3(position).add(delta)
      });
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom + 0.2
      });
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom - 0.2
      });
    }
  }, {
    key: "_getUpdatedState",
    value: function _getUpdatedState(newProps) {
      return new FirstPersonState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }
  }]);
  return FirstPersonState;
}(_viewState.default);

var FirstPersonController = function (_Controller) {
  (0, _inherits2.default)(FirstPersonController, _Controller);

  function FirstPersonController(props) {
    (0, _classCallCheck2.default)(this, FirstPersonController);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FirstPersonController).call(this, FirstPersonState, props));
  }

  return FirstPersonController;
}(_controller.default);

exports.default = FirstPersonController;
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"../../../node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/views/first-person-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _math = require("math.gl");

var _firstPersonController = _interopRequireDefault(require("../controllers/first-person-controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDirectionFromBearingAndPitch(_ref) {
  var bearing = _ref.bearing,
      pitch = _ref.pitch;
  var spherical = new _math._SphericalCoordinates({
    bearing: bearing,
    pitch: pitch
  });
  var direction = spherical.toVector3().normalize();
  return direction;
}

var FirstPersonView = function (_View) {
  (0, _inherits2.default)(FirstPersonView, _View);

  function FirstPersonView() {
    (0, _classCallCheck2.default)(this, FirstPersonView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FirstPersonView).apply(this, arguments));
  }

  (0, _createClass2.default)(FirstPersonView, [{
    key: "_getViewport",
    value: function _getViewport(props) {
      var _props$viewState = props.viewState,
          _props$viewState$mode = _props$viewState.modelMatrix,
          modelMatrix = _props$viewState$mode === void 0 ? null : _props$viewState$mode,
          bearing = _props$viewState.bearing,
          _props$viewState$up = _props$viewState.up,
          up = _props$viewState$up === void 0 ? [0, 0, 1] : _props$viewState$up;
      var dir = getDirectionFromBearingAndPitch({
        bearing: bearing,
        pitch: 89
      });
      var center = modelMatrix ? modelMatrix.transformDirection(dir) : dir;
      var viewMatrix = new _math.Matrix4().lookAt({
        eye: [0, 0, 0],
        center: center,
        up: up
      });
      return new _viewport.default(Object.assign({}, props, {
        zoom: null,
        viewMatrix: viewMatrix
      }));
    }
  }, {
    key: "controller",
    get: function get() {
      return this._getControllerProps({
        type: _firstPersonController.default
      });
    }
  }]);
  return FirstPersonView;
}(_view.default);

exports.default = FirstPersonView;
FirstPersonView.displayName = 'FirstPersonView';
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./view":"../../../node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../controllers/first-person-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js"}],"../../../node_modules/@deck.gl/core/dist/esm/views/third-person-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _math = require("math.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDirectionFromBearingAndPitch(_ref) {
  var bearing = _ref.bearing,
      pitch = _ref.pitch;
  var spherical = new _math._SphericalCoordinates({
    bearing: bearing,
    pitch: pitch
  });
  return spherical.toVector3().normalize();
}

var ThirdPersonView = function (_View) {
  (0, _inherits2.default)(ThirdPersonView, _View);

  function ThirdPersonView() {
    (0, _classCallCheck2.default)(this, ThirdPersonView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ThirdPersonView).apply(this, arguments));
  }

  (0, _createClass2.default)(ThirdPersonView, [{
    key: "_getViewport",
    value: function _getViewport(props) {
      var _props$viewState = props.viewState,
          bearing = _props$viewState.bearing,
          pitch = _props$viewState.pitch,
          position = _props$viewState.position,
          up = _props$viewState.up,
          zoom = _props$viewState.zoom;
      var direction = getDirectionFromBearingAndPitch({
        bearing: bearing,
        pitch: pitch
      });
      var distance = zoom * 50;
      var eye = direction.scale(-distance).multiply(new _math.Vector3(1, 1, -1));
      var viewMatrix = new _math.Matrix4().multiplyRight(new _math.Matrix4().lookAt({
        eye: eye,
        center: position,
        up: up
      }));
      return new _viewport.default(Object.assign({}, props, {
        id: this.id,
        zoom: null,
        viewMatrix: viewMatrix
      }));
    }
  }]);
  return ThirdPersonView;
}(_view.default);

exports.default = ThirdPersonView;
ThirdPersonView.displayName = 'ThirdPersonView';
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./view":"../../../node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OrbitState = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _math = require("math.gl");

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transitionManager = require("./transition-manager");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MOVEMENT_SPEED = 50;
var DEFAULT_STATE = {
  orbitAxis: 'Z',
  rotationX: 0,
  rotationOrbit: 0,
  fovy: 50,
  zoom: 0,
  target: [0, 0, 0],
  minZoom: -Infinity,
  maxZoom: Infinity
};
var LINEAR_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(['target', 'zoom', 'rotationX', 'rotationOrbit']),
  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
};

var zoom2Scale = function zoom2Scale(zoom) {
  return Math.pow(2, zoom);
};

var OrbitState = function (_ViewState) {
  (0, _inherits2.default)(OrbitState, _ViewState);

  function OrbitState(_ref) {
    var _this;

    var ViewportType = _ref.ViewportType,
        width = _ref.width,
        height = _ref.height,
        _ref$orbitAxis = _ref.orbitAxis,
        orbitAxis = _ref$orbitAxis === void 0 ? DEFAULT_STATE.orbitAxis : _ref$orbitAxis,
        _ref$rotationX = _ref.rotationX,
        rotationX = _ref$rotationX === void 0 ? DEFAULT_STATE.rotationX : _ref$rotationX,
        _ref$rotationOrbit = _ref.rotationOrbit,
        rotationOrbit = _ref$rotationOrbit === void 0 ? DEFAULT_STATE.rotationOrbit : _ref$rotationOrbit,
        _ref$target = _ref.target,
        target = _ref$target === void 0 ? DEFAULT_STATE.target : _ref$target,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === void 0 ? DEFAULT_STATE.zoom : _ref$zoom,
        _ref$fovy = _ref.fovy,
        fovy = _ref$fovy === void 0 ? DEFAULT_STATE.fovy : _ref$fovy,
        _ref$minZoom = _ref.minZoom,
        minZoom = _ref$minZoom === void 0 ? DEFAULT_STATE.minZoom : _ref$minZoom,
        _ref$maxZoom = _ref.maxZoom,
        maxZoom = _ref$maxZoom === void 0 ? DEFAULT_STATE.maxZoom : _ref$maxZoom,
        startPanPosition = _ref.startPanPosition,
        startTarget = _ref.startTarget,
        startRotationX = _ref.startRotationX,
        startRotationOrbit = _ref.startRotationOrbit,
        startZoomPosition = _ref.startZoomPosition,
        startZoom = _ref.startZoom;
    (0, _classCallCheck2.default)(this, OrbitState);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrbitState).call(this, {
      width: width,
      height: height,
      orbitAxis: orbitAxis,
      rotationX: rotationX,
      rotationOrbit: rotationOrbit,
      target: target,
      fovy: fovy,
      zoom: zoom,
      minZoom: minZoom,
      maxZoom: maxZoom
    }));
    _this._interactiveState = {
      startPanPosition: startPanPosition,
      startTarget: startTarget,
      startRotationX: startRotationX,
      startRotationOrbit: startRotationOrbit,
      startZoomPosition: startZoomPosition,
      startZoom: startZoom
    };
    _this.ViewportType = ViewportType;
    return _this;
  }

  (0, _createClass2.default)(OrbitState, [{
    key: "getViewportProps",
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: "getInteractiveState",
    value: function getInteractiveState() {
      return this._interactiveState;
    }
  }, {
    key: "panStart",
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var target = this._viewportProps.target;
      return this._getUpdatedState({
        startPanPosition: pos,
        startTarget: target
      });
    }
  }, {
    key: "pan",
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;
      var _this$_interactiveSta = this._interactiveState,
          startPanPosition = _this$_interactiveSta.startPanPosition,
          startTarget = _this$_interactiveSta.startTarget;
      var delta = new _math.Vector2(pos).subtract(startPanPosition);
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          startTarget: startTarget,
          pixelOffset: delta
        })
      });
    }
  }, {
    key: "panEnd",
    value: function panEnd() {
      return this._getUpdatedState({
        startPanPosition: null,
        startTarget: null
      });
    }
  }, {
    key: "rotateStart",
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;
      return this._getUpdatedState({
        startRotationX: this._viewportProps.rotationX,
        startRotationOrbit: this._viewportProps.rotationOrbit
      });
    }
  }, {
    key: "rotate",
    value: function rotate(_ref5) {
      var deltaScaleX = _ref5.deltaScaleX,
          deltaScaleY = _ref5.deltaScaleY;
      var _this$_interactiveSta2 = this._interactiveState,
          startRotationX = _this$_interactiveSta2.startRotationX,
          startRotationOrbit = _this$_interactiveSta2.startRotationOrbit;

      if (!Number.isFinite(startRotationX) || !Number.isFinite(startRotationOrbit)) {
        return this;
      }

      var newRotationX = (0, _math.clamp)(startRotationX + deltaScaleY * 180, -89.999, 89.999);
      var newRotationOrbit = (startRotationOrbit + deltaScaleX * 180) % 360;
      return this._getUpdatedState({
        rotationX: newRotationX,
        rotationOrbit: newRotationOrbit,
        isRotating: true
      });
    }
  }, {
    key: "rotateEnd",
    value: function rotateEnd() {
      return this._getUpdatedState({
        startRotationX: null,
        startRotationOrbit: null
      });
    }
  }, {
    key: "shortestPathFrom",
    value: function shortestPathFrom(viewState) {
      var props = Object.assign({}, this._viewportProps);
      return props;
    }
  }, {
    key: "zoomStart",
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;
      return this._getUpdatedState({
        startZoomPosition: pos,
        startTarget: this._viewportProps.target,
        startZoom: this._viewportProps.zoom
      });
    }
  }, {
    key: "zoom",
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;
      var _this$_viewportProps = this._viewportProps,
          zoom = _this$_viewportProps.zoom,
          width = _this$_viewportProps.width,
          height = _this$_viewportProps.height,
          target = _this$_viewportProps.target;
      var _this$_interactiveSta3 = this._interactiveState,
          startZoom = _this$_interactiveSta3.startZoom,
          startZoomPosition = _this$_interactiveSta3.startZoomPosition,
          startTarget = _this$_interactiveSta3.startTarget;

      if (!Number.isFinite(startZoom)) {
        startZoom = zoom;
        startTarget = target;
        startZoomPosition = startPos || pos;
      }

      var newZoom = this._calculateNewZoom({
        scale: scale,
        startZoom: startZoom
      });

      var startScale = zoom2Scale(startZoom);
      var newScale = zoom2Scale(newZoom);
      var dX = (width / 2 - startZoomPosition[0]) * (newScale / startScale - 1);
      var dY = (height / 2 - startZoomPosition[1]) * (newScale / startScale - 1);
      return this._getUpdatedState({
        zoom: newZoom,
        target: this._calculateNewTarget({
          startTarget: startTarget,
          zoom: newZoom,
          pixelOffset: [dX, dY]
        })
      });
    }
  }, {
    key: "zoomEnd",
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null,
        startTarget: null,
        startZoom: null
      });
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({
          scale: 2
        })
      });
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({
          scale: 0.5
        })
      });
    }
  }, {
    key: "moveLeft",
    value: function moveLeft() {
      var pixelOffset = [-MOVEMENT_SPEED, 0];
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          pixelOffset: pixelOffset
        })
      });
    }
  }, {
    key: "moveRight",
    value: function moveRight() {
      var pixelOffset = [MOVEMENT_SPEED, 0];
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          pixelOffset: pixelOffset
        })
      });
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      var pixelOffset = [0, -MOVEMENT_SPEED];
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          pixelOffset: pixelOffset
        })
      });
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      var pixelOffset = [0, MOVEMENT_SPEED];
      return this._getUpdatedState({
        target: this._calculateNewTarget({
          pixelOffset: pixelOffset
        })
      });
    }
  }, {
    key: "rotateLeft",
    value: function rotateLeft() {
      return this._getUpdatedState({
        rotationOrbit: this._viewportProps.rotationOrbit - 15
      });
    }
  }, {
    key: "rotateRight",
    value: function rotateRight() {
      return this._getUpdatedState({
        rotationOrbit: this._viewportProps.rotationOrbit + 15
      });
    }
  }, {
    key: "rotateUp",
    value: function rotateUp() {
      return this._getUpdatedState({
        rotationX: this._viewportProps.rotationX - 10
      });
    }
  }, {
    key: "rotateDown",
    value: function rotateDown() {
      return this._getUpdatedState({
        rotationX: this._viewportProps.rotationX + 10
      });
    }
  }, {
    key: "_calculateNewZoom",
    value: function _calculateNewZoom(_ref8) {
      var scale = _ref8.scale,
          startZoom = _ref8.startZoom;
      var _this$_viewportProps2 = this._viewportProps,
          maxZoom = _this$_viewportProps2.maxZoom,
          minZoom = _this$_viewportProps2.minZoom;

      if (!Number.isFinite(startZoom)) {
        startZoom = this._viewportProps.zoom;
      }

      var zoom = startZoom + Math.log2(scale);
      return (0, _math.clamp)(zoom, minZoom, maxZoom);
    }
  }, {
    key: "_calculateNewTarget",
    value: function _calculateNewTarget(_ref9) {
      var startTarget = _ref9.startTarget,
          zoom = _ref9.zoom,
          pixelOffset = _ref9.pixelOffset;
      var viewportProps = Object.assign({}, this._viewportProps);

      if (Number.isFinite(zoom)) {
        viewportProps.zoom = zoom;
      }

      if (startTarget) {
        viewportProps.target = startTarget;
      }

      var viewport = new this.ViewportType(viewportProps);
      var center = viewport.project(viewportProps.target);
      return viewport.unproject([center[0] - pixelOffset[0], center[1] - pixelOffset[1], center[2]]);
    }
  }, {
    key: "_getUpdatedState",
    value: function _getUpdatedState(newProps) {
      return new OrbitState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }
  }, {
    key: "_applyConstraints",
    value: function _applyConstraints(props) {
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;
      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = zoom < minZoom ? minZoom : zoom;
      return props;
    }
  }]);
  return OrbitState;
}(_viewState.default);

exports.OrbitState = OrbitState;

var OrbitController = function (_Controller) {
  (0, _inherits2.default)(OrbitController, _Controller);

  function OrbitController(props) {
    (0, _classCallCheck2.default)(this, OrbitController);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrbitController).call(this, OrbitState, props));
  }

  (0, _createClass2.default)(OrbitController, [{
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      return LINEAR_TRANSITION_PROPS;
    }
  }]);
  return OrbitController;
}(_controller.default);

exports.default = OrbitController;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","./controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"../../../node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","../transitions/linear-interpolator":"../../../node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","./transition-manager":"../../../node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js"}],"../../../node_modules/@deck.gl/core/dist/esm/views/orbit-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _math = require("math.gl");

var _orbitController = _interopRequireDefault(require("../controllers/orbit-controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEGREES_TO_RADIANS = Math.PI / 180;

function getViewMatrix(_ref) {
  var height = _ref.height,
      fovy = _ref.fovy,
      orbitAxis = _ref.orbitAxis,
      rotationX = _ref.rotationX,
      rotationOrbit = _ref.rotationOrbit,
      zoom = _ref.zoom;
  var distance = 0.5 / Math.tan(fovy * DEGREES_TO_RADIANS / 2);
  var viewMatrix = new _math.Matrix4().lookAt({
    eye: [0, 0, distance]
  });
  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);

  if (orbitAxis === 'Z') {
    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);
  } else {
    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);
  }

  var projectionScale = 1 / (height || 1);
  viewMatrix.scale([projectionScale, projectionScale, projectionScale]);
  return viewMatrix;
}

var OrbitViewport = function (_Viewport) {
  (0, _inherits2.default)(OrbitViewport, _Viewport);

  function OrbitViewport(props) {
    (0, _classCallCheck2.default)(this, OrbitViewport);
    var id = props.id,
        x = props.x,
        y = props.y,
        width = props.width,
        height = props.height,
        _props$fovy = props.fovy,
        fovy = _props$fovy === void 0 ? 50 : _props$fovy,
        near = props.near,
        far = props.far,
        _props$orbitAxis = props.orbitAxis,
        orbitAxis = _props$orbitAxis === void 0 ? 'Z' : _props$orbitAxis,
        _props$target = props.target,
        target = _props$target === void 0 ? [0, 0, 0] : _props$target,
        _props$rotationX = props.rotationX,
        rotationX = _props$rotationX === void 0 ? 0 : _props$rotationX,
        _props$rotationOrbit = props.rotationOrbit,
        rotationOrbit = _props$rotationOrbit === void 0 ? 0 : _props$rotationOrbit,
        _props$zoom = props.zoom,
        zoom = _props$zoom === void 0 ? 0 : _props$zoom;
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrbitViewport).call(this, {
      id: id,
      viewMatrix: getViewMatrix({
        height: height,
        fovy: fovy,
        orbitAxis: orbitAxis,
        rotationX: rotationX,
        rotationOrbit: rotationOrbit,
        zoom: zoom
      }),
      fovy: fovy,
      near: near,
      far: far,
      x: x,
      y: y,
      position: target,
      width: width,
      height: height,
      zoom: zoom
    }));
  }

  return OrbitViewport;
}(_viewport.default);

var OrbitView = function (_View) {
  (0, _inherits2.default)(OrbitView, _View);

  function OrbitView(props) {
    (0, _classCallCheck2.default)(this, OrbitView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrbitView).call(this, Object.assign({}, props, {
      type: OrbitViewport
    })));
  }

  (0, _createClass2.default)(OrbitView, [{
    key: "controller",
    get: function get() {
      return this._getControllerProps({
        type: _orbitController.default,
        ViewportType: OrbitViewport
      });
    }
  }]);
  return OrbitView;
}(_view.default);

exports.default = OrbitView;
OrbitView.displayName = 'OrbitView';
},{"@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./view":"../../../node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../controllers/orbit-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js"}],"../../../node_modules/@deck.gl/core/dist/esm/views/perspective-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEGREES_TO_RADIANS = Math.PI / 180;

var PerspectiveView = function (_View) {
  (0, _inherits2.default)(PerspectiveView, _View);

  function PerspectiveView() {
    (0, _classCallCheck2.default)(this, PerspectiveView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PerspectiveView).apply(this, arguments));
  }

  (0, _createClass2.default)(PerspectiveView, [{
    key: "_getViewport",
    value: function _getViewport(props) {
      var x = props.x,
          y = props.y,
          width = props.width,
          height = props.height,
          viewState = props.viewState;
      var eye = viewState.eye,
          _viewState$lookAt = viewState.lookAt,
          lookAt = _viewState$lookAt === void 0 ? [0, 0, 0] : _viewState$lookAt,
          _viewState$up = viewState.up,
          up = _viewState$up === void 0 ? [0, 1, 0] : _viewState$up;
      var fovy = props.fovy || viewState.fovy || 75;
      var near = props.near || viewState.near || 1;
      var far = props.far || viewState.far || 100;
      var aspect = Number.isFinite(viewState.aspect) ? viewState.aspect : width / height;
      var fovyRadians = fovy * DEGREES_TO_RADIANS;
      return new _viewport.default({
        id: this.id,
        x: x,
        y: y,
        width: width,
        height: height,
        viewMatrix: mat4.lookAt([], eye, lookAt, up),
        projectionMatrix: mat4.perspective([], fovyRadians, aspect, near, far)
      });
    }
  }]);
  return PerspectiveView;
}(_view.default);

exports.default = PerspectiveView;
PerspectiveView.displayName = 'PerspectiveView';
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./view":"../../../node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","gl-matrix/mat4":"../../../node_modules/gl-matrix/esm/mat4.js"}],"../../../node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _controller = _interopRequireDefault(require("./controller"));

var _orbitController = require("./orbit-controller");

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

var _transitionManager = require("./transition-manager");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LINEAR_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: function transitionEasing(t) {
    return t;
  },
  transitionInterpolator: new _linearInterpolator.default(['target', 'zoom']),
  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
};

var OrthographicController = function (_Controller) {
  (0, _inherits2.default)(OrthographicController, _Controller);

  function OrthographicController(props) {
    var _this;

    (0, _classCallCheck2.default)(this, OrthographicController);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrthographicController).call(this, _orbitController.OrbitState, props));
    _this.invertPan = true;
    return _this;
  }

  (0, _createClass2.default)(OrthographicController, [{
    key: "_onPanRotate",
    value: function _onPanRotate(event) {
      return false;
    }
  }, {
    key: "_getTransitionProps",
    value: function _getTransitionProps() {
      return LINEAR_TRANSITION_PROPS;
    }
  }]);
  return OrthographicController;
}(_controller.default);

exports.default = OrthographicController;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./orbit-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js","../transitions/linear-interpolator":"../../../node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","./transition-manager":"../../../node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js"}],"../../../node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _math = require("math.gl");

var _orthographicController = _interopRequireDefault(require("../controllers/orthographic-controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var viewMatrix = new _math.Matrix4().lookAt({
  eye: [0, 0, 1]
});

function getProjectionMatrix(_ref) {
  var width = _ref.width,
      height = _ref.height,
      near = _ref.near,
      far = _ref.far;
  width = width || 1;
  height = height || 1;
  return new _math.Matrix4().ortho({
    left: -width / 2,
    right: width / 2,
    bottom: height / 2,
    top: -height / 2,
    near: near,
    far: far
  });
}

var OrthographicViewport = function (_Viewport) {
  (0, _inherits2.default)(OrthographicViewport, _Viewport);

  function OrthographicViewport(_ref2) {
    var _this;

    var id = _ref2.id,
        x = _ref2.x,
        y = _ref2.y,
        width = _ref2.width,
        height = _ref2.height,
        _ref2$near = _ref2.near,
        near = _ref2$near === void 0 ? 0.1 : _ref2$near,
        _ref2$far = _ref2.far,
        far = _ref2$far === void 0 ? 1000 : _ref2$far,
        _ref2$zoom = _ref2.zoom,
        zoom = _ref2$zoom === void 0 ? 0 : _ref2$zoom,
        _ref2$target = _ref2.target,
        target = _ref2$target === void 0 ? [0, 0, 0] : _ref2$target;
    (0, _classCallCheck2.default)(this, OrthographicViewport);
    return (0, _possibleConstructorReturn2.default)(_this, new _viewport.default({
      id: id,
      x: x,
      y: y,
      width: width,
      height: height,
      position: target,
      viewMatrix: viewMatrix,
      projectionMatrix: getProjectionMatrix({
        width: width,
        height: height,
        near: near,
        far: far
      }),
      zoom: zoom
    }));
  }

  return OrthographicViewport;
}(_viewport.default);

var OrthographicView = function (_View) {
  (0, _inherits2.default)(OrthographicView, _View);

  function OrthographicView(props) {
    (0, _classCallCheck2.default)(this, OrthographicView);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(OrthographicView).call(this, Object.assign({}, props, {
      type: OrthographicViewport
    })));
  }

  (0, _createClass2.default)(OrthographicView, [{
    key: "controller",
    get: function get() {
      return this._getControllerProps({
        type: _orthographicController.default,
        ViewportType: OrthographicViewport
      });
    }
  }]);
  return OrthographicView;
}(_view.default);

exports.default = OrthographicView;
OrthographicView.displayName = 'OrthographicView';
},{"@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./view":"../../../node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","../controllers/orthographic-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js"}],"../../../node_modules/@deck.gl/core/dist/esm/transitions/viewport-fly-to-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));

var _math = require("math.gl");

var _viewportMercatorProject = require("viewport-mercator-project");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];

var FlyToInterpolator = function (_TransitionInterpolat) {
  (0, _inherits2.default)(FlyToInterpolator, _TransitionInterpolat);

  function FlyToInterpolator() {
    (0, _classCallCheck2.default)(this, FlyToInterpolator);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FlyToInterpolator).call(this, {
      compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      extract: ['width', 'height', 'longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      required: ['width', 'height', 'latitude', 'longitude', 'zoom']
    }));
  }

  (0, _createClass2.default)(FlyToInterpolator, [{
    key: "interpolateProps",
    value: function interpolateProps(startProps, endProps, t) {
      var viewport = (0, _viewportMercatorProject.flyToViewport)(startProps, endProps, t);

      for (var _i = 0; _i < LINEARLY_INTERPOLATED_PROPS.length; _i++) {
        var key = LINEARLY_INTERPOLATED_PROPS[_i];
        viewport[key] = (0, _math.lerp)(startProps[key] || 0, endProps[key] || 0, t);
      }

      return viewport;
    }
  }]);
  return FlyToInterpolator;
}(_transitionInterpolator.default);

exports.default = FlyToInterpolator;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./transition-interpolator":"../../../node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","math.gl":"../../../node_modules/math.gl/dist/esm/index.js","viewport-mercator-project":"../../../node_modules/viewport-mercator-project/dist/esm/index.js"}],"../../../node_modules/@deck.gl/core/dist/esm/utils/tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _iterableUtils = require("./iterable-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TypedArrayManager = function () {
  function TypedArrayManager() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$overAlloc = _ref.overAlloc,
        overAlloc = _ref$overAlloc === void 0 ? 1 : _ref$overAlloc;

    (0, _classCallCheck2.default)(this, TypedArrayManager);
    this.overAlloc = overAlloc;
  }

  (0, _createClass2.default)(TypedArrayManager, [{
    key: "allocate",
    value: function allocate(typedArray, count, _ref2) {
      var size = _ref2.size,
          type = _ref2.type,
          _ref2$copy = _ref2.copy,
          copy = _ref2$copy === void 0 ? false : _ref2$copy;
      var newSize = count * size;

      if (typedArray && newSize <= typedArray.length) {
        return typedArray;
      }

      var allocSize = Math.max(Math.ceil(newSize * this.overAlloc), 1);

      var newArray = this._allocate(type, allocSize);

      if (typedArray && copy) {
        newArray.set(typedArray);
      }

      this._release(typedArray);

      return newArray;
    }
  }, {
    key: "_allocate",
    value: function _allocate() {
      var Type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Float32Array;
      var size = arguments.length > 1 ? arguments[1] : undefined;
      return new Type(size);
    }
  }, {
    key: "_release",
    value: function _release(typedArray) {}
  }]);
  return TypedArrayManager;
}();

var Tesselator = function () {
  function Tesselator() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, Tesselator);
    var _opts$attributes = opts.attributes,
        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;
    this.typedArrayManager = new TypedArrayManager();
    this.indexLayout = null;
    this.bufferLayout = null;
    this.vertexCount = 0;
    this.instanceCount = 0;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.updateGeometry(opts);
    Object.seal(this);
  }

  (0, _createClass2.default)(Tesselator, [{
    key: "updateGeometry",
    value: function updateGeometry(_ref3) {
      var data = _ref3.data,
          getGeometry = _ref3.getGeometry,
          positionFormat = _ref3.positionFormat,
          fp64 = _ref3.fp64;
      this.data = data;
      this.getGeometry = getGeometry;
      this.fp64 = fp64;
      this.positionSize = positionFormat === 'XY' ? 2 : 3;

      this._rebuildGeometry();
    }
  }, {
    key: "updatePartialGeometry",
    value: function updatePartialGeometry(_ref4) {
      var startRow = _ref4.startRow,
          endRow = _ref4.endRow;

      this._rebuildGeometry({
        startRow: startRow,
        endRow: endRow
      });
    }
  }, {
    key: "updateGeometryAttributes",
    value: function updateGeometryAttributes(geometry, startIndex, size) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getGeometrySize",
    value: function getGeometrySize(geometry) {
      throw new Error('Not implemented');
    }
  }, {
    key: "_forEachGeometry",
    value: function _forEachGeometry(visitor, startRow, endRow) {
      var data = this.data,
          getGeometry = this.getGeometry;

      var _createIterable = (0, _iterableUtils.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var geometry = getGeometry(object, objectInfo);
          visitor(geometry, objectInfo.index);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "_rebuildGeometry",
    value: function _rebuildGeometry(dataRange) {
      var _this = this;

      if (!this.data || !this.getGeometry) {
        return;
      }

      var indexLayout = this.indexLayout,
          bufferLayout = this.bufferLayout;

      if (!dataRange) {
        indexLayout = [];
        bufferLayout = [];
      }

      var _ref5 = dataRange || {},
          _ref5$startRow = _ref5.startRow,
          startRow = _ref5$startRow === void 0 ? 0 : _ref5$startRow,
          _ref5$endRow = _ref5.endRow,
          endRow = _ref5$endRow === void 0 ? Infinity : _ref5$endRow;

      this._forEachGeometry(function (geometry, dataIndex) {
        bufferLayout[dataIndex] = _this.getGeometrySize(geometry);
      }, startRow, endRow);

      var instanceCount = 0;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = bufferLayout[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var count = _step2.value;
          instanceCount += count;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var attributes = this.attributes,
          _attributeDefs = this._attributeDefs,
          typedArrayManager = this.typedArrayManager,
          fp64 = this.fp64;

      for (var name in _attributeDefs) {
        var def = _attributeDefs[name];
        def.copy = Boolean(dataRange);

        if (!def.fp64Only || fp64) {
          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
        }
      }

      this.indexLayout = indexLayout;
      this.bufferLayout = bufferLayout;
      this.instanceCount = instanceCount;
      var context = {
        vertexStart: 0,
        indexStart: 0
      };

      for (var i = 0; i < startRow; i++) {
        context.vertexStart += bufferLayout[i];
        context.indexStart += indexLayout[i] || 0;
      }

      this._forEachGeometry(function (geometry, dataIndex) {
        var geometrySize = bufferLayout[dataIndex];
        context.geometryIndex = dataIndex;
        context.geometrySize = geometrySize;

        _this.updateGeometryAttributes(geometry, context);

        context.vertexStart += geometrySize;
        context.indexStart += indexLayout[dataIndex] || 0;
      }, startRow, endRow);

      var vertexCount = context.indexStart;

      for (var _i = endRow; _i < indexLayout.length; _i++) {
        vertexCount += indexLayout[_i];
      }

      this.vertexCount = vertexCount;
    }
  }]);
  return Tesselator;
}();

exports.default = Tesselator;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","./iterable-utils":"../../../node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js"}],"../../../node_modules/@deck.gl/core/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COORDINATE_SYSTEM", {
  enumerable: true,
  get: function () {
    return _constants.COORDINATE_SYSTEM;
  }
});
Object.defineProperty(exports, "LightingEffect", {
  enumerable: true,
  get: function () {
    return _lightingEffect.default;
  }
});
Object.defineProperty(exports, "PointLight", {
  enumerable: true,
  get: function () {
    return _pointLight.default;
  }
});
Object.defineProperty(exports, "DirectionalLight", {
  enumerable: true,
  get: function () {
    return _directionalLight.default;
  }
});
Object.defineProperty(exports, "_CameraLight", {
  enumerable: true,
  get: function () {
    return _cameraLight.default;
  }
});
Object.defineProperty(exports, "_SunLight", {
  enumerable: true,
  get: function () {
    return _sunLight.default;
  }
});
Object.defineProperty(exports, "PostProcessEffect", {
  enumerable: true,
  get: function () {
    return _postProcessEffect.default;
  }
});
Object.defineProperty(exports, "_LayersPass", {
  enumerable: true,
  get: function () {
    return _layersPass.default;
  }
});
Object.defineProperty(exports, "Deck", {
  enumerable: true,
  get: function () {
    return _deck.default;
  }
});
Object.defineProperty(exports, "LayerManager", {
  enumerable: true,
  get: function () {
    return _layerManager.default;
  }
});
Object.defineProperty(exports, "AttributeManager", {
  enumerable: true,
  get: function () {
    return _attributeManager.default;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function () {
    return _layer.default;
  }
});
Object.defineProperty(exports, "CompositeLayer", {
  enumerable: true,
  get: function () {
    return _compositeLayer.default;
  }
});
Object.defineProperty(exports, "DeckRenderer", {
  enumerable: true,
  get: function () {
    return _deckRenderer.default;
  }
});
Object.defineProperty(exports, "Viewport", {
  enumerable: true,
  get: function () {
    return _viewport.default;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.default;
  }
});
Object.defineProperty(exports, "project64", {
  enumerable: true,
  get: function () {
    return _project2.default;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function () {
    return _view.default;
  }
});
Object.defineProperty(exports, "MapView", {
  enumerable: true,
  get: function () {
    return _mapView.default;
  }
});
Object.defineProperty(exports, "FirstPersonView", {
  enumerable: true,
  get: function () {
    return _firstPersonView.default;
  }
});
Object.defineProperty(exports, "ThirdPersonView", {
  enumerable: true,
  get: function () {
    return _thirdPersonView.default;
  }
});
Object.defineProperty(exports, "OrbitView", {
  enumerable: true,
  get: function () {
    return _orbitView.default;
  }
});
Object.defineProperty(exports, "PerspectiveView", {
  enumerable: true,
  get: function () {
    return _perspectiveView.default;
  }
});
Object.defineProperty(exports, "OrthographicView", {
  enumerable: true,
  get: function () {
    return _orthographicView.default;
  }
});
Object.defineProperty(exports, "Controller", {
  enumerable: true,
  get: function () {
    return _controller.default;
  }
});
Object.defineProperty(exports, "MapController", {
  enumerable: true,
  get: function () {
    return _mapController.default;
  }
});
Object.defineProperty(exports, "_FirstPersonController", {
  enumerable: true,
  get: function () {
    return _firstPersonController.default;
  }
});
Object.defineProperty(exports, "_OrbitController", {
  enumerable: true,
  get: function () {
    return _orbitController.default;
  }
});
Object.defineProperty(exports, "_OrthographicController", {
  enumerable: true,
  get: function () {
    return _orthographicController.default;
  }
});
Object.defineProperty(exports, "Effect", {
  enumerable: true,
  get: function () {
    return _effect.default;
  }
});
Object.defineProperty(exports, "TRANSITION_EVENTS", {
  enumerable: true,
  get: function () {
    return _transitionManager.TRANSITION_EVENTS;
  }
});
Object.defineProperty(exports, "LinearInterpolator", {
  enumerable: true,
  get: function () {
    return _linearInterpolator.default;
  }
});
Object.defineProperty(exports, "FlyToInterpolator", {
  enumerable: true,
  get: function () {
    return _viewportFlyToInterpolator.default;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "createIterable", {
  enumerable: true,
  get: function () {
    return _iterableUtils.createIterable;
  }
});
Object.defineProperty(exports, "AmbientLight", {
  enumerable: true,
  get: function () {
    return _core.AmbientLight;
  }
});
exports.experimental = void 0;

require("./lib/init");

require("./shaderlib");

var _constants = require("./lib/constants");

var _lightingEffect = _interopRequireDefault(require("./effects/lighting/lighting-effect"));

var _pointLight = _interopRequireDefault(require("./effects/lighting/point-light"));

var _directionalLight = _interopRequireDefault(require("./effects/lighting/directional-light"));

var _cameraLight = _interopRequireDefault(require("./effects/lighting/camera-light"));

var _sunLight = _interopRequireDefault(require("./effects/lighting/sun-light"));

var _postProcessEffect = _interopRequireDefault(require("./effects/post-process-effect"));

var _layersPass = _interopRequireDefault(require("./passes/layers-pass"));

var _deck = _interopRequireDefault(require("./lib/deck"));

var _layerManager = _interopRequireDefault(require("./lib/layer-manager"));

var _attributeManager = _interopRequireDefault(require("./lib/attribute-manager"));

var _layer = _interopRequireDefault(require("./lib/layer"));

var _compositeLayer = _interopRequireDefault(require("./lib/composite-layer"));

var _deckRenderer = _interopRequireDefault(require("./lib/deck-renderer"));

var _viewport = _interopRequireDefault(require("./viewports/viewport"));

var _webMercatorViewport = _interopRequireDefault(require("./viewports/web-mercator-viewport"));

var _project = _interopRequireDefault(require("./shaderlib/project/project"));

var _project2 = _interopRequireDefault(require("./shaderlib/project64/project64"));

var _view = _interopRequireDefault(require("./views/view"));

var _mapView = _interopRequireDefault(require("./views/map-view"));

var _firstPersonView = _interopRequireDefault(require("./views/first-person-view"));

var _thirdPersonView = _interopRequireDefault(require("./views/third-person-view"));

var _orbitView = _interopRequireDefault(require("./views/orbit-view"));

var _perspectiveView = _interopRequireDefault(require("./views/perspective-view"));

var _orthographicView = _interopRequireDefault(require("./views/orthographic-view"));

var _controller = _interopRequireDefault(require("./controllers/controller"));

var _mapController = _interopRequireDefault(require("./controllers/map-controller"));

var _firstPersonController = _interopRequireDefault(require("./controllers/first-person-controller"));

var _orbitController = _interopRequireDefault(require("./controllers/orbit-controller"));

var _orthographicController = _interopRequireDefault(require("./controllers/orthographic-controller"));

var _effect = _interopRequireDefault(require("./lib/effect"));

var _transitionManager = require("./controllers/transition-manager");

var _linearInterpolator = _interopRequireDefault(require("./transitions/linear-interpolator"));

var _viewportFlyToInterpolator = _interopRequireDefault(require("./transitions/viewport-fly-to-interpolator"));

var _log = _interopRequireDefault(require("./utils/log"));

var _flatten = require("./utils/flatten");

var _iterableUtils = require("./utils/iterable-utils");

var _tesselator = _interopRequireDefault(require("./utils/tesselator"));

var _count = require("./utils/count");

var _memoize = _interopRequireDefault(require("./utils/memoize"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var experimental = {
  Tesselator: _tesselator.default,
  flattenVertices: _flatten.flattenVertices,
  fillArray: _flatten.fillArray,
  count: _count.count,
  memoize: _memoize.default
};
exports.experimental = experimental;
},{"./lib/init":"../../../node_modules/@deck.gl/core/dist/esm/lib/init.js","./shaderlib":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/index.js","./lib/constants":"../../../node_modules/@deck.gl/core/dist/esm/lib/constants.js","./effects/lighting/lighting-effect":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js","./effects/lighting/point-light":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","./effects/lighting/directional-light":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","./effects/lighting/camera-light":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js","./effects/lighting/sun-light":"../../../node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js","./effects/post-process-effect":"../../../node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js","./passes/layers-pass":"../../../node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","./lib/deck":"../../../node_modules/@deck.gl/core/dist/esm/lib/deck.js","./lib/layer-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js","./lib/attribute-manager":"../../../node_modules/@deck.gl/core/dist/esm/lib/attribute-manager.js","./lib/layer":"../../../node_modules/@deck.gl/core/dist/esm/lib/layer.js","./lib/composite-layer":"../../../node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js","./lib/deck-renderer":"../../../node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./viewports/viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","./viewports/web-mercator-viewport":"../../../node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","./shaderlib/project/project":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","./shaderlib/project64/project64":"../../../node_modules/@deck.gl/core/dist/esm/shaderlib/project64/project64.js","./views/view":"../../../node_modules/@deck.gl/core/dist/esm/views/view.js","./views/map-view":"../../../node_modules/@deck.gl/core/dist/esm/views/map-view.js","./views/first-person-view":"../../../node_modules/@deck.gl/core/dist/esm/views/first-person-view.js","./views/third-person-view":"../../../node_modules/@deck.gl/core/dist/esm/views/third-person-view.js","./views/orbit-view":"../../../node_modules/@deck.gl/core/dist/esm/views/orbit-view.js","./views/perspective-view":"../../../node_modules/@deck.gl/core/dist/esm/views/perspective-view.js","./views/orthographic-view":"../../../node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js","./controllers/controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./controllers/map-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js","./controllers/first-person-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js","./controllers/orbit-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js","./controllers/orthographic-controller":"../../../node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js","./lib/effect":"../../../node_modules/@deck.gl/core/dist/esm/lib/effect.js","./controllers/transition-manager":"../../../node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js","./transitions/linear-interpolator":"../../../node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","./transitions/viewport-fly-to-interpolator":"../../../node_modules/@deck.gl/core/dist/esm/transitions/viewport-fly-to-interpolator.js","./utils/log":"../../../node_modules/@deck.gl/core/dist/esm/utils/log.js","./utils/flatten":"../../../node_modules/@deck.gl/core/dist/esm/utils/flatten.js","./utils/iterable-utils":"../../../node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./utils/tesselator":"../../../node_modules/@deck.gl/core/dist/esm/utils/tesselator.js","./utils/count":"../../../node_modules/@deck.gl/core/dist/esm/utils/count.js","./utils/memoize":"../../../node_modules/@deck.gl/core/dist/esm/utils/memoize.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertexHeight = sqrt(max(0.0, paraboloid(source, target, segmentRatio))) * instanceHeights;\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target - source);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * vertexHeight * sin(tiltAngle);\n\n  return vec3(\n    mix(source, target, segmentRatio) + tilt,\n    vertexHeight * cos(tiltAngle)\n  );\n}\n\nvoid main(void) {\n  vec2 source = project_position(vec3(instancePositions.xy, 0.0), instancePositions64Low.xy).xy;\n  vec2 target = project_position(vec3(instancePositions.zw, 0.0), instancePositions64Low.zw).xy;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec3 currPos = getPos(source, target, segmentRatio);\n  vec3 nextPos = getPos(source, target, nextSegmentRatio);\n  vec4 curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n  vec4 next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels);\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex-64.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\n\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\n\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\nvec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {\n\n  vec2 x[2];\n  vec2_mix_fp64(source, target, ratio, x);\n  vec2 center[2];\n  vec2_mix_fp64(source, target, 0.5, center);\n\n  vec2 dSourceCenter = vec2_distance_fp64(source, center);\n  vec2 dXCenter = vec2_distance_fp64(x, center);\n  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvoid get_pos_fp64(vec2 source[2], vec2 target[2], float segmentRatio, out vec2 position[4]) {\n\n  vec2 vertex_height = paraboloid_fp64(source, target, segmentRatio);\n\n  vec2 position_temp[2];\n\n  vec2_mix_fp64(source, target, segmentRatio, position_temp);\n\n  position[0] = position_temp[0];\n  position[1] = position_temp[1];\n\n  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) {\n    vertex_height = vec2(0.0, 0.0);\n  }\n\n  position[2] = sqrt_fp64(vertex_height);\n  position[3] = vec2(1.0, 0.0);\n}\n\nvoid main(void) {\n  vec2 projected_source_coord[2];\n  vec2 projected_target_coord[2];\n\n  project_position_fp64(instancePositions.xy, instancePositions64Low.xy, projected_source_coord);\n  project_position_fp64(instancePositions.zw, instancePositions64Low.zw, projected_target_coord);\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec2 curr_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, segmentRatio,\n    curr_pos_modelspace);\n\n  vec2 next_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, nextSegmentRatio,\n    next_pos_modelspace);\n\n  vec4 curr_pos_clipspace = project_common_position_to_clipspace_fp64(curr_pos_modelspace);\n  vec4 next_pos_clipspace = project_common_position_to_clipspace_fp64(next_pos_modelspace);\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n\n  vec2 offset = getExtrusionOffset(next_pos_clipspace.xy - curr_pos_clipspace.xy, positions.y, widthPixels);\n\n  gl_Position = curr_pos_clipspace + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vColor = vec4(color.rgb, color.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _arcLayerVertex = _interopRequireDefault(require("./arc-layer-vertex.glsl"));

var _arcLayerVertex2 = _interopRequireDefault(require("./arc-layer-vertex-64.glsl"));

var _arcLayerFragment = _interopRequireDefault(require("./arc-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fp64LowPart = _core2.fp64.fp64LowPart;
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  fp64: false,
  getSourcePosition: {
    type: 'accessor',
    value: function value(x) {
      return x.sourcePosition;
    }
  },
  getTargetPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.targetPosition;
    }
  },
  getSourceColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getTargetColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  getHeight: {
    type: 'accessor',
    value: 1
  },
  getTilt: {
    type: 'accessor',
    value: 0
  },
  widthUnits: 'pixels',
  widthScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  widthMinPixels: {
    type: 'number',
    value: 0,
    min: 0
  },
  widthMaxPixels: {
    type: 'number',
    value: Number.MAX_SAFE_INTEGER,
    min: 0
  },
  getStrokeWidth: {
    deprecatedFor: 'getWidth'
  }
};

var ArcLayer = function (_Layer) {
  (0, _inherits2.default)(ArcLayer, _Layer);

  function ArcLayer() {
    (0, _classCallCheck2.default)(this, ArcLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ArcLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(ArcLayer, [{
    key: "getShaders",
    value: function getShaders() {
      return this.use64bitProjection() ? {
        vs: _arcLayerVertex2.default,
        fs: _arcLayerFragment.default,
        modules: ['project64', 'picking']
      } : {
        vs: _arcLayerVertex.default,
        fs: _arcLayerFragment.default,
        modules: ['picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 4,
          transition: true,
          accessor: ['getSourcePosition', 'getTargetPosition'],
          update: this.calculateInstancePositions
        },
        instancePositions64Low: {
          size: 4,
          accessor: ['getSourcePosition', 'getTargetPosition'],
          update: this.calculateInstancePositions64Low
        },
        instanceSourceColors: {
          size: 4,
          type: 5121,
          transition: true,
          accessor: 'getSourceColor',
          defaultValue: DEFAULT_COLOR
        },
        instanceTargetColors: {
          size: 4,
          type: 5121,
          transition: true,
          accessor: 'getTargetColor',
          defaultValue: DEFAULT_COLOR
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: 'getWidth',
          defaultValue: 1
        },
        instanceHeights: {
          size: 1,
          transition: true,
          accessor: 'getHeight',
          defaultValue: 1
        },
        instanceTilts: {
          size: 1,
          transition: true,
          accessor: 'getTilt',
          defaultValue: 0
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;
      (0, _get2.default)((0, _getPrototypeOf2.default)(ArcLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this._getModel(gl)
        });
        this.getAttributeManager().invalidateAll();
      }
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var viewport = this.context.viewport;
      var _this$props = this.props,
          widthUnits = _this$props.widthUnits,
          widthScale = _this$props.widthScale,
          widthMinPixels = _this$props.widthMinPixels,
          widthMaxPixels = _this$props.widthMaxPixels;
      var widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;
      this.state.model.setUniforms(Object.assign({}, uniforms, {
        widthScale: widthScale * widthMultiplier,
        widthMinPixels: widthMinPixels,
        widthMaxPixels: widthMaxPixels
      })).draw();
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      var positions = [];
      var NUM_SEGMENTS = 50;

      for (var i = 0; i < NUM_SEGMENTS; i++) {
        positions = positions.concat([i, -1, 0, i, 1, 0]);
      }

      var model = new _core2.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _core2.Geometry({
          drawMode: 5,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
      model.setUniforms({
        numSegments: NUM_SEGMENTS
      });
      return model;
    }
  }, {
    key: "calculateInstancePositions",
    value: function calculateInstancePositions(attribute, _ref3) {
      var startRow = _ref3.startRow,
          endRow = _ref3.endRow;
      var _this$props2 = this.props,
          data = _this$props2.data,
          getSourcePosition = _this$props2.getSourcePosition,
          getTargetPosition = _this$props2.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var sourcePosition = getSourcePosition(object, objectInfo);
          value[i++] = sourcePosition[0];
          value[i++] = sourcePosition[1];
          var targetPosition = getTargetPosition(object, objectInfo);
          value[i++] = targetPosition[0];
          value[i++] = targetPosition[1];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "calculateInstancePositions64Low",
    value: function calculateInstancePositions64Low(attribute, _ref4) {
      var startRow = _ref4.startRow,
          endRow = _ref4.endRow;
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(4);
        return;
      }

      var _this$props3 = this.props,
          data = _this$props3.data,
          getSourcePosition = _this$props3.getSourcePosition,
          getTargetPosition = _this$props3.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable2 = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable2.iterable,
          objectInfo = _createIterable2.objectInfo;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;
          objectInfo.index++;
          var sourcePosition = getSourcePosition(object, objectInfo);
          value[i++] = fp64LowPart(sourcePosition[0]);
          value[i++] = fp64LowPart(sourcePosition[1]);
          var targetPosition = getTargetPosition(object, objectInfo);
          value[i++] = fp64LowPart(targetPosition[0]);
          value[i++] = fp64LowPart(targetPosition[1]);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }]);
  return ArcLayer;
}(_core.Layer);

exports.default = ArcLayer;
ArcLayer.layerName = 'ArcLayer';
ArcLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./arc-layer-vertex.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js","./arc-layer-vertex-64.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex-64.glsl.js","./arc-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js"}],"../../../node_modules/@loaders.gl/images/dist/esm/utils/globals.js":[function(require,module,exports) {
var process = require("process");
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.global = exports.isBrowser = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/typeof"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || true;
exports.isBrowser = isBrowser;
var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global
};
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
},{"@babel/runtime/helpers/esm/typeof":"../../../node_modules/@babel/runtime/helpers/esm/typeof.js","process":"../../../node_modules/process/browser.js"}],"../../../node_modules/@loaders.gl/images/dist/esm/lib/image-parsers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mimeTypeMap = void 0;
var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
var mimeTypeMap = new Map([['image/png', {
  test: isPng,
  getSize: getPngSize
}], ['image/jpeg', {
  test: isJpeg,
  getSize: getJpegSize
}], ['image/gif', {
  test: isGif,
  getSize: getGifSize
}], ['image/bmp', {
  test: isBmp,
  getSize: getBmpSize
}]]);
exports.mimeTypeMap = mimeTypeMap;

function isPng(dataView) {
  return dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
}

function getPngSize(dataView) {
  return {
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

function isGif(dataView) {
  return dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
}

function getGifSize(dataView) {
  return {
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

function isBmp(dataView) {
  return dataView.byteLength >= 2 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d;
}

function getBmpSize(dataView) {
  return {
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

function isJpeg(dataView) {
  return dataView.byteLength >= 2 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8;
}

function getJpegSize(dataView) {
  if (dataView.byteLength < 2 || dataView.getUint16(0, BIG_ENDIAN) !== 0xffd8) {
    return null;
  }

  var _getJpegMarkers = getJpegMarkers(),
      tableMarkers = _getJpegMarkers.tableMarkers,
      sofMarkers = _getJpegMarkers.sofMarkers;

  var i = 2;

  while (i < dataView.byteLength) {
    var marker = dataView.getUint16(i, BIG_ENDIAN);

    if (sofMarkers.has(marker)) {
      return {
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }

    if (!tableMarkers.has(marker)) {
      return null;
    }

    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  var tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);

  for (var i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  var sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);
  return {
    tableMarkers: tableMarkers,
    sofMarkers: sofMarkers
  };
}
},{}],"../../../node_modules/@loaders.gl/images/dist/esm/lib/get-image-metadata.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImage = isImage;
exports.getImageMIMEType = getImageMIMEType;
exports.getImageSize = getImageSize;
exports.getImageMetadata = getImageMetadata;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/slicedToArray"));

var _imageParsers = require("./image-parsers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERR_INVALID_MIME_TYPE = "Invalid MIME type. Supported MIME types are: ".concat(Array.from(_imageParsers.mimeTypeMap.keys()).join(', '));

function isImage(arrayBuffer, mimeType) {
  if (mimeType) {
    var _getImageTypeHandlers = getImageTypeHandlers(mimeType),
        test = _getImageTypeHandlers.test;

    var dataView = toDataView(arrayBuffer);
    return test(dataView);
  }

  return Boolean(getImageMIMEType(arrayBuffer));
}

function getImageMIMEType(arrayBuffer) {
  var dataView = toDataView(arrayBuffer);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _imageParsers.mimeTypeMap.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
          mimeType = _step$value[0],
          test = _step$value[1].test;

      if (test(dataView)) {
        return mimeType;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}

function getImageSize(arrayBuffer) {
  var mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  mimeType = mimeType || getImageMIMEType(arrayBuffer);

  var _getImageTypeHandlers2 = getImageTypeHandlers(mimeType),
      getSize = _getImageTypeHandlers2.getSize;

  var dataView = toDataView(arrayBuffer);
  var size = getSize(dataView);

  if (!size) {
    throw new Error("invalid image data for type: ".concat(mimeType));
  }

  return size;
}

function getImageMetadata(arrayBuffer) {
  var mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  mimeType = mimeType || getImageMIMEType(arrayBuffer);
  var metadata = getImageSize(arrayBuffer, mimeType);
  metadata.mimeType = mimeType;
  return metadata;
}

function getImageTypeHandlers(mimeType) {
  var handlers = _imageParsers.mimeTypeMap.get(mimeType);

  if (!handlers) {
    throw new Error(ERR_INVALID_MIME_TYPE);
  }

  return handlers;
}

function toDataView(data) {
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return new DataView(data.buffer || data);
  }

  throw new Error('toDataView');
}
},{"@babel/runtime/helpers/esm/slicedToArray":"../../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","./image-parsers":"../../../node_modules/@loaders.gl/images/dist/esm/lib/image-parsers.js"}],"../../../node_modules/@loaders.gl/images/dist/esm/lib/parse-image.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseImage = parseImage;
exports.loadImage = loadImage;
exports.parseToImageBitmap = parseToImageBitmap;
exports.loadToHTMLImage = loadToHTMLImage;
exports.canParseImage = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/asyncToGenerator"));

var _globals = require("../utils/globals");

var _getImageMetadata2 = require("./get-image-metadata");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canParseImage = _globals.global._parseImageNode || typeof ImageBitmap !== 'undefined';
exports.canParseImage = canParseImage;

function parseImage(arrayBuffer, options) {
  if (_globals.global._parseImageNode) {
    var _getImageMetadata = (0, _getImageMetadata2.getImageMetadata)(arrayBuffer),
        mimeType = _getImageMetadata.mimeType;

    return _globals.global._parseImageNode(arrayBuffer, mimeType, options);
  }

  return parseToImageBitmap(arrayBuffer);
}

function loadImage(_x, _x2) {
  return _loadImage.apply(this, arguments);
}

function _loadImage() {
  _loadImage = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(url, options) {
    var response, arrayBuffer;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof Image === 'undefined')) {
              _context.next = 8;
              break;
            }

            _context.next = 3;
            return fetch(url, options);

          case 3:
            response = _context.sent;
            _context.next = 6;
            return response.arrayBuffer();

          case 6:
            arrayBuffer = _context.sent;
            return _context.abrupt("return", parseImage(arrayBuffer));

          case 8:
            _context.next = 10;
            return loadToHTMLImage(url, options);

          case 10:
            return _context.abrupt("return", _context.sent);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadImage.apply(this, arguments);
}

function parseToImageBitmap(arrayBuffer) {
  if (typeof createImageBitmap === 'undefined') {
    throw new Error('parseImage');
  }

  var blob = new Blob([new Uint8Array(arrayBuffer)]);
  return createImageBitmap(blob);
}

function loadToHTMLImage(_x3, _x4) {
  return _loadToHTMLImage.apply(this, arguments);
}

function _loadToHTMLImage() {
  _loadToHTMLImage = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(url, options) {
    var src, response, xml;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!/\.svg((\?|#).*)?$/.test(url)) {
              _context2.next = 10;
              break;
            }

            _context2.next = 3;
            return fetch(url, options);

          case 3:
            response = _context2.sent;
            _context2.next = 6;
            return response.text();

          case 6:
            xml = _context2.sent;
            src = "data:image/svg+xml;base64,".concat(btoa(xml));
            _context2.next = 13;
            break;

          case 10:
            _context2.next = 12;
            return url;

          case 12:
            src = _context2.sent;

          case 13:
            _context2.next = 15;
            return new Promise(function (resolve, reject) {
              try {
                var image = new Image();

                image.onload = function () {
                  return resolve(image);
                };

                image.onerror = function (err) {
                  return reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
                };

                image.crossOrigin = options && options.crossOrigin || 'anonymous';
                image.src = src;
              } catch (error) {
                reject(error);
              }
            });

          case 15:
            return _context2.abrupt("return", _context2.sent);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadToHTMLImage.apply(this, arguments);
}
},{"@babel/runtime/regenerator":"../../../node_modules/@babel/runtime/regenerator/index.js","@babel/runtime/helpers/esm/asyncToGenerator":"../../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","../utils/globals":"../../../node_modules/@loaders.gl/images/dist/esm/utils/globals.js","./get-image-metadata":"../../../node_modules/@loaders.gl/images/dist/esm/lib/get-image-metadata.js"}],"../../../node_modules/@loaders.gl/images/dist/esm/image-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HTMLImageLoader = exports.ImageBitmapLoader = exports.default = void 0;

var _parseImage = require("./lib/parse-image");

var EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];
var _default = {
  name: 'Images',
  extensions: EXTENSIONS,
  parse: _parseImage.canParseImage && _parseImage.parseImage,
  loadAndParse: !_parseImage.canParseImage && _parseImage.loadImage
};
exports.default = _default;
var ImageBitmapLoader = {
  extensions: EXTENSIONS,
  parse: _parseImage.parseToImageBitmap
};
exports.ImageBitmapLoader = ImageBitmapLoader;
var HTMLImageLoader = {
  extensions: EXTENSIONS,
  loadAndParse: _parseImage.loadToHTMLImage
};
exports.HTMLImageLoader = HTMLImageLoader;
},{"./lib/parse-image":"../../../node_modules/@loaders.gl/images/dist/esm/lib/parse-image.js"}],"../../../node_modules/@loaders.gl/images/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || '@loaders.gl/images assertion failed.');
  }
}
},{}],"../../../node_modules/@loaders.gl/images/dist/esm/lib/encode-image.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeImage = encodeImage;

var _assert = _interopRequireDefault(require("../utils/assert"));

var _globals = require("../utils/globals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function encodeImage(image, type) {
  if (_globals.global._encodeImageNode) {
    return _globals.global._encodeImageNode(image, type);
  }

  if (image instanceof HTMLCanvasElement) {
    var _canvas = image;
    return _canvas.toDataURL(type);
  }

  (0, _assert.default)(image instanceof Image, 'getImageData accepts image or canvas');
  var canvas = document.createElement('canvas');
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext('2d').drawImage(image, 0, 0);
  var data = canvas.toDataURL(type || 'png').replace(/^data:image\/(png|jpg);base64,/, '');
  return Promise.resolve(data);
}
},{"../utils/assert":"../../../node_modules/@loaders.gl/images/dist/esm/utils/assert.js","../utils/globals":"../../../node_modules/@loaders.gl/images/dist/esm/utils/globals.js"}],"../../../node_modules/@loaders.gl/images/dist/esm/image-writer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _encodeImage = require("./lib/encode-image");

var _default = {
  name: 'Images',
  extensions: ['jpeg'],
  encode: _encodeImage.encodeImage,
  DEFAULT_OPTIONS: {
    type: 'png'
  }
};
exports.default = _default;
},{"./lib/encode-image":"../../../node_modules/@loaders.gl/images/dist/esm/lib/encode-image.js"}],"../../../node_modules/@loaders.gl/images/dist/esm/lib/image-utils-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeImage = decodeImage;
exports.getImagePixelData = getImagePixelData;

function decodeImage(arrayBufferOrView, _ref) {
  var _ref$mimeType = _ref.mimeType,
      mimeType = _ref$mimeType === void 0 ? 'image/jpeg' : _ref$mimeType;
  var blob = new Blob([arrayBufferOrView], {
    type: mimeType
  });
  var urlCreator = window.URL || window.webkitURL;
  var imageUrl = urlCreator.createObjectURL(blob);
  return new Promise(function (resolve, reject) {
    var image = new Image();

    image.onload = function () {
      return resolve(image);
    };

    image.onerror = reject;
    image.src = imageUrl;
    return image;
  });
}

function getImagePixelData(image) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  width = width || image.width;
  height = height || image.height;
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext('2d');
  ctx.drawImage(image, 0, 0, width, height);
  return ctx.getImageData(0, 0, width, height);
}
},{}],"../../../node_modules/@loaders.gl/images/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ImageLoader", {
  enumerable: true,
  get: function () {
    return _imageLoader.default;
  }
});
Object.defineProperty(exports, "HTMLImageLoader", {
  enumerable: true,
  get: function () {
    return _imageLoader.HTMLImageLoader;
  }
});
Object.defineProperty(exports, "ImageBitmapLoader", {
  enumerable: true,
  get: function () {
    return _imageLoader.ImageBitmapLoader;
  }
});
Object.defineProperty(exports, "ImageWriter", {
  enumerable: true,
  get: function () {
    return _imageWriter.default;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _parseImage.loadImage;
  }
});
Object.defineProperty(exports, "isImage", {
  enumerable: true,
  get: function () {
    return _getImageMetadata.isImage;
  }
});
Object.defineProperty(exports, "getImageMetadata", {
  enumerable: true,
  get: function () {
    return _getImageMetadata.getImageMetadata;
  }
});
Object.defineProperty(exports, "getImageMIMEType", {
  enumerable: true,
  get: function () {
    return _getImageMetadata.getImageMIMEType;
  }
});
Object.defineProperty(exports, "getImageSize", {
  enumerable: true,
  get: function () {
    return _getImageMetadata.getImageSize;
  }
});
Object.defineProperty(exports, "decodeImage", {
  enumerable: true,
  get: function () {
    return _imageUtilsBrowser.decodeImage;
  }
});

var _imageLoader = _interopRequireWildcard(require("./image-loader"));

var _imageWriter = _interopRequireDefault(require("./image-writer"));

var _parseImage = require("./lib/parse-image");

var _getImageMetadata = require("./lib/get-image-metadata");

var _imageUtilsBrowser = require("./lib/image-utils-browser");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }
},{"./image-loader":"../../../node_modules/@loaders.gl/images/dist/esm/image-loader.js","./image-writer":"../../../node_modules/@loaders.gl/images/dist/esm/image-writer.js","./lib/parse-image":"../../../node_modules/@loaders.gl/images/dist/esm/lib/parse-image.js","./lib/get-image-metadata":"../../../node_modules/@loaders.gl/images/dist/esm/lib/get-image-metadata.js","./lib/image-utils-browser":"../../../node_modules/@loaders.gl/images/dist/esm/lib/image-utils-browser.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec2 positions64xyLow;\nattribute vec3 instancePickingColors;\n\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n  gl_Position = project_position_to_clipspace(positions, positions64xyLow, vec3(0.0));\n \n  vTexCoord = texCoords;\n \n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor / 255.0;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  return mix(transparentColor / 255.0, vec4(color, 1.0), alpha);\n}\n\nvoid main(void) {\n  vec4 bitmapColor = texture2D(bitmapTexture, vTexCoord);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _images = require("@loaders.gl/images");

var _bitmapLayerVertex = _interopRequireDefault(require("./bitmap-layer-vertex"));

var _bitmapLayerFragment = _interopRequireDefault(require("./bitmap-layer-fragment"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _DEFAULT_TEXTURE_PARA;

var fp64LowPart = _core2.fp64.fp64LowPart;
var DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, (0, _defineProperty2.default)(_DEFAULT_TEXTURE_PARA, 10241, 9987), (0, _defineProperty2.default)(_DEFAULT_TEXTURE_PARA, 10240, 9729), (0, _defineProperty2.default)(_DEFAULT_TEXTURE_PARA, 10242, 33071), (0, _defineProperty2.default)(_DEFAULT_TEXTURE_PARA, 10243, 33071), _DEFAULT_TEXTURE_PARA);
var defaultProps = {
  image: null,
  bounds: {
    type: 'array',
    value: [1, 0, 0, 1],
    compare: true
  },
  fp64: false,
  desaturate: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0
  },
  transparentColor: {
    type: 'color',
    value: [0, 0, 0, 0]
  },
  tintColor: {
    type: 'color',
    value: [255, 255, 255]
  }
};

var BitmapLayer = function (_Layer) {
  (0, _inherits2.default)(BitmapLayer, _Layer);

  function BitmapLayer() {
    (0, _classCallCheck2.default)(this, BitmapLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(BitmapLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(BitmapLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: _bitmapLayerVertex.default,
        fs: _bitmapLayerFragment.default,
        modules: [projectModule, 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          update: this.calculatePositions,
          value: new Float32Array(12)
        },
        positions64xyLow: {
          size: 3,
          update: this.calculatePositions64xyLow,
          value: new Float32Array(12)
        }
      });
      this.setState({
        numInstances: 4
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this._getModel(gl)
        });
        this.getAttributeManager().invalidateAll();
      }

      if (props.image !== oldProps.image) {
        this.loadTexture(props.image);
      }

      var attributeManager = this.getAttributeManager();

      if (props.bounds !== oldProps.bounds) {
        this.setState({
          positions: this._getPositionsFromBounds(props.bounds)
        });
        attributeManager.invalidate('positions');
        attributeManager.invalidate('positions64xyLow');
      }
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(BitmapLayer.prototype), "finalizeState", this).call(this);

      if (this.state.bitmapTexture) {
        this.state.bitmapTexture.delete();
      }
    }
  }, {
    key: "_getPositionsFromBounds",
    value: function _getPositionsFromBounds(bounds) {
      var positions = new Array(12);

      if (Number.isFinite(bounds[0])) {
        positions[0] = bounds[0];
        positions[1] = bounds[1];
        positions[2] = 0;
        positions[3] = bounds[0];
        positions[4] = bounds[3];
        positions[5] = 0;
        positions[6] = bounds[2];
        positions[7] = bounds[3];
        positions[8] = 0;
        positions[9] = bounds[2];
        positions[10] = bounds[1];
        positions[11] = 0;
      } else {
        for (var i = 0; i < bounds.length; i++) {
          positions[i * 3 + 0] = bounds[i][0];
          positions[i * 3 + 1] = bounds[i][1];
          positions[i * 3 + 2] = bounds[i][2] || 0;
        }
      }

      return positions;
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      if (!gl) {
        return null;
      }

      return new _core2.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        shaderCache: this.context.shaderCache,
        geometry: new _core2.Geometry({
          drawMode: 6,
          vertexCount: 4,
          attributes: {
            texCoords: new Float32Array([0, 0, 0, 1, 1, 1, 1, 0])
          }
        }),
        isInstanced: false
      }));
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _this$state = this.state,
          bitmapTexture = _this$state.bitmapTexture,
          model = _this$state.model;
      var _this$props = this.props,
          desaturate = _this$props.desaturate,
          transparentColor = _this$props.transparentColor,
          tintColor = _this$props.tintColor;

      if (bitmapTexture && model) {
        model.setUniforms(Object.assign({}, uniforms, {
          bitmapTexture: bitmapTexture,
          desaturate: desaturate,
          transparentColor: transparentColor,
          tintColor: tintColor
        })).draw();
      }
    }
  }, {
    key: "loadTexture",
    value: function loadTexture(image) {
      var _this = this;

      if (typeof image === 'string') {
        image = (0, _images.loadImage)(image);
      }

      if (image instanceof Promise) {
        image.then(function (data) {
          return _this.loadTexture(data);
        });
        return;
      }

      var gl = this.context.gl;

      if (this.state.bitmapTexture) {
        this.state.bitmapTexture.delete();
      }

      if (image instanceof _core2.Texture2D) {
        this.setState({
          bitmapTexture: image
        });
      } else if (image instanceof Image || image instanceof HTMLCanvasElement) {
        this.setState({
          bitmapTexture: new _core2.Texture2D(gl, {
            data: image,
            parameters: DEFAULT_TEXTURE_PARAMETERS
          })
        });
      }
    }
  }, {
    key: "calculatePositions",
    value: function calculatePositions(_ref3) {
      var value = _ref3.value;
      var positions = this.state.positions;
      value.set(positions);
    }
  }, {
    key: "calculatePositions64xyLow",
    value: function calculatePositions64xyLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(4);
        return;
      }

      var value = attribute.value;
      value.set(this.state.positions.map(fp64LowPart));
    }
  }]);
  return BitmapLayer;
}(_core.Layer);

exports.default = BitmapLayer;
BitmapLayer.layerName = 'BitmapLayer';
BitmapLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","@loaders.gl/images":"../../../node_modules/@loaders.gl/images/dist/esm/index.js","./bitmap-layer-vertex":"../../../node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js","./bitmap-layer-fragment":"../../../node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n\n  if (billboard)  {\n    pixelOffset.y *= -1.0;\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.0)); \n    gl_Position.xy += project_pixel_size_to_clipspace(pixelOffset);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset_common); \n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\n\n  vColor = instanceColors / 255.;\n\n  vColorMode = instanceColorModes;\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nconst float MIN_ALPHA = 0.05;\n\nvoid main(void) {\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < MIN_ALPHA) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildMapping = buildMapping;
exports.getDiffIcons = getDiffIcons;
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _core = require("@luma.gl/core");

var _images = require("@loaders.gl/images");

var _core2 = require("@deck.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _DEFAULT_TEXTURE_PARA;

var DEFAULT_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER = 4;

var noop = function noop() {};

var DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, (0, _defineProperty2.default)(_DEFAULT_TEXTURE_PARA, 10241, 9987), (0, _defineProperty2.default)(_DEFAULT_TEXTURE_PARA, 10240, 9729), _DEFAULT_TEXTURE_PARA);

function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}

function resizeImage(ctx, imageData, width, height) {
  var naturalWidth = imageData.naturalWidth,
      naturalHeight = imageData.naturalHeight;

  if (width === naturalWidth && height === naturalHeight) {
    return imageData;
  }

  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.drawImage(imageData, 0, 0, naturalWidth, naturalHeight, 0, 0, width, height);
  return ctx.canvas;
}

function getIconId(icon) {
  return icon && (icon.id || icon.url);
}

function buildRowMapping(mapping, columns, yOffset) {
  for (var i = 0; i < columns.length; i++) {
    var _columns$i = columns[i],
        icon = _columns$i.icon,
        xOffset = _columns$i.xOffset;
    var id = getIconId(icon);
    mapping[id] = Object.assign({}, icon, {
      x: xOffset,
      y: yOffset
    });
  }
}

function resizeTexture(texture, width, height) {
  var oldWidth = texture.width;
  var oldHeight = texture.height;
  var oldPixels = (0, _core.readPixelsToBuffer)(texture, {});
  texture.resize({
    width: width,
    height: height
  });
  texture.setSubImageData({
    data: oldPixels,
    x: 0,
    y: height - oldHeight,
    width: oldWidth,
    height: oldHeight,
    parameters: DEFAULT_TEXTURE_PARAMETERS
  });
  texture.generateMipmap();
  oldPixels.delete();
  return texture;
}

function buildMapping(_ref) {
  var icons = _ref.icons,
      buffer = _ref.buffer,
      _ref$mapping = _ref.mapping,
      mapping = _ref$mapping === void 0 ? {} : _ref$mapping,
      _ref$xOffset = _ref.xOffset,
      xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset,
      _ref$yOffset = _ref.yOffset,
      yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset,
      canvasWidth = _ref.canvasWidth;
  var rowHeight = 0;
  var columns = [];

  for (var i = 0; i < icons.length; i++) {
    var icon = icons[i];
    var id = getIconId(icon);

    if (!mapping[id]) {
      var height = icon.height,
          width = icon.width;

      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }

      columns.push({
        icon: icon,
        xOffset: xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }

  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }

  return {
    mapping: mapping,
    xOffset: xOffset,
    yOffset: yOffset,
    canvasWidth: canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}

function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }

  cachedIcons = cachedIcons || {};
  var icons = {};

  var _createIterable = (0, _core2.createIterable)(data),
      iterable = _createIterable.iterable,
      objectInfo = _createIterable.objectInfo;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var object = _step.value;
      objectInfo.index++;
      var icon = getIcon(object, objectInfo);
      var id = getIconId(icon);

      if (!icon) {
        throw new Error('Icon is missing.');
      }

      if (!icon.url) {
        throw new Error('Icon url is missing.');
      }

      if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
        icons[id] = icon;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return icons;
}

var IconManager = function () {
  function IconManager(gl, _ref2) {
    var _ref2$onUpdate = _ref2.onUpdate,
        onUpdate = _ref2$onUpdate === void 0 ? noop : _ref2$onUpdate;
    (0, _classCallCheck2.default)(this, IconManager);
    this.gl = gl;
    this.onUpdate = onUpdate;
    this._getIcon = null;
    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};
    this._autoPacking = false;
    this._xOffset = 0;
    this._yOffset = 0;
    this._buffer = DEFAULT_BUFFER;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
  }

  (0, _createClass2.default)(IconManager, [{
    key: "finalize",
    value: function finalize() {
      if (this._texture) {
        this._texture.delete();
      }
    }
  }, {
    key: "getTexture",
    value: function getTexture() {
      return this._texture || this._externalTexture;
    }
  }, {
    key: "getIconMapping",
    value: function getIconMapping(object, objectInfo) {
      var icon = this._getIcon(object, objectInfo);

      var id = this._autoPacking ? getIconId(icon) : icon;
      return this._mapping[id] || {};
    }
  }, {
    key: "setProps",
    value: function setProps(_ref3) {
      var autoPacking = _ref3.autoPacking,
          iconAtlas = _ref3.iconAtlas,
          iconMapping = _ref3.iconMapping,
          data = _ref3.data,
          getIcon = _ref3.getIcon;

      if (autoPacking !== undefined) {
        this._autoPacking = autoPacking;
      }

      if (getIcon) {
        this._getIcon = getIcon;
      }

      if (iconMapping) {
        this._mapping = iconMapping;
      }

      if (iconAtlas) {
        this._updateIconAtlas(iconAtlas);
      }

      if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {
        this._canvas = this._canvas || document.createElement('canvas');

        this._updateAutoPacking(data);
      }
    }
  }, {
    key: "_updateIconAtlas",
    value: function _updateIconAtlas(iconAtlas) {
      var _this = this;

      if (this._texture) {
        this._texture.delete();

        this._texture = null;
      }

      if (iconAtlas instanceof _core.Texture2D) {
        iconAtlas.setParameters(DEFAULT_TEXTURE_PARAMETERS);
        this._externalTexture = iconAtlas;
        this.onUpdate();
      } else if (typeof iconAtlas === 'string') {
        (0, _images.loadImage)(iconAtlas).then(function (data) {
          _this._texture = new _core.Texture2D(_this.gl, {
            data: data,
            parameters: DEFAULT_TEXTURE_PARAMETERS
          });

          _this.onUpdate();
        });
      }
    }
  }, {
    key: "_updateAutoPacking",
    value: function _updateAutoPacking(data) {
      var icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});

      if (icons.length > 0) {
        var _buildMapping = buildMapping({
          icons: icons,
          buffer: this._buffer,
          canvasWidth: this._canvasWidth,
          mapping: this._mapping,
          xOffset: this._xOffset,
          yOffset: this._yOffset
        }),
            mapping = _buildMapping.mapping,
            xOffset = _buildMapping.xOffset,
            yOffset = _buildMapping.yOffset,
            canvasHeight = _buildMapping.canvasHeight;

        this._mapping = mapping;
        this._xOffset = xOffset;
        this._yOffset = yOffset;
        this._canvasHeight = canvasHeight;

        if (!this._texture) {
          this._texture = new _core.Texture2D(this.gl, {
            width: this._canvasWidth,
            height: this._canvasHeight,
            parameters: DEFAULT_TEXTURE_PARAMETERS
          });
        }

        if (this._texture.height !== this._canvasHeight) {
          resizeTexture(this._texture, this._canvasWidth, this._canvasHeight);
        }

        this.onUpdate();

        this._loadIcons(icons);
      }
    }
  }, {
    key: "_loadIcons",
    value: function _loadIcons(icons) {
      var _this2 = this;

      var ctx = this._canvas.getContext('2d');

      var canvasHeight = this._texture.height;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        var _loop = function _loop() {
          var icon = _step2.value;
          (0, _images.loadImage)(icon.url).then(function (imageData) {
            var id = getIconId(icon);
            var _this2$_mapping$id = _this2._mapping[id],
                x = _this2$_mapping$id.x,
                y = _this2$_mapping$id.y,
                width = _this2$_mapping$id.width,
                height = _this2$_mapping$id.height;
            var data = resizeImage(ctx, imageData, width, height);

            _this2._texture.setSubImageData({
              data: data,
              x: x,
              y: canvasHeight - y - height,
              width: width,
              height: height,
              parameters: Object.assign({}, DEFAULT_TEXTURE_PARAMETERS, (0, _defineProperty2.default)({}, 37440, true))
            });

            _this2._texture.generateMipmap();

            _this2.onUpdate();
          });
        };

        for (var _iterator2 = icons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }]);
  return IconManager;
}();

exports.default = IconManager;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","@loaders.gl/images":"../../../node_modules/@loaders.gl/images/dist/esm/index.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _iconLayerVertex = _interopRequireDefault(require("./icon-layer-vertex.glsl"));

var _iconLayerFragment = _interopRequireDefault(require("./icon-layer-fragment.glsl"));

var _iconManager = _interopRequireDefault(require("./icon-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fp64LowPart = _core2.fp64.fp64LowPart;
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  iconAtlas: null,
  iconMapping: {
    type: 'object',
    value: {},
    async: true
  },
  sizeScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  fp64: false,
  billboard: true,
  sizeUnits: 'pixels',
  sizeMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getIcon: {
    type: 'accessor',
    value: function value(x) {
      return x.icon;
    }
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getSize: {
    type: 'accessor',
    value: 1
  },
  getAngle: {
    type: 'accessor',
    value: 0
  }
};

var IconLayer = function (_Layer) {
  (0, _inherits2.default)(IconLayer, _Layer);

  function IconLayer() {
    (0, _classCallCheck2.default)(this, IconLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(IconLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(IconLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: _iconLayerVertex.default,
        fs: _iconLayerFragment.default,
        modules: [projectModule, 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var _this = this;

      this.state = {
        iconManager: new _iconManager.default(this.context.gl, {
          onUpdate: function onUpdate() {
            return _this._onUpdate();
          }
        })
      };
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          transition: true,
          accessor: 'getPosition'
        },
        instancePositions64xyLow: {
          size: 2,
          accessor: 'getPosition',
          update: this.calculateInstancePositions64xyLow
        },
        instanceSizes: {
          size: 1,
          transition: true,
          accessor: 'getSize',
          defaultValue: 1
        },
        instanceOffsets: {
          size: 2,
          accessor: 'getIcon',
          update: this.calculateInstanceOffsets
        },
        instanceIconFrames: {
          size: 4,
          accessor: 'getIcon',
          update: this.calculateInstanceIconFrames
        },
        instanceColorModes: {
          size: 1,
          type: 5121,
          accessor: 'getIcon',
          update: this.calculateInstanceColorMode
        },
        instanceColors: {
          size: 4,
          type: 5121,
          transition: true,
          accessor: 'getColor',
          defaultValue: DEFAULT_COLOR
        },
        instanceAngles: {
          size: 1,
          transition: true,
          accessor: 'getAngle',
          defaultValue: 0
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;
      (0, _get2.default)((0, _getPrototypeOf2.default)(IconLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });
      var attributeManager = this.getAttributeManager();
      var iconManager = this.state.iconManager;
      var iconAtlas = props.iconAtlas,
          iconMapping = props.iconMapping,
          data = props.data,
          getIcon = props.getIcon;
      var iconMappingChanged = false;

      if (iconAtlas) {
        if (oldProps.iconAtlas !== props.iconAtlas) {
          iconManager.setProps({
            iconAtlas: iconAtlas,
            autoPacking: false
          });
        }

        if (oldProps.iconMapping !== props.iconMapping) {
          iconManager.setProps({
            iconMapping: iconMapping
          });
          iconMappingChanged = true;
        }
      } else {
        iconManager.setProps({
          autoPacking: true
        });
      }

      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
        iconManager.setProps({
          data: data,
          getIcon: getIcon
        });
        iconMappingChanged = true;
      }

      if (iconMappingChanged) {
        attributeManager.invalidate('instanceOffsets');
        attributeManager.invalidate('instanceIconFrames');
        attributeManager.invalidate('instanceColorModes');
      }

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this._getModel(gl)
        });
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(IconLayer.prototype), "finalizeState", this).call(this);
      this.state.iconManager.finalize();
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _this$props = this.props,
          sizeScale = _this$props.sizeScale,
          sizeMinPixels = _this$props.sizeMinPixels,
          sizeMaxPixels = _this$props.sizeMaxPixels,
          sizeUnits = _this$props.sizeUnits,
          billboard = _this$props.billboard;
      var iconManager = this.state.iconManager;
      var viewport = this.context.viewport;
      var iconsTexture = iconManager.getTexture();

      if (iconsTexture) {
        this.state.model.setUniforms(Object.assign({}, uniforms, {
          iconsTexture: iconsTexture,
          iconsTextureDim: [iconsTexture.width, iconsTexture.height],
          sizeScale: sizeScale * (sizeUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1),
          sizeMinPixels: sizeMinPixels,
          sizeMaxPixels: sizeMaxPixels,
          billboard: billboard
        })).draw();
      }
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      var positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];
      return new _core2.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _core2.Geometry({
          drawMode: 6,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: "_onUpdate",
    value: function _onUpdate() {
      this.setNeedsRedraw();
    }
  }, {
    key: "calculateInstancePositions64xyLow",
    value: function calculateInstancePositions64xyLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      var _this$props2 = this.props,
          data = _this$props2.data,
          getPosition = _this$props2.getPosition;
      var value = attribute.value;
      var i = 0;

      var _createIterable = (0, _core.createIterable)(data),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var position = getPosition(object, objectInfo);
          value[i++] = fp64LowPart(position[0]);
          value[i++] = fp64LowPart(position[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "calculateInstanceOffsets",
    value: function calculateInstanceOffsets(attribute, _ref3) {
      var startRow = _ref3.startRow,
          endRow = _ref3.endRow;
      var data = this.props.data;
      var iconManager = this.state.iconManager;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable2 = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable2.iterable,
          objectInfo = _createIterable2.objectInfo;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;
          objectInfo.index++;
          var rect = iconManager.getIconMapping(object, objectInfo);
          value[i++] = rect.width / 2 - rect.anchorX || 0;
          value[i++] = rect.height / 2 - rect.anchorY || 0;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "calculateInstanceColorMode",
    value: function calculateInstanceColorMode(attribute, _ref4) {
      var startRow = _ref4.startRow,
          endRow = _ref4.endRow;
      var data = this.props.data;
      var iconManager = this.state.iconManager;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable3 = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable3.iterable,
          objectInfo = _createIterable3.objectInfo;

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = iterable[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var object = _step3.value;
          objectInfo.index++;
          var mapping = iconManager.getIconMapping(object, objectInfo);
          var colorMode = mapping.mask;
          value[i++] = colorMode ? 1 : 0;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "calculateInstanceIconFrames",
    value: function calculateInstanceIconFrames(attribute, _ref5) {
      var startRow = _ref5.startRow,
          endRow = _ref5.endRow;
      var data = this.props.data;
      var iconManager = this.state.iconManager;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable4 = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable4.iterable,
          objectInfo = _createIterable4.objectInfo;

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = iterable[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var object = _step4.value;
          objectInfo.index++;
          var rect = iconManager.getIconMapping(object, objectInfo);
          value[i++] = rect.x || 0;
          value[i++] = rect.y || 0;
          value[i++] = rect.width || 0;
          value[i++] = rect.height || 0;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }]);
  return IconLayer;
}(_core.Layer);

exports.default = IconLayer;
IconLayer.layerName = 'IconLayer';
IconLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./icon-layer-vertex.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js","./icon-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js","./icon-manager":"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec4 instanceSourceTargetPositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nvoid main(void) {\n  vec4 source = project_position_to_clipspace(instanceSourcePositions, instanceSourceTargetPositions64xyLow.xy, vec3(0.));\n  vec4 target = project_position_to_clipspace(instanceTargetPositions, instanceSourceTargetPositions64xyLow.zw, vec3(0.));\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  vec2 offset = getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels);\n  gl_Position = p + vec4(offset, 0.0, 0.0);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _lineLayerVertex = _interopRequireDefault(require("./line-layer-vertex.glsl"));

var _lineLayerFragment = _interopRequireDefault(require("./line-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fp64LowPart = _core2.fp64.fp64LowPart;
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  fp64: false,
  getSourcePosition: {
    type: 'accessor',
    value: function value(x) {
      return x.sourcePosition;
    }
  },
  getTargetPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.targetPosition;
    }
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  widthUnits: 'pixels',
  widthScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  widthMinPixels: {
    type: 'number',
    value: 0,
    min: 0
  },
  widthMaxPixels: {
    type: 'number',
    value: Number.MAX_SAFE_INTEGER,
    min: 0
  },
  getStrokeWidth: {
    deprecatedFor: 'getWidth'
  }
};

var LineLayer = function (_Layer) {
  (0, _inherits2.default)(LineLayer, _Layer);

  function LineLayer() {
    (0, _classCallCheck2.default)(this, LineLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LineLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(LineLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: _lineLayerVertex.default,
        fs: _lineLayerFragment.default,
        modules: [projectModule, 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          transition: true,
          accessor: 'getSourcePosition'
        },
        instanceTargetPositions: {
          size: 3,
          transition: true,
          accessor: 'getTargetPosition'
        },
        instanceSourceTargetPositions64xyLow: {
          size: 4,
          accessor: ['getSourcePosition', 'getTargetPosition'],
          update: this.calculateInstanceSourceTargetPositions64xyLow
        },
        instanceColors: {
          size: 4,
          type: 5121,
          transition: true,
          accessor: 'getColor',
          defaultValue: [0, 0, 0, 255]
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: 'getWidth',
          defaultValue: 1
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;
      (0, _get2.default)((0, _getPrototypeOf2.default)(LineLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this._getModel(gl)
        });
        this.getAttributeManager().invalidateAll();
      }
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var viewport = this.context.viewport;
      var _this$props = this.props,
          widthUnits = _this$props.widthUnits,
          widthScale = _this$props.widthScale,
          widthMinPixels = _this$props.widthMinPixels,
          widthMaxPixels = _this$props.widthMaxPixels;
      var widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;
      this.state.model.setUniforms(Object.assign({}, uniforms, {
        widthScale: widthScale * widthMultiplier,
        widthMinPixels: widthMinPixels,
        widthMaxPixels: widthMaxPixels
      })).draw();
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      var positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
      return new _core2.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _core2.Geometry({
          drawMode: 5,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: "calculateInstanceSourceTargetPositions64xyLow",
    value: function calculateInstanceSourceTargetPositions64xyLow(attribute, _ref3) {
      var startRow = _ref3.startRow,
          endRow = _ref3.endRow;
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(4);
        return;
      }

      var _this$props2 = this.props,
          data = _this$props2.data,
          getSourcePosition = _this$props2.getSourcePosition,
          getTargetPosition = _this$props2.getTargetPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var sourcePosition = getSourcePosition(object, objectInfo);
          var targetPosition = getTargetPosition(object, objectInfo);
          value[i++] = fp64LowPart(sourcePosition[0]);
          value[i++] = fp64LowPart(sourcePosition[1]);
          value[i++] = fp64LowPart(targetPosition[0]);
          value[i++] = fp64LowPart(targetPosition[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return LineLayer;
}(_core.Layer);

exports.default = LineLayer;
LineLayer.layerName = 'LineLayer';
LineLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./line-layer-vertex.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js","./line-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  unitPosition = positions.xy;\n  vec4 position_commonspace;\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.), position_commonspace);\n  gl_Position.xy += project_pixel_size_to_clipspace(positions.xy * radiusPixels);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, position_commonspace.xyz, project_normal(instanceNormals));\n  vColor = vec4(lightColor, instanceColors.a * opacity) / 255.0;\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _pointCloudLayerVertex = _interopRequireDefault(require("./point-cloud-layer-vertex.glsl"));

var _pointCloudLayerFragment = _interopRequireDefault(require("./point-cloud-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fp64LowPart = _core2.fp64.fp64LowPart;
var DEFAULT_COLOR = [0, 0, 0, 255];
var DEFAULT_NORMAL = [0, 0, 1];
var defaultMaterial = new _core2.PhongMaterial();
var defaultProps = {
  sizeUnits: 'pixels',
  pointSize: {
    type: 'number',
    min: 0,
    value: 10
  },
  fp64: false,
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getNormal: {
    type: 'accessor',
    value: DEFAULT_NORMAL
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  material: defaultMaterial,
  radiusPixels: {
    deprecatedFor: 'pointSize'
  }
};

var PointCloudLayer = function (_Layer) {
  (0, _inherits2.default)(PointCloudLayer, _Layer);

  function PointCloudLayer() {
    (0, _classCallCheck2.default)(this, PointCloudLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PointCloudLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(PointCloudLayer, [{
    key: "getShaders",
    value: function getShaders(id) {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: _pointCloudLayerVertex.default,
        fs: _pointCloudLayerFragment.default,
        modules: [projectModule, 'gouraud-lighting', 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          transition: true,
          accessor: 'getPosition'
        },
        instancePositions64xyLow: {
          size: 2,
          accessor: 'getPosition',
          update: this.calculateInstancePositions64xyLow
        },
        instanceNormals: {
          size: 3,
          transition: true,
          accessor: 'getNormal',
          defaultValue: DEFAULT_NORMAL
        },
        instanceColors: {
          size: 4,
          type: 5121,
          transition: true,
          accessor: 'getColor',
          defaultValue: DEFAULT_COLOR
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;
      (0, _get2.default)((0, _getPrototypeOf2.default)(PointCloudLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this._getModel(gl)
        });
        this.getAttributeManager().invalidateAll();
      }
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var viewport = this.context.viewport;
      var _this$props = this.props,
          pointSize = _this$props.pointSize,
          sizeUnits = _this$props.sizeUnits;
      var sizeMultiplier = sizeUnits === 'meters' ? viewport.distanceScales.pixelsPerMeter[2] : 1;
      this.state.model.setUniforms(Object.assign({}, uniforms, {
        radiusPixels: pointSize * sizeMultiplier
      })).draw();
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      var positions = [];

      for (var i = 0; i < 3; i++) {
        var angle = i / 3 * Math.PI * 2;
        positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
      }

      return new _core2.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _core2.Geometry({
          drawMode: 4,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: "calculateInstancePositions64xyLow",
    value: function calculateInstancePositions64xyLow(attribute, _ref3) {
      var startRow = _ref3.startRow,
          endRow = _ref3.endRow;
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      var _this$props2 = this.props,
          data = _this$props2.data,
          getPosition = _this$props2.getPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var position = getPosition(object, objectInfo);
          value[i++] = fp64LowPart(position[0]);
          value[i++] = fp64LowPart(position[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return PointCloudLayer;
}(_core.Layer);

exports.default = PointCloudLayer;
PointCloudLayer.layerName = 'PointCloudLayer';
PointCloudLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./point-cloud-layer-vertex.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js","./point-cloud-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n  float outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  unitPosition = positions.xy;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity) / 255.;\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  } \n  if (distToCenter > innerUnitRadius) {\n    gl_FragColor = vLineColor;\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _scatterplotLayerVertex = _interopRequireDefault(require("./scatterplot-layer-vertex.glsl"));

var _scatterplotLayerFragment = _interopRequireDefault(require("./scatterplot-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fp64LowPart = _core2.fp64.fp64LowPart;
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  radiusScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  radiusMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  radiusMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  lineWidthUnits: 'meters',
  lineWidthScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  lineWidthMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  lineWidthMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  stroked: false,
  fp64: false,
  filled: true,
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getRadius: {
    type: 'accessor',
    value: 1
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  strokeWidth: {
    deprecatedFor: 'getLineWidth'
  },
  outline: {
    deprecatedFor: 'stroked'
  },
  getColor: {
    deprecatedFor: ['getFillColor', 'getLineColor']
  }
};

var ScatterplotLayer = function (_Layer) {
  (0, _inherits2.default)(ScatterplotLayer, _Layer);

  function ScatterplotLayer() {
    (0, _classCallCheck2.default)(this, ScatterplotLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ScatterplotLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(ScatterplotLayer, [{
    key: "getShaders",
    value: function getShaders(id) {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: _scatterplotLayerVertex.default,
        fs: _scatterplotLayerFragment.default,
        modules: [projectModule, 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          transition: true,
          accessor: 'getPosition'
        },
        instancePositions64xyLow: {
          size: 2,
          accessor: 'getPosition',
          update: this.calculateInstancePositions64xyLow
        },
        instanceRadius: {
          size: 1,
          transition: true,
          accessor: 'getRadius',
          defaultValue: 1
        },
        instanceFillColors: {
          size: 4,
          transition: true,
          type: 5121,
          accessor: 'getFillColor',
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineColors: {
          size: 4,
          transition: true,
          type: 5121,
          accessor: 'getLineColor',
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineWidths: {
          size: 1,
          transition: true,
          accessor: 'getLineWidth',
          defaultValue: 1
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;
      (0, _get2.default)((0, _getPrototypeOf2.default)(ScatterplotLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this._getModel(gl)
        });
        this.getAttributeManager().invalidateAll();
      }
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var viewport = this.context.viewport;
      var _this$props = this.props,
          radiusScale = _this$props.radiusScale,
          radiusMinPixels = _this$props.radiusMinPixels,
          radiusMaxPixels = _this$props.radiusMaxPixels,
          stroked = _this$props.stroked,
          filled = _this$props.filled,
          lineWidthUnits = _this$props.lineWidthUnits,
          lineWidthScale = _this$props.lineWidthScale,
          lineWidthMinPixels = _this$props.lineWidthMinPixels,
          lineWidthMaxPixels = _this$props.lineWidthMaxPixels;
      var widthMultiplier = lineWidthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;
      this.state.model.setUniforms(Object.assign({}, uniforms, {
        stroked: stroked ? 1 : 0,
        filled: filled,
        radiusScale: radiusScale,
        radiusMinPixels: radiusMinPixels,
        radiusMaxPixels: radiusMaxPixels,
        lineWidthScale: lineWidthScale * widthMultiplier,
        lineWidthMinPixels: lineWidthMinPixels,
        lineWidthMaxPixels: lineWidthMaxPixels
      })).draw();
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      var positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];
      return new _core2.Model(gl, Object.assign(this.getShaders(), {
        id: this.props.id,
        geometry: new _core2.Geometry({
          drawMode: 6,
          vertexCount: 4,
          attributes: {
            positions: {
              size: 3,
              value: new Float32Array(positions)
            }
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: "calculateInstancePositions64xyLow",
    value: function calculateInstancePositions64xyLow(attribute, _ref3) {
      var startRow = _ref3.startRow,
          endRow = _ref3.endRow;
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      var _this$props2 = this.props,
          data = _this$props2.data,
          getPosition = _this$props2.getPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var position = getPosition(object, objectInfo);
          value[i++] = fp64LowPart(position[0]);
          value[i++] = fp64LowPart(position[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ScatterplotLayer;
}(_core.Layer);

exports.default = ScatterplotLayer;
ScatterplotLayer.layerName = 'ScatterplotLayer';
ScatterplotLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./scatterplot-layer-vertex.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js","./scatterplot-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/objectSpread"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ColumnGeometry = function (_Geometry) {
  (0, _inherits2.default)(ColumnGeometry, _Geometry);

  function ColumnGeometry() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, ColumnGeometry);
    var _props$id = props.id,
        id = _props$id === void 0 ? (0, _core2.uid)('column-geometry') : _props$id;

    var _tesselateColumn = tesselateColumn(props),
        indices = _tesselateColumn.indices,
        attributes = _tesselateColumn.attributes;

    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ColumnGeometry).call(this, (0, _objectSpread2.default)({}, props, {
      id: id,
      indices: indices,
      attributes: attributes
    })));
  }

  return ColumnGeometry;
}(_core2.Geometry);

exports.default = ColumnGeometry;

function tesselateColumn(props) {
  var radius = props.radius,
      _props$height = props.height,
      height = _props$height === void 0 ? 1 : _props$height,
      _props$nradial = props.nradial,
      nradial = _props$nradial === void 0 ? 10 : _props$nradial,
      vertices = props.vertices;

  _core.log.assert(!vertices || vertices.length >= nradial);

  var vertsAroundEdge = nradial + 1;
  var numVertices = vertsAroundEdge * 3;
  var stepAngle = Math.PI * 2 / nradial;
  var indices = new Uint16Array(nradial * 3 * 2);
  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var i = 0;

  for (var j = 0; j < vertsAroundEdge; j++) {
    var a = j * stepAngle;
    var vertex = vertices && vertices[j % nradial];
    var nextVertex = vertices && vertices[(j + 1) % nradial];
    var sin = Math.sin(a);
    var cos = Math.cos(a);

    for (var k = 0; k < 2; k++) {
      positions[i + 0] = vertex ? vertex[0] : cos * radius;
      positions[i + 1] = vertex ? vertex[1] : sin * radius;
      positions[i + 2] = (1 / 2 - k) * height;
      normals[i + 0] = vertex ? nextVertex[0] - vertex[0] : cos;
      normals[i + 1] = vertex ? nextVertex[1] - vertex[1] : sin;
      i += 3;
    }
  }

  for (var _j = 0; _j < vertsAroundEdge; _j++) {
    var v = Math.floor(_j / 2) * Math.sign(_j % 2 - 0.5);

    var _a = v * stepAngle;

    var _vertex = vertices && vertices[(v + nradial) % nradial];

    var _sin = Math.sin(_a);

    var _cos = Math.cos(_a);

    positions[i + 0] = _vertex ? _vertex[0] : _cos * radius;
    positions[i + 1] = _vertex ? _vertex[1] : _sin * radius;
    positions[i + 2] = height / 2;
    normals[i + 2] = 1;
    i += 3;
  }

  var index = 0;

  for (var _j2 = 0; _j2 < nradial; _j2++) {
    indices[index++] = _j2 * 2 + 0;
    indices[index++] = _j2 * 2 + 2;
    indices[index++] = _j2 * 2 + 0;
    indices[index++] = _j2 * 2 + 1;
    indices[index++] = _j2 * 2 + 1;
    indices[index++] = _j2 * 2 + 3;
  }

  return {
    indices: indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      }
    }
  };
}
},{"@babel/runtime/helpers/esm/objectSpread":"../../../node_modules/@babel/runtime/helpers/esm/objectSpread.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME column-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute float instanceElevations;\nattribute vec2 instancePositions64xyLow;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute float instanceStrokeWidths;\n\nattribute vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nvarying vec4 vColor;\n\nvoid main(void) {\n  \n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation = 0.0;\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (isStroke) {\n    float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    strokeOffsetRatio += sign(positions.z) * project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n  }\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec2 centroidPosition64xyLow = instancePositions64xyLow;\n  vec3 pos = vec3(project_size(rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius, 0.);\n\n  vec4 position_commonspace;\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64xyLow, pos, position_commonspace);\n\n  vec3 normals_commonspace = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n\n  if (extruded && !isStroke) {\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, position_commonspace.xyz, normals_commonspace);\n    vColor = vec4(lightColor, color.a * opacity) / 255.0;\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity) / 255.0;\n  }\n  picking_setPickingColor(instancePickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _columnGeometry = _interopRequireDefault(require("./column-geometry"));

var _columnLayerVertex = _interopRequireDefault(require("./column-layer-vertex.glsl"));

var _columnLayerFragment = _interopRequireDefault(require("./column-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fp64LowPart = _core2.fp64.fp64LowPart;
var defaultMaterial = new _core2.PhongMaterial();
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  diskResolution: {
    type: 'number',
    min: 4,
    value: 20
  },
  vertices: null,
  radius: {
    type: 'number',
    min: 0,
    value: 1000
  },
  angle: {
    type: 'number',
    value: 0
  },
  offset: {
    type: 'array',
    value: [0, 0]
  },
  coverage: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: true,
  fp64: false,
  wireframe: false,
  filled: true,
  stroked: false,
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: defaultMaterial,
  getColor: {
    deprecatedFor: ['getFillColor', 'getLineColor']
  }
};

var ColumnLayer = function (_Layer) {
  (0, _inherits2.default)(ColumnLayer, _Layer);

  function ColumnLayer() {
    (0, _classCallCheck2.default)(this, ColumnLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ColumnLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(ColumnLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: _columnLayerVertex.default,
        fs: _columnLayerFragment.default,
        modules: [projectModule, 'gouraud-lighting', 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          transition: true,
          accessor: 'getPosition'
        },
        instanceElevations: {
          size: 1,
          transition: true,
          accessor: 'getElevation'
        },
        instancePositions64xyLow: {
          size: 2,
          accessor: 'getPosition',
          update: this.calculateInstancePositions64xyLow
        },
        instanceFillColors: {
          size: 4,
          type: 5121,
          transition: true,
          accessor: 'getFillColor',
          defaultValue: DEFAULT_COLOR
        },
        instanceLineColors: {
          size: 4,
          type: 5121,
          transition: true,
          accessor: 'getLineColor',
          defaultValue: DEFAULT_COLOR
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: 'getLineWidth',
          transition: true
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;
      (0, _get2.default)((0, _getPrototypeOf2.default)(ColumnLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });
      var regenerateModels = props.fp64 !== oldProps.fp64;

      if (regenerateModels) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this._getModel(gl)
        });
        this.getAttributeManager().invalidateAll();
      }

      if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices) {
        this._updateGeometry(props);
      }
    }
  }, {
    key: "getGeometry",
    value: function getGeometry(diskResolution, vertices) {
      var geometry = new _columnGeometry.default({
        radius: 1,
        height: 2,
        vertices: vertices,
        nradial: diskResolution
      });
      var meanVertexDistance = 0;

      if (vertices) {
        for (var i = 0; i < diskResolution; i++) {
          var p = vertices[i];
          var d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
          meanVertexDistance += d / diskResolution;
        }
      } else {
        meanVertexDistance = 1;
      }

      this.setState({
        edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
      });
      return geometry;
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      return new _core2.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: "_updateGeometry",
    value: function _updateGeometry(_ref2) {
      var diskResolution = _ref2.diskResolution,
          vertices = _ref2.vertices;
      var geometry = this.getGeometry(diskResolution, vertices);
      this.setState({
        fillVertexCount: geometry.attributes.POSITION.value.length / 3,
        wireframeVertexCount: geometry.indices.value.length
      });
      this.state.model.setProps({
        geometry: geometry
      });
    }
  }, {
    key: "draw",
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;
      var viewport = this.context.viewport;
      var _this$props = this.props,
          lineWidthUnits = _this$props.lineWidthUnits,
          lineWidthScale = _this$props.lineWidthScale,
          lineWidthMinPixels = _this$props.lineWidthMinPixels,
          lineWidthMaxPixels = _this$props.lineWidthMaxPixels,
          elevationScale = _this$props.elevationScale,
          extruded = _this$props.extruded,
          filled = _this$props.filled,
          stroked = _this$props.stroked,
          wireframe = _this$props.wireframe,
          offset = _this$props.offset,
          coverage = _this$props.coverage,
          radius = _this$props.radius,
          angle = _this$props.angle;
      var _this$state = this.state,
          model = _this$state.model,
          fillVertexCount = _this$state.fillVertexCount,
          wireframeVertexCount = _this$state.wireframeVertexCount,
          edgeDistance = _this$state.edgeDistance;
      var widthMultiplier = lineWidthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;
      model.setUniforms(Object.assign({}, uniforms, {
        radius: radius,
        angle: angle / 180 * Math.PI,
        offset: offset,
        extruded: extruded,
        coverage: coverage,
        elevationScale: elevationScale,
        edgeDistance: edgeDistance,
        widthScale: lineWidthScale * widthMultiplier,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels
      }));

      if (extruded && wireframe) {
        model.setProps({
          isIndexed: true
        });
        model.setVertexCount(wireframeVertexCount).setDrawMode(1).setUniforms({
          isStroke: true
        }).draw();
      }

      if (filled) {
        model.setProps({
          isIndexed: false
        });
        model.setVertexCount(fillVertexCount).setDrawMode(5).setUniforms({
          isStroke: false
        }).draw();
      }

      if (!extruded && stroked) {
        model.setProps({
          isIndexed: false
        });
        model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(5).setUniforms({
          isStroke: true
        }).draw();
      }
    }
  }, {
    key: "calculateInstancePositions64xyLow",
    value: function calculateInstancePositions64xyLow(attribute, _ref4) {
      var startRow = _ref4.startRow,
          endRow = _ref4.endRow;
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      var _this$props2 = this.props,
          data = _this$props2.data,
          getPosition = _this$props2.getPosition;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var position = getPosition(object, objectInfo);
          value[i++] = fp64LowPart(position[0]);
          value[i++] = fp64LowPart(position[1]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return ColumnLayer;
}(_core.Layer);

exports.default = ColumnLayer;
ColumnLayer.layerName = 'ColumnLayer';
ColumnLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./column-geometry":"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js","./column-layer-vertex.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js","./column-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@luma.gl/core");

var _columnLayer = _interopRequireDefault(require("./column-layer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultProps = {
  cellSize: {
    type: 'number',
    min: 0,
    value: 1000
  },
  offset: {
    type: 'array',
    min: 0,
    value: [1, 1]
  }
};

var GridCellLayer = function (_ColumnLayer) {
  (0, _inherits2.default)(GridCellLayer, _ColumnLayer);

  function GridCellLayer() {
    (0, _classCallCheck2.default)(this, GridCellLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(GridCellLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(GridCellLayer, [{
    key: "getGeometry",
    value: function getGeometry(diskResolution) {
      return new _core.CubeGeometry();
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var uniforms = _ref.uniforms;
      var _this$props = this.props,
          elevationScale = _this$props.elevationScale,
          extruded = _this$props.extruded,
          offset = _this$props.offset,
          coverage = _this$props.coverage,
          cellSize = _this$props.cellSize,
          angle = _this$props.angle;
      this.state.model.setUniforms(Object.assign({}, uniforms, {
        radius: cellSize / 2,
        angle: angle,
        offset: offset,
        extruded: extruded,
        coverage: coverage,
        elevationScale: elevationScale,
        edgeDistance: 1,
        isWireframe: false
      })).draw();
    }
  }]);
  return GridCellLayer;
}(_columnLayer.default);

exports.default = GridCellLayer;
GridCellLayer.layerName = 'GridCellLayer';
GridCellLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./column-layer":"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Tesselator = _core.experimental.Tesselator;
var fp64LowPart = _core2.fp64.fp64LowPart;

var PathTesselator = function (_Tesselator) {
  (0, _inherits2.default)(PathTesselator, _Tesselator);

  function PathTesselator(_ref) {
    var data = _ref.data,
        getGeometry = _ref.getGeometry,
        positionFormat = _ref.positionFormat,
        fp64 = _ref.fp64;
    (0, _classCallCheck2.default)(this, PathTesselator);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PathTesselator).call(this, {
      data: data,
      getGeometry: getGeometry,
      fp64: fp64,
      positionFormat: positionFormat,
      attributes: {
        startPositions: {
          size: 3
        },
        endPositions: {
          size: 3
        },
        leftPositions: {
          size: 3
        },
        rightPositions: {
          size: 3
        },
        startEndPositions64XyLow: {
          size: 4,
          fp64Only: true
        },
        neighborPositions64XyLow: {
          size: 4,
          fp64Only: true
        }
      }
    }));
  }

  (0, _createClass2.default)(PathTesselator, [{
    key: "get",
    value: function get(attributeName) {
      return this.attributes[attributeName];
    }
  }, {
    key: "getGeometrySize",
    value: function getGeometrySize(path) {
      return Math.max(0, this.getPathLength(path) - 1);
    }
  }, {
    key: "updateGeometryAttributes",
    value: function updateGeometryAttributes(path, context) {
      var _this$attributes = this.attributes,
          startPositions = _this$attributes.startPositions,
          endPositions = _this$attributes.endPositions,
          leftPositions = _this$attributes.leftPositions,
          rightPositions = _this$attributes.rightPositions,
          startEndPositions64XyLow = _this$attributes.startEndPositions64XyLow,
          neighborPositions64XyLow = _this$attributes.neighborPositions64XyLow,
          fp64 = this.fp64;
      var numPoints = context.geometrySize + 1;

      if (numPoints < 2) {
        return;
      }

      var isPathClosed = this.isClosed(path);
      var startPoint = this.getPointOnPath(path, 0);
      var endPoint = this.getPointOnPath(path, 1);
      var prevPoint = isPathClosed ? this.getPointOnPath(path, numPoints - 2) : startPoint;
      var nextPoint;

      for (var i = context.vertexStart, ptIndex = 1; ptIndex < numPoints; i++, ptIndex++) {
        if (ptIndex + 1 < numPoints) {
          nextPoint = this.getPointOnPath(path, ptIndex + 1);
        } else {
          nextPoint = isPathClosed ? this.getPointOnPath(path, 1) : endPoint;
        }

        startPositions[i * 3] = startPoint[0];
        startPositions[i * 3 + 1] = startPoint[1];
        startPositions[i * 3 + 2] = startPoint[2] || 0;
        endPositions[i * 3] = endPoint[0];
        endPositions[i * 3 + 1] = endPoint[1];
        endPositions[i * 3 + 2] = endPoint[2] || 0;
        leftPositions[i * 3] = prevPoint[0];
        leftPositions[i * 3 + 1] = prevPoint[1];
        leftPositions[i * 3 + 2] = prevPoint[2] || 0;
        rightPositions[i * 3] = nextPoint[0];
        rightPositions[i * 3 + 1] = nextPoint[1];
        rightPositions[i * 3 + 2] = nextPoint[2] || 0;

        if (fp64) {
          startEndPositions64XyLow[i * 4] = fp64LowPart(startPoint[0]);
          startEndPositions64XyLow[i * 4 + 1] = fp64LowPart(startPoint[1]);
          startEndPositions64XyLow[i * 4 + 2] = fp64LowPart(endPoint[0]);
          startEndPositions64XyLow[i * 4 + 3] = fp64LowPart(endPoint[1]);
          neighborPositions64XyLow[i * 4] = fp64LowPart(prevPoint[0]);
          neighborPositions64XyLow[i * 4 + 1] = fp64LowPart(prevPoint[1]);
          neighborPositions64XyLow[i * 4 + 2] = fp64LowPart(nextPoint[0]);
          neighborPositions64XyLow[i * 4 + 3] = fp64LowPart(nextPoint[1]);
        }

        prevPoint = startPoint;
        startPoint = endPoint;
        endPoint = nextPoint;
      }
    }
  }, {
    key: "getPathLength",
    value: function getPathLength(path) {
      if (Number.isFinite(path[0])) {
        return path.length / this.positionSize;
      }

      return path.length;
    }
  }, {
    key: "getPointOnPath",
    value: function getPointOnPath(path, index) {
      if (Number.isFinite(path[0])) {
        var positionSize = this.positionSize;
        return [path[index * positionSize], path[index * positionSize + 1], positionSize === 3 ? path[index * positionSize + 2] : 0];
      }

      return path[index];
    }
  }, {
    key: "isClosed",
    value: function isClosed(path) {
      var numPoints = this.getPathLength(path);
      var firstPoint = this.getPointOnPath(path, 0);
      var lastPoint = this.getPointOnPath(path, numPoints - 1);
      return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] && firstPoint[2] === lastPoint[2];
    }
  }]);
  return PathTesselator;
}(Tesselator);

exports.default = PathTesselator;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  float relativePosition, bool isEnd, bool isJoint,\n  vec2 width\n) {\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  lenA = lenA > EPSILON ? lenA : 0.0;\n  lenB = lenB > EPSILON ? lenB : 0.0;\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  float cornerPosition = isJoint ?\n    0.0 :\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\n  cornerPosition *=\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\n  if (cornerPosition < 0.0) {\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\n  }\n\n  vMiterLength = cornerPosition >= 0.0 ?\n    mix(offsetScale, 0.0, cornerPosition) :\n    offsetScale * cornerPosition;\n  vMiterLength -= sinHalfA * jointType;\n\n  float offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  bool isStartCap = step(0.0, -lenA) > 0.5;\n  bool isEndCap = step(0.0, -lenB) > 0.5;\n  bool isCap = isStartCap || isEndCap;\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\n  if (isStartCap) {\n    offsetVec = mix(dirB, perpB, cornerPosition);\n  }\n  if (isEndCap) {\n    offsetVec = mix(dirA, perpA, cornerPosition);\n  }\n  if (isCap) {\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\n    vMiterLength = 1.0 - cornerPosition;\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\n  }\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L;\n  vec2 offsetFromStartOfPath = vCornerOffset;\n  if (isEnd) {\n    offsetFromStartOfPath += deltaA;\n  }\n  vec2 dir = isEnd ? dirA : dirB;\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return currPoint + vec3(vCornerOffset * width, 0.0);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float relativePosition = positions.y;\n  bool isEnd = positions.x > EPSILON;\n  bool isJoint = positions.z > EPSILON;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  return lineJoin(\n    prevPoint, currPoint, nextPoint,\n    relativePosition, isEnd, isJoint,\n    billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels)\n  );\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\n    currPosition = project_position(currPosition, currPosition64xyLow);\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\n\n    vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n    gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));\n  }\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex-64.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME path-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec4 instanceNeighborPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\nvec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {\n\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n  float width = project_pixel_size(widthPixels);\n\n  vec2 deltaA64[2];\n  vec2 deltaB64[2];\n\n  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);\n  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);\n\n  vec2 lengthA64 = vec2_length_fp64(deltaA64);\n  vec2 lengthB64 = vec2_length_fp64(deltaB64);\n\n  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);\n  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);\n\n  float lenA = lengthA64.x;\n  float lenB = lengthB64.x;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\n  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  float isStartCap = step(lenA, 1.0e-5);\n  float isEndCap = step(lenB, 1.0e-5);\n  float isCap = max(isStartCap, isEndCap);\n  cornerPosition = isCap * (1.0 - positions.z);\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L / width;\n  float isEnd = positions.x;\n  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);\n  vec2 dir = mix(dirB, dirA, isEnd);\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);\n  float projected_curr_position_z = project_size(currPosition.z);\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\n\n  vec2 projected_prev_position[2];\n  project_position_fp64(prevPosition.xy, prevPosition64xyLow, projected_prev_position);\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\n\n  vec2 projected_next_position[2];\n  project_position_fp64(nextPosition.xy, nextPosition64xyLow, projected_next_position);\n\n  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);\n  vec2 vertex_pos_modelspace[4];\n\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\nuniform float alignMode;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\nbool dash_isFragInGap() {\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = alignMode * solidLength / 2.0;\n\n  return gapLength > 0.0 &&\n    vPathPosition.y >= 0.0 &&\n    vPathPosition.y <= vPathLength &&\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\n}\n\nvoid main(void) {\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\n    discard;\n  }\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _pathTesselator = _interopRequireDefault(require("./path-tesselator"));

var _pathLayerVertex = _interopRequireDefault(require("./path-layer-vertex.glsl"));

var _pathLayerVertex2 = _interopRequireDefault(require("./path-layer-vertex-64.glsl"));

var _pathLayerFragment = _interopRequireDefault(require("./path-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  widthUnits: 'meters',
  widthScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  widthMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  widthMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  rounded: false,
  miterLimit: {
    type: 'number',
    min: 0,
    value: 4
  },
  fp64: false,
  dashJustified: false,
  billboard: false,
  getPath: {
    type: 'accessor',
    value: function value(object) {
      return object.path;
    }
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  getDashArray: {
    type: 'accessor',
    value: [0, 0]
  }
};
var ATTRIBUTE_TRANSITION = {
  enter: function enter(value, chunk) {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};

var PathLayer = function (_Layer) {
  (0, _inherits2.default)(PathLayer, _Layer);

  function PathLayer() {
    (0, _classCallCheck2.default)(this, PathLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PathLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(PathLayer, [{
    key: "getShaders",
    value: function getShaders() {
      return this.use64bitProjection() ? {
        vs: _pathLayerVertex2.default,
        fs: _pathLayerFragment.default,
        modules: ['project64', 'picking']
      } : {
        vs: _pathLayerVertex.default,
        fs: _pathLayerFragment.default,
        modules: ['project32', 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var _this = this;

      var noAlloc = true;
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceStartPositions: {
          size: 3,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getPath',
          update: this.calculateStartPositions,
          noAlloc: noAlloc
        },
        instanceEndPositions: {
          size: 3,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getPath',
          update: this.calculateEndPositions,
          noAlloc: noAlloc
        },
        instanceStartEndPositions64xyLow: {
          size: 4,
          update: this.calculateInstanceStartEndPositions64xyLow,
          noAlloc: noAlloc
        },
        instanceLeftPositions: {
          size: 3,
          accessor: 'getPath',
          update: this.calculateLeftPositions,
          noAlloc: noAlloc
        },
        instanceRightPositions: {
          size: 3,
          accessor: 'getPath',
          update: this.calculateRightPositions,
          noAlloc: noAlloc
        },
        instanceNeighborPositions64xyLow: {
          size: 4,
          update: this.calculateInstanceNeighborPositions64xyLow,
          noAlloc: noAlloc
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: 'getWidth',
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: 1
        },
        instanceDashArrays: {
          size: 2,
          accessor: 'getDashArray'
        },
        instanceColors: {
          size: 4,
          type: 5121,
          accessor: 'getColor',
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: DEFAULT_COLOR
        },
        instancePickingColors: {
          size: 3,
          type: 5121,
          accessor: function accessor(object, _ref) {
            var index = _ref.index,
                value = _ref.target;
            return _this.encodePickingColor(index, value);
          }
        }
      });
      this.setState({
        pathTesselator: new _pathTesselator.default({})
      });
    }
  }, {
    key: "updateState",
    value: function updateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          changeFlags = _ref2.changeFlags;
      (0, _get2.default)((0, _getPrototypeOf2.default)(PathLayer.prototype), "updateState", this).call(this, {
        props: props,
        oldProps: oldProps,
        changeFlags: changeFlags
      });
      var attributeManager = this.getAttributeManager();
      var geometryChanged = changeFlags.dataChanged || props.fp64 !== oldProps.fp64 || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);

      if (geometryChanged) {
        var pathTesselator = this.state.pathTesselator;
        pathTesselator.updateGeometry({
          data: props.data,
          getGeometry: props.getPath,
          positionFormat: props.positionFormat,
          fp64: this.use64bitPositions()
        });
        this.setState({
          numInstances: pathTesselator.instanceCount,
          bufferLayout: pathTesselator.bufferLayout
        });
        attributeManager.invalidateAll();
      }

      if (props.fp64 !== oldProps.fp64) {
        var gl = this.context.gl;

        if (this.state.model) {
          this.state.model.delete();
        }

        this.setState({
          model: this._getModel(gl)
        });
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: "draw",
    value: function draw(_ref3) {
      var uniforms = _ref3.uniforms;
      var viewport = this.context.viewport;
      var _this$props = this.props,
          rounded = _this$props.rounded,
          billboard = _this$props.billboard,
          miterLimit = _this$props.miterLimit,
          widthUnits = _this$props.widthUnits,
          widthScale = _this$props.widthScale,
          widthMinPixels = _this$props.widthMinPixels,
          widthMaxPixels = _this$props.widthMaxPixels,
          dashJustified = _this$props.dashJustified;
      var widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;
      this.state.model.setUniforms(Object.assign({}, uniforms, {
        jointType: Number(rounded),
        billboard: billboard,
        alignMode: Number(dashJustified),
        widthScale: widthScale * widthMultiplier,
        miterLimit: miterLimit,
        widthMinPixels: widthMinPixels,
        widthMaxPixels: widthMaxPixels
      })).draw();
    }
  }, {
    key: "_getModel",
    value: function _getModel(gl) {
      var SEGMENT_INDICES = [0, 2, 1, 1, 2, 4, 1, 4, 3, 3, 4, 5];
      var SEGMENT_POSITIONS = [0, 0, 1, 0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0, 1, 0, 1];
      return new _core2.Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _core2.Geometry({
          drawMode: 4,
          attributes: {
            indices: new Uint16Array(SEGMENT_INDICES),
            positions: new Float32Array(SEGMENT_POSITIONS)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: "calculateStartPositions",
    value: function calculateStartPositions(attribute) {
      var pathTesselator = this.state.pathTesselator;
      attribute.bufferLayout = pathTesselator.bufferLayout;
      attribute.value = pathTesselator.get('startPositions');
    }
  }, {
    key: "calculateEndPositions",
    value: function calculateEndPositions(attribute) {
      var pathTesselator = this.state.pathTesselator;
      attribute.bufferLayout = pathTesselator.bufferLayout;
      attribute.value = pathTesselator.get('endPositions');
    }
  }, {
    key: "calculateInstanceStartEndPositions64xyLow",
    value: function calculateInstanceStartEndPositions64xyLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (isFP64) {
        attribute.value = this.state.pathTesselator.get('startEndPositions64XyLow');
      } else {
        attribute.value = new Float32Array(4);
      }
    }
  }, {
    key: "calculateLeftPositions",
    value: function calculateLeftPositions(attribute) {
      var pathTesselator = this.state.pathTesselator;
      attribute.value = pathTesselator.get('leftPositions');
    }
  }, {
    key: "calculateRightPositions",
    value: function calculateRightPositions(attribute) {
      var pathTesselator = this.state.pathTesselator;
      attribute.value = pathTesselator.get('rightPositions');
    }
  }, {
    key: "calculateInstanceNeighborPositions64xyLow",
    value: function calculateInstanceNeighborPositions64xyLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (isFP64) {
        attribute.value = this.state.pathTesselator.get('neighborPositions64XyLow');
      } else {
        attribute.value = new Float32Array(4);
      }
    }
  }, {
    key: "clearPickingColor",
    value: function clearPickingColor(color) {
      var pickedPathIndex = this.decodePickingColor(color);
      var bufferLayout = this.state.pathTesselator.bufferLayout;
      var numVertices = bufferLayout[pickedPathIndex];
      var startInstanceIndex = 0;

      for (var pathIndex = 0; pathIndex < pickedPathIndex; pathIndex++) {
        startInstanceIndex += bufferLayout[pathIndex];
      }

      var instancePickingColors = this.getAttributeManager().attributes.instancePickingColors;
      var value = instancePickingColors.value;
      var endInstanceIndex = startInstanceIndex + numVertices;
      value.fill(0, startInstanceIndex * 3, endInstanceIndex * 3);
      instancePickingColors.update({
        value: value
      });
    }
  }]);
  return PathLayer;
}(_core.Layer);

exports.default = PathLayer;
PathLayer.layerName = 'PathLayer';
PathLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./path-tesselator":"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","./path-layer-vertex.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","./path-layer-vertex-64.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex-64.glsl.js","./path-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js"}],"../../../node_modules/earcut/src/earcut.js":[function(require,module,exports) {
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVertexCount = getVertexCount;
exports.normalize = normalize;
exports.getSurfaceIndices = getSurfaceIndices;

var _earcut = _interopRequireDefault(require("earcut"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;

  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error('invalid polygon');
  }
}

function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}

function isNestedRingClosed(simplePolygon) {
  var p0 = simplePolygon[0];
  var p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}

function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (var i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }

  return true;
}

function copyNestedRing(target, targetStartIndex, simplePolygon, size) {
  var targetIndex = targetStartIndex;
  var len = simplePolygon.length;

  for (var i = 0; i < len; i++) {
    for (var j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }

  if (!isNestedRingClosed(simplePolygon)) {
    for (var _j = 0; _j < size; _j++) {
      target[targetIndex++] = simplePolygon[0][_j] || 0;
    }
  }

  return targetIndex;
}

function copyFlatRing(target, targetStartIndex, positions, size) {
  var srcStartIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var srcEndIndex = arguments.length > 5 ? arguments[5] : undefined;
  srcEndIndex = srcEndIndex || positions.length;
  var srcLength = srcEndIndex - srcStartIndex;

  if (srcLength <= 0) {
    return targetStartIndex;
  }

  var targetIndex = targetStartIndex;

  for (var i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }

  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (var _i = 0; _i < size; _i++) {
      target[targetIndex++] = positions[srcStartIndex + _i];
    }
  }

  return targetIndex;
}

function getNestedVertexCount(simplePolygon) {
  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;
}

function getFlatVertexCount(positions, size) {
  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var endIndex = arguments.length > 3 ? arguments[3] : undefined;
  endIndex = endIndex || positions.length;

  if (startIndex >= endIndex) {
    return 0;
  }

  return (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) + (endIndex - startIndex) / size;
}

function getVertexCount(polygon, positionSize) {
  validate(polygon);

  if (polygon.positions) {
    var _polygon = polygon,
        positions = _polygon.positions,
        holeIndices = _polygon.holeIndices;

    if (holeIndices) {
      var vertexCount = 0;

      for (var i = 0; i <= holeIndices.length; i++) {
        vertexCount += getFlatVertexCount(polygon.positions, positionSize, holeIndices[i - 1], holeIndices[i]);
      }

      return vertexCount;
    }

    polygon = positions;
  }

  if (Number.isFinite(polygon[0])) {
    return getFlatVertexCount(polygon, positionSize);
  }

  if (!isSimple(polygon)) {
    var _vertexCount = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var simplePolygon = _step.value;
        _vertexCount += getNestedVertexCount(simplePolygon);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return _vertexCount;
  }

  return getNestedVertexCount(polygon);
}

function normalize(polygon, positionSize, vertexCount) {
  validate(polygon);
  vertexCount = vertexCount || getVertexCount(polygon, positionSize);
  var positions = new Float64Array(vertexCount * positionSize);
  var holeIndices = [];

  if (polygon.positions) {
    var _polygon2 = polygon,
        srcPositions = _polygon2.positions,
        srcHoleIndices = _polygon2.holeIndices;

    if (srcHoleIndices) {
      var targetIndex = 0;

      for (var i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i]);
        holeIndices.push(targetIndex);
      }

      holeIndices.pop();
      return {
        positions: positions,
        holeIndices: holeIndices
      };
    }

    polygon = srcPositions;
  }

  if (Number.isFinite(polygon[0])) {
    copyFlatRing(positions, 0, polygon, positionSize);
    return {
      positions: positions,
      holeIndices: null
    };
  }

  if (!isSimple(polygon)) {
    var _targetIndex = 0;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = polygon[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var simplePolygon = _step2.value;
        _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize);
        holeIndices.push(_targetIndex);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    holeIndices.pop();
    return {
      positions: positions,
      holeIndices: holeIndices
    };
  }

  copyNestedRing(positions, 0, polygon, positionSize);
  return {
    positions: positions,
    holeIndices: null
  };
}

function getSurfaceIndices(normalizedPolygon, positionSize) {
  var holeIndices = null;

  if (normalizedPolygon.holeIndices) {
    holeIndices = normalizedPolygon.holeIndices.map(function (positionIndex) {
      return positionIndex / positionSize;
    });
  }

  return (0, _earcut.default)(normalizedPolygon.positions, holeIndices, positionSize);
}
},{"earcut":"../../../node_modules/earcut/src/earcut.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var Polygon = _interopRequireWildcard(require("./polygon"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Tesselator = _core.experimental.Tesselator;
var fp64LowPart = _core2.fp64.fp64LowPart;

var PolygonTesselator = function (_Tesselator) {
  (0, _inherits2.default)(PolygonTesselator, _Tesselator);

  function PolygonTesselator(_ref) {
    var data = _ref.data,
        getGeometry = _ref.getGeometry,
        fp64 = _ref.fp64,
        positionFormat = _ref.positionFormat,
        _ref$IndexType = _ref.IndexType,
        IndexType = _ref$IndexType === void 0 ? Uint32Array : _ref$IndexType;
    (0, _classCallCheck2.default)(this, PolygonTesselator);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PolygonTesselator).call(this, {
      data: data,
      getGeometry: getGeometry,
      fp64: fp64,
      positionFormat: positionFormat,
      attributes: {
        positions: {
          size: 3
        },
        positions64xyLow: {
          size: 2,
          fp64Only: true
        },
        vertexValid: {
          type: Uint8ClampedArray,
          size: 1
        },
        indices: {
          type: IndexType,
          size: 1
        }
      }
    }));
  }

  (0, _createClass2.default)(PolygonTesselator, [{
    key: "get",
    value: function get(attributeName) {
      if (attributeName === 'indices') {
        return this.attributes.indices.subarray(0, this.vertexCount);
      }

      return this.attributes[attributeName];
    }
  }, {
    key: "getGeometrySize",
    value: function getGeometrySize(polygon) {
      return Polygon.getVertexCount(polygon, this.positionSize);
    }
  }, {
    key: "updateGeometryAttributes",
    value: function updateGeometryAttributes(polygon, context) {
      polygon = Polygon.normalize(polygon, this.positionSize, context.geometrySize);

      this._updateIndices(polygon, context);

      this._updatePositions(polygon, context);
    }
  }, {
    key: "_updateIndices",
    value: function _updateIndices(polygon, _ref2) {
      var geometryIndex = _ref2.geometryIndex,
          offset = _ref2.vertexStart,
          indexStart = _ref2.indexStart;
      var attributes = this.attributes,
          indexLayout = this.indexLayout,
          typedArrayManager = this.typedArrayManager;
      var target = attributes.indices;
      var currentLength = target.length;
      var i = indexStart;
      var indices = Polygon.getSurfaceIndices(polygon, this.positionSize);

      if (currentLength < i + indices.length) {
        currentLength = (i + indices.length) * 2;
        target = typedArrayManager.allocate(target, currentLength, {
          type: target.constructor,
          size: 1,
          copy: true
        });
      }

      for (var j = 0; j < indices.length; j++) {
        target[i++] = indices[j] + offset;
      }

      indexLayout[geometryIndex] = indices.length;
      attributes.indices = target;
    }
  }, {
    key: "_updatePositions",
    value: function _updatePositions(polygon, _ref3) {
      var vertexStart = _ref3.vertexStart,
          geometrySize = _ref3.geometrySize;
      var _this$attributes = this.attributes,
          positions = _this$attributes.positions,
          positions64xyLow = _this$attributes.positions64xyLow,
          vertexValid = _this$attributes.vertexValid,
          fp64 = this.fp64,
          positionSize = this.positionSize;
      var i = vertexStart;
      var polygonPositions = polygon.positions,
          holeIndices = polygon.holeIndices;

      for (var j = 0; j < geometrySize; j++) {
        var x = polygonPositions[j * positionSize];
        var y = polygonPositions[j * positionSize + 1];
        var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        if (fp64) {
          positions64xyLow[i * 2] = fp64LowPart(x);
          positions64xyLow[i * 2 + 1] = fp64LowPart(y);
        }

        vertexValid[i] = 1;
        i++;
      }

      if (holeIndices) {
        for (var _j = 0; _j < holeIndices.length; _j++) {
          vertexValid[vertexStart + holeIndices[_j] / positionSize - 1] = 0;
        }
      }

      vertexValid[vertexStart + geometrySize - 1] = 0;
    }
  }]);
  return PolygonTesselator;
}(Tesselator);

exports.default = PolygonTesselator;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","./polygon":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying float isValid;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec2 positions64xyLow;\n  vec2 nextPositions64xyLow;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNG_LAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n  vec3 pos;\n  vec2 pos64xyLow;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64xyLow = mix(props.positions64xyLow, props.nextPositions64xyLow, vertexPositions.x);\n  isValid = vertexValid;\n#else\n  pos = props.positions;\n  pos64xyLow = props.positions64xyLow;\n  isValid = 1.0;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n\n  vec4 position_commonspace;\n  gl_Position = project_position_to_clipspace(pos, pos64xyLow, vec3(0.), position_commonspace);\n\n  if (extruded) {\n#ifdef IS_SIDE_VERTEX\n    normal = vec3(props.positions.y - props.nextPositions.y, props.nextPositions.x - props.positions.x, 0.0);\n    normal = project_offset_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity) / 255.0;\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity) / 255.0;\n  }\n  picking_setPickingColor(props.pickingColors);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _solidPolygonLayerVertexMain = _interopRequireDefault(require("./solid-polygon-layer-vertex-main.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec2 positions64xyLow;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(_solidPolygonLayerVertexMain.default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64xyLow = positions64xyLow;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n");

exports.default = _default;
},{"./solid-polygon-layer-vertex-main.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _solidPolygonLayerVertexMain = _interopRequireDefault(require("./solid-polygon-layer-vertex-main.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec3 nextPositions;\nattribute vec2 nextPositions64xyLow;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(_solidPolygonLayerVertexMain.default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = instancePositions;\n  props.positions64xyLow = instancePositions64xyLow;\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n  props.nextPositions = nextPositions;\n  props.nextPositions64xyLow = nextPositions64xyLow;\n\n  calculatePosition(props);\n}\n");

exports.default = _default;
},{"./solid-polygon-layer-vertex-main.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid < 0.5) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _polygonTesselator = _interopRequireDefault(require("./polygon-tesselator"));

var _solidPolygonLayerVertexTop = _interopRequireDefault(require("./solid-polygon-layer-vertex-top.glsl"));

var _solidPolygonLayerVertexSide = _interopRequireDefault(require("./solid-polygon-layer-vertex-side.glsl"));

var _solidPolygonLayerFragment = _interopRequireDefault(require("./solid-polygon-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultMaterial = new _core2.PhongMaterial();
var defaultProps = {
  filled: true,
  extruded: false,
  wireframe: false,
  fp64: false,
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  getPolygon: {
    type: 'accessor',
    value: function value(f) {
      return f.polygon;
    }
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  material: defaultMaterial
};
var ATTRIBUTE_TRANSITION = {
  enter: function enter(value, chunk) {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};

var SolidPolygonLayer = function (_Layer) {
  (0, _inherits2.default)(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    (0, _classCallCheck2.default)(this, SolidPolygonLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SolidPolygonLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(SolidPolygonLayer, [{
    key: "getShaders",
    value: function getShaders(vs) {
      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';
      return {
        vs: vs,
        fs: _solidPolygonLayerFragment.default,
        defines: {},
        modules: [projectModule, 'gouraud-lighting', 'picking']
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      var _this = this;

      var gl = this.context.gl;
      this.setState({
        numInstances: 0,
        polygonTesselator: new _polygonTesselator.default({
          IndexType: !gl || (0, _core2.hasFeature)(gl, _core2.FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
        })
      });
      var attributeManager = this.getAttributeManager();
      var noAlloc = true;
      attributeManager.remove(['instancePickingColors']);
      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: this.calculateIndices,
          noAlloc: noAlloc
        },
        positions: {
          size: 3,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getPolygon',
          update: this.calculatePositions,
          noAlloc: noAlloc,
          shaderAttributes: {
            positions: {
              offset: 0,
              divisor: 0
            },
            instancePositions: {
              offset: 0,
              divisor: 1
            },
            nextPositions: {
              offset: 12,
              divisor: 1
            }
          }
        },
        positions64xyLow: {
          size: 2,
          update: this.calculatePositionsLow,
          noAlloc: noAlloc,
          shaderAttributes: {
            positions64xyLow: {
              offset: 0,
              divisor: 0
            },
            instancePositions64xyLow: {
              offset: 0,
              divisor: 1
            },
            nextPositions64xyLow: {
              offset: 8,
              divisor: 1
            }
          }
        },
        vertexValid: {
          size: 1,
          divisor: 1,
          type: 5121,
          update: this.calculateVertexValid,
          noAlloc: noAlloc
        },
        elevations: {
          size: 1,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getElevation',
          shaderAttributes: {
            elevations: {
              divisor: 0
            },
            instanceElevations: {
              divisor: 1
            }
          }
        },
        fillColors: {
          alias: 'colors',
          size: 4,
          type: 5121,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getFillColor',
          defaultValue: DEFAULT_COLOR,
          shaderAttributes: {
            fillColors: {
              divisor: 0
            },
            instanceFillColors: {
              divisor: 1
            }
          }
        },
        lineColors: {
          alias: 'colors',
          size: 4,
          type: 5121,
          transition: ATTRIBUTE_TRANSITION,
          accessor: 'getLineColor',
          defaultValue: DEFAULT_COLOR,
          shaderAttributes: {
            lineColors: {
              divisor: 0
            },
            instanceLineColors: {
              divisor: 1
            }
          }
        },
        pickingColors: {
          size: 3,
          type: 5121,
          accessor: function accessor(object, _ref) {
            var index = _ref.index,
                value = _ref.target;
            return _this.encodePickingColor(index, value);
          },
          shaderAttributes: {
            pickingColors: {
              divisor: 0
            },
            instancePickingColors: {
              divisor: 1
            }
          }
        }
      });
    }
  }, {
    key: "draw",
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _this$props = this.props,
          extruded = _this$props.extruded,
          filled = _this$props.filled,
          wireframe = _this$props.wireframe,
          elevationScale = _this$props.elevationScale;
      var _this$state = this.state,
          topModel = _this$state.topModel,
          sideModel = _this$state.sideModel,
          polygonTesselator = _this$state.polygonTesselator;
      var renderUniforms = Object.assign({}, uniforms, {
        extruded: Boolean(extruded),
        elevationScale: elevationScale
      });

      if (sideModel) {
        sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
        sideModel.setUniforms(renderUniforms);

        if (wireframe) {
          sideModel.setDrawMode(3);
          sideModel.setUniforms({
            isWireframe: true
          }).draw();
        }

        if (filled) {
          sideModel.setDrawMode(6);
          sideModel.setUniforms({
            isWireframe: false
          }).draw();
        }
      }

      if (topModel) {
        topModel.setVertexCount(polygonTesselator.get('indices').length);
        topModel.setUniforms(renderUniforms).draw();
      }
    }
  }, {
    key: "updateState",
    value: function updateState(updateParams) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(SolidPolygonLayer.prototype), "updateState", this).call(this, updateParams);
      this.updateGeometry(updateParams);
      var props = updateParams.props,
          oldProps = updateParams.oldProps;
      var attributeManager = this.getAttributeManager();
      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;

      if (regenerateModels) {
        if (this.state.models) {
          this.state.models.forEach(function (model) {
            return model.delete();
          });
        }

        this.setState(this._getModels(this.context.gl));
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: "updateGeometry",
    value: function updateGeometry(_ref3) {
      var props = _ref3.props,
          oldProps = _ref3.oldProps,
          changeFlags = _ref3.changeFlags;
      var geometryConfigChanged = changeFlags.dataChanged || props.fp64 !== oldProps.fp64 || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);

      if (geometryConfigChanged) {
        var polygonTesselator = this.state.polygonTesselator;
        polygonTesselator.updateGeometry({
          data: props.data,
          getGeometry: props.getPolygon,
          positionFormat: props.positionFormat,
          fp64: this.use64bitPositions()
        });
        this.setState({
          numInstances: polygonTesselator.instanceCount,
          bufferLayout: polygonTesselator.bufferLayout
        });
        this.getAttributeManager().invalidateAll();
      }
    }
  }, {
    key: "_getModels",
    value: function _getModels(gl) {
      var _this$props2 = this.props,
          id = _this$props2.id,
          filled = _this$props2.filled,
          extruded = _this$props2.extruded;
      var topModel;
      var sideModel;

      if (filled) {
        var shaders = this.getShaders(_solidPolygonLayerVertexTop.default);
        shaders.defines.NON_INSTANCED_MODEL = 1;
        topModel = new _core2.Model(gl, Object.assign({}, shaders, {
          id: "".concat(id, "-top"),
          drawMode: 4,
          attributes: {
            vertexPositions: new Float32Array([0, 1])
          },
          uniforms: {
            isWireframe: false,
            isSideVertex: false
          },
          vertexCount: 0,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        }));
      }

      if (extruded) {
        sideModel = new _core2.Model(gl, Object.assign({}, this.getShaders(_solidPolygonLayerVertexSide.default), {
          id: "".concat(id, "-side"),
          geometry: new _core2.Geometry({
            drawMode: 1,
            vertexCount: 4,
            attributes: {
              vertexPositions: {
                size: 2,
                value: new Float32Array([1, 1, 0, 1, 0, 0, 1, 0])
              }
            }
          }),
          instanceCount: 0,
          isInstanced: 1,
          shaderCache: this.context.shaderCache
        }));
        sideModel.userData.excludeAttributes = {
          indices: true
        };
      }

      return {
        models: [sideModel, topModel].filter(Boolean),
        topModel: topModel,
        sideModel: sideModel
      };
    }
  }, {
    key: "calculateIndices",
    value: function calculateIndices(attribute) {
      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.indexLayout;
      attribute.value = polygonTesselator.get('indices');
    }
  }, {
    key: "calculatePositions",
    value: function calculatePositions(attribute) {
      var polygonTesselator = this.state.polygonTesselator;
      attribute.bufferLayout = polygonTesselator.bufferLayout;
      attribute.value = polygonTesselator.get('positions');
    }
  }, {
    key: "calculatePositionsLow",
    value: function calculatePositionsLow(attribute) {
      var isFP64 = this.use64bitPositions();
      attribute.constant = !isFP64;

      if (!isFP64) {
        attribute.value = new Float32Array(2);
        return;
      }

      attribute.value = this.state.polygonTesselator.get('positions64xyLow');
    }
  }, {
    key: "calculateVertexValid",
    value: function calculateVertexValid(attribute) {
      attribute.value = this.state.polygonTesselator.get('vertexValid');
    }
  }, {
    key: "clearPickingColor",
    value: function clearPickingColor(color) {
      var pickedPolygonIndex = this.decodePickingColor(color);
      var bufferLayout = this.state.polygonTesselator.bufferLayout;
      var numVertices = bufferLayout[pickedPolygonIndex];
      var startInstanceIndex = 0;

      for (var polygonIndex = 0; polygonIndex < pickedPolygonIndex; polygonIndex++) {
        startInstanceIndex += bufferLayout[polygonIndex];
      }

      var pickingColors = this.getAttributeManager().attributes.pickingColors;
      var value = pickingColors.value;
      var endInstanceIndex = startInstanceIndex + numVertices;
      value.fill(0, startInstanceIndex * 3, endInstanceIndex * 3);
      pickingColors.update({
        value: value
      });
    }
  }]);
  return SolidPolygonLayer;
}(_core.Layer);

exports.default = SolidPolygonLayer;
SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","./polygon-tesselator":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js","./solid-polygon-layer-vertex-top.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js","./solid-polygon-layer-vertex-side.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js","./solid-polygon-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@luma.gl/core");

var _core2 = require("@deck.gl/core");

var _solidPolygonLayer = _interopRequireDefault(require("../solid-polygon-layer/solid-polygon-layer"));

var _pathLayer = _interopRequireDefault(require("../path-layer/path-layer"));

var Polygon = _interopRequireWildcard(require("../solid-polygon-layer/polygon"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultLineColor = [0, 0, 0, 255];
var defaultFillColor = [0, 0, 0, 255];
var defaultMaterial = new _core.PhongMaterial();
var defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  lineDashJustified: false,
  fp64: false,
  getPolygon: {
    type: 'accessor',
    value: function value(f) {
      return f.polygon;
    }
  },
  getFillColor: {
    type: 'accessor',
    value: defaultFillColor
  },
  getLineColor: {
    type: 'accessor',
    value: defaultLineColor
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getLineDashArray: {
    type: 'accessor',
    value: [0, 0]
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: defaultMaterial
};

var PolygonLayer = function (_CompositeLayer) {
  (0, _inherits2.default)(PolygonLayer, _CompositeLayer);

  function PolygonLayer() {
    (0, _classCallCheck2.default)(this, PolygonLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PolygonLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(PolygonLayer, [{
    key: "initializeState",
    value: function initializeState() {
      this.state = {
        paths: []
      };
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;
      var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);

      if (geometryChanged) {
        this.state.paths = this._getPaths(props);
      }
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref2) {
      var info = _ref2.info;
      return Object.assign(info, {
        object: info.object && info.object.object || info.object
      });
    }
  }, {
    key: "_getPaths",
    value: function _getPaths(_ref3) {
      var data = _ref3.data,
          getPolygon = _ref3.getPolygon,
          positionFormat = _ref3.positionFormat;
      var paths = [];
      var positionSize = positionFormat === 'XY' ? 2 : 3;

      var _createIterable = (0, _core2.createIterable)(data),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;

          var _Polygon$normalize = Polygon.normalize(getPolygon(object, objectInfo), positionSize),
              positions = _Polygon$normalize.positions,
              holeIndices = _Polygon$normalize.holeIndices;

          if (holeIndices) {
            for (var i = 0; i <= holeIndices.length; i++) {
              var path = positions.subarray(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);
              paths.push({
                path: path,
                object: object
              });
            }
          } else {
            paths.push({
              path: positions,
              object: object
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return paths;
    }
  }, {
    key: "_getAccessor",
    value: function _getAccessor(accessor) {
      if (typeof accessor === 'function') {
        return function (x) {
          return accessor(x.object);
        };
      }

      return accessor;
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var _this$props = this.props,
          data = _this$props.data,
          stroked = _this$props.stroked,
          filled = _this$props.filled,
          extruded = _this$props.extruded,
          wireframe = _this$props.wireframe,
          elevationScale = _this$props.elevationScale,
          transitions = _this$props.transitions;
      var _this$props2 = this.props,
          lineWidthUnits = _this$props2.lineWidthUnits,
          lineWidthScale = _this$props2.lineWidthScale,
          lineWidthMinPixels = _this$props2.lineWidthMinPixels,
          lineWidthMaxPixels = _this$props2.lineWidthMaxPixels,
          lineJointRounded = _this$props2.lineJointRounded,
          lineMiterLimit = _this$props2.lineMiterLimit,
          lineDashJustified = _this$props2.lineDashJustified,
          fp64 = _this$props2.fp64;
      var _this$props3 = this.props,
          getFillColor = _this$props3.getFillColor,
          getLineColor = _this$props3.getLineColor,
          getLineWidth = _this$props3.getLineWidth,
          getLineDashArray = _this$props3.getLineDashArray,
          getElevation = _this$props3.getElevation,
          getPolygon = _this$props3.getPolygon,
          updateTriggers = _this$props3.updateTriggers,
          material = _this$props3.material;
      var paths = this.state.paths;
      var FillLayer = this.getSubLayerClass('fill', _solidPolygonLayer.default);
      var StrokeLayer = this.getSubLayerClass('stroke', _pathLayer.default);
      var polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({
        extruded: extruded,
        elevationScale: elevationScale,
        fp64: fp64,
        filled: filled,
        wireframe: wireframe,
        getElevation: getElevation,
        getFillColor: getFillColor,
        getLineColor: getLineColor,
        material: material,
        transitions: transitions
      }, this.getSubLayerProps({
        id: 'fill',
        updateTriggers: {
          getPolygon: updateTriggers.getPolygon,
          getElevation: updateTriggers.getElevation,
          getFillColor: updateTriggers.getFillColor,
          getLineColor: updateTriggers.getLineColor
        }
      }), {
        data: data,
        getPolygon: getPolygon
      });
      var polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({
        fp64: fp64,
        widthUnits: lineWidthUnits,
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels,
        rounded: lineJointRounded,
        miterLimit: lineMiterLimit,
        dashJustified: lineDashJustified,
        transitions: transitions && {
          getWidth: transitions.getLineWidth,
          getColor: transitions.getLineColor,
          getPath: transitions.getPolygon
        },
        getColor: this._getAccessor(getLineColor),
        getWidth: this._getAccessor(getLineWidth),
        getDashArray: this._getAccessor(getLineDashArray)
      }, this.getSubLayerProps({
        id: 'stroke',
        updateTriggers: {
          getWidth: updateTriggers.getLineWidth,
          getColor: updateTriggers.getLineColor,
          getDashArray: updateTriggers.getLineDashArray
        }
      }), {
        data: paths,
        getPath: function getPath(x) {
          return x.path;
        }
      });
      return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];
    }
  }]);
  return PolygonLayer;
}(_core2.CompositeLayer);

exports.default = PolygonLayer;
PolygonLayer.layerName = 'PolygonLayer';
PolygonLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","../solid-polygon-layer/solid-polygon-layer":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","../path-layer/path-layer":"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","../solid-polygon-layer/polygon":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGeojsonFeatures = getGeojsonFeatures;
exports.separateGeojsonFeatures = separateGeojsonFeatures;
exports.unwrapSourceFeature = unwrapSourceFeature;
exports.unwrapSourceFeatureIndex = unwrapSourceFeatureIndex;
exports.validateGeometry = validateGeometry;

var _core = require("@deck.gl/core");

function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }

  _core.log.assert(geojson.type, 'GeoJSON does not have type');

  switch (geojson.type) {
    case 'Feature':
      return [geojson];

    case 'FeatureCollection':
      _core.log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');

      return geojson.features;

    default:
      return [{
        geometry: geojson
      }];
  }
}

function separateGeojsonFeatures(features) {
  var separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };

  for (var featureIndex = 0; featureIndex < features.length; featureIndex++) {
    var feature = features[featureIndex];

    _core.log.assert(feature && feature.geometry, 'GeoJSON does not have geometry');

    var geometry = feature.geometry;
    var sourceFeature = {
      feature: feature,
      index: featureIndex
    };

    if (geometry.type === 'GeometryCollection') {
      _core.log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');

      var geometries = geometry.geometries;

      for (var i = 0; i < geometries.length; i++) {
        var subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, sourceFeature);
      }
    } else {
      separateGeometry(geometry, separated, sourceFeature);
    }
  }

  return separated;
}

function separateGeometry(geometry, separated, sourceFeature) {
  var type = geometry.type,
      coordinates = geometry.coordinates;
  var pointFeatures = separated.pointFeatures,
      lineFeatures = separated.lineFeatures,
      polygonFeatures = separated.polygonFeatures,
      polygonOutlineFeatures = separated.polygonOutlineFeatures;

  if (!validateGeometry(type, coordinates)) {
    _core.log.warn("".concat(type, " coordinates are malformed"))();

    return;
  }

  switch (type) {
    case 'Point':
      pointFeatures.push({
        geometry: geometry,
        sourceFeature: sourceFeature
      });
      break;

    case 'MultiPoint':
      coordinates.forEach(function (point) {
        pointFeatures.push({
          geometry: {
            type: 'Point',
            coordinates: point
          },
          sourceFeature: sourceFeature
        });
      });
      break;

    case 'LineString':
      lineFeatures.push({
        geometry: geometry,
        sourceFeature: sourceFeature
      });
      break;

    case 'MultiLineString':
      coordinates.forEach(function (path) {
        lineFeatures.push({
          geometry: {
            type: 'LineString',
            coordinates: path
          },
          sourceFeature: sourceFeature
        });
      });
      break;

    case 'Polygon':
      polygonFeatures.push({
        geometry: geometry,
        sourceFeature: sourceFeature
      });
      coordinates.forEach(function (path) {
        polygonOutlineFeatures.push({
          geometry: {
            type: 'LineString',
            coordinates: path
          },
          sourceFeature: sourceFeature
        });
      });
      break;

    case 'MultiPolygon':
      coordinates.forEach(function (polygon) {
        polygonFeatures.push({
          geometry: {
            type: 'Polygon',
            coordinates: polygon
          },
          sourceFeature: sourceFeature
        });
        polygon.forEach(function (path) {
          polygonOutlineFeatures.push({
            geometry: {
              type: 'LineString',
              coordinates: path
            },
            sourceFeature: sourceFeature
          });
        });
      });
      break;

    default:
  }
}

function unwrapSourceFeature(wrappedFeature) {
  return wrappedFeature.sourceFeature.feature;
}

function unwrapSourceFeatureIndex(wrappedFeature) {
  return wrappedFeature.sourceFeature.index;
}

var COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};

function validateGeometry(type, coordinates) {
  var nestLevel = COORDINATE_NEST_LEVEL[type];

  _core.log.assert(nestLevel, "Unknown GeoJSON type ".concat(type));

  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }

  return coordinates && Number.isFinite(coordinates[0]);
}
},{"@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _scatterplotLayer = _interopRequireDefault(require("../scatterplot-layer/scatterplot-layer"));

var _pathLayer = _interopRequireDefault(require("../path-layer/path-layer"));

var _core2 = require("@luma.gl/core");

var _solidPolygonLayer = _interopRequireDefault(require("../solid-polygon-layer/solid-polygon-layer"));

var _geojson = require("./geojson");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultLineColor = [0, 0, 0, 255];
var defaultFillColor = [0, 0, 0, 255];
var defaultMaterial = new _core2.PhongMaterial();
var defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  elevationScale: 1,
  pointRadiusScale: 1,
  pointRadiusMinPixels: 0,
  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,
  lineDashJustified: false,
  fp64: false,
  getLineColor: {
    type: 'accessor',
    value: defaultLineColor
  },
  getFillColor: {
    type: 'accessor',
    value: defaultFillColor
  },
  getRadius: {
    type: 'accessor',
    value: 1
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getLineDashArray: {
    type: 'accessor',
    value: [0, 0]
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: defaultMaterial
};

function getCoordinates(f) {
  return f.geometry.coordinates;
}

function unwrappingAccessor(accessor) {
  if (typeof accessor !== 'function') return accessor;
  return function (feature) {
    return accessor((0, _geojson.unwrapSourceFeature)(feature));
  };
}

var GeoJsonLayer = function (_CompositeLayer) {
  (0, _inherits2.default)(GeoJsonLayer, _CompositeLayer);

  function GeoJsonLayer() {
    (0, _classCallCheck2.default)(this, GeoJsonLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(GeoJsonLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(GeoJsonLayer, [{
    key: "initializeState",
    value: function initializeState() {
      this.state = {
        features: {}
      };
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;

      if (changeFlags.dataChanged) {
        var data = props.data;
        var features = (0, _geojson.getGeojsonFeatures)(data);
        this.state.features = (0, _geojson.separateGeojsonFeatures)(features);
      }
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref2) {
      var info = _ref2.info,
          sourceLayer = _ref2.sourceLayer;
      return Object.assign(info, {
        object: info.object ? (0, _geojson.unwrapSourceFeature)(info.object) : info.object,
        index: info.object ? (0, _geojson.unwrapSourceFeatureIndex)(info.object) : info.index
      });
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var features = this.state.features;
      var pointFeatures = features.pointFeatures,
          lineFeatures = features.lineFeatures,
          polygonFeatures = features.polygonFeatures,
          polygonOutlineFeatures = features.polygonOutlineFeatures;
      var _this$props = this.props,
          stroked = _this$props.stroked,
          filled = _this$props.filled,
          extruded = _this$props.extruded,
          wireframe = _this$props.wireframe,
          material = _this$props.material,
          transitions = _this$props.transitions;
      var _this$props2 = this.props,
          lineWidthUnits = _this$props2.lineWidthUnits,
          lineWidthScale = _this$props2.lineWidthScale,
          lineWidthMinPixels = _this$props2.lineWidthMinPixels,
          lineWidthMaxPixels = _this$props2.lineWidthMaxPixels,
          lineJointRounded = _this$props2.lineJointRounded,
          lineMiterLimit = _this$props2.lineMiterLimit,
          pointRadiusScale = _this$props2.pointRadiusScale,
          pointRadiusMinPixels = _this$props2.pointRadiusMinPixels,
          pointRadiusMaxPixels = _this$props2.pointRadiusMaxPixels,
          elevationScale = _this$props2.elevationScale,
          lineDashJustified = _this$props2.lineDashJustified,
          fp64 = _this$props2.fp64;
      var _this$props3 = this.props,
          getLineColor = _this$props3.getLineColor,
          getFillColor = _this$props3.getFillColor,
          getRadius = _this$props3.getRadius,
          getLineWidth = _this$props3.getLineWidth,
          getLineDashArray = _this$props3.getLineDashArray,
          getElevation = _this$props3.getElevation,
          updateTriggers = _this$props3.updateTriggers;
      var PolygonFillLayer = this.getSubLayerClass('polygons-fill', _solidPolygonLayer.default);
      var PolygonStrokeLayer = this.getSubLayerClass('polygons-stroke', _pathLayer.default);
      var LineStringsLayer = this.getSubLayerClass('line-strings', _pathLayer.default);
      var PointsLayer = this.getSubLayerClass('points', _scatterplotLayer.default);
      var polygonFillLayer = this.shouldRenderSubLayer('polygons-fill', polygonFeatures) && new PolygonFillLayer({
        fp64: fp64,
        extruded: extruded,
        elevationScale: elevationScale,
        filled: filled,
        wireframe: wireframe,
        material: material,
        getElevation: unwrappingAccessor(getElevation),
        getFillColor: unwrappingAccessor(getFillColor),
        getLineColor: unwrappingAccessor(getLineColor),
        transitions: transitions && {
          getPolygon: transitions.geometry,
          getElevation: transitions.getElevation,
          getFillColor: transitions.getFillColor,
          getLineColor: transitions.getLineColor
        }
      }, this.getSubLayerProps({
        id: 'polygons-fill',
        updateTriggers: {
          getElevation: updateTriggers.getElevation,
          getFillColor: updateTriggers.getFillColor,
          getLineColor: updateTriggers.getLineColor
        }
      }), {
        data: polygonFeatures,
        getPolygon: getCoordinates
      });
      var polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('polygons-stroke', polygonOutlineFeatures) && new PolygonStrokeLayer({
        fp64: fp64,
        widthUnits: lineWidthUnits,
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels,
        rounded: lineJointRounded,
        miterLimit: lineMiterLimit,
        dashJustified: lineDashJustified,
        getColor: unwrappingAccessor(getLineColor),
        getWidth: unwrappingAccessor(getLineWidth),
        getDashArray: unwrappingAccessor(getLineDashArray),
        transitions: transitions && {
          getPath: transitions.geometry,
          getColor: transitions.getLineColor,
          getWidth: transitions.getLineWidth
        }
      }, this.getSubLayerProps({
        id: 'polygons-stroke',
        updateTriggers: {
          getColor: updateTriggers.getLineColor,
          getWidth: updateTriggers.getLineWidth,
          getDashArray: updateTriggers.getLineDashArray
        }
      }), {
        data: polygonOutlineFeatures,
        getPath: getCoordinates
      });
      var pathLayer = this.shouldRenderSubLayer('linestrings', lineFeatures) && new LineStringsLayer({
        fp64: fp64,
        widthUnits: lineWidthUnits,
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels,
        rounded: lineJointRounded,
        miterLimit: lineMiterLimit,
        dashJustified: lineDashJustified,
        getColor: unwrappingAccessor(getLineColor),
        getWidth: unwrappingAccessor(getLineWidth),
        getDashArray: unwrappingAccessor(getLineDashArray),
        transitions: transitions && {
          getPath: transitions.geometry,
          getColor: transitions.getLineColor,
          getWidth: transitions.getLineWidth
        }
      }, this.getSubLayerProps({
        id: 'line-strings',
        updateTriggers: {
          getColor: updateTriggers.getLineColor,
          getWidth: updateTriggers.getLineWidth,
          getDashArray: updateTriggers.getLineDashArray
        }
      }), {
        data: lineFeatures,
        getPath: getCoordinates
      });
      var pointLayer = this.shouldRenderSubLayer('points', pointFeatures) && new PointsLayer({
        fp64: fp64,
        stroked: stroked,
        filled: filled,
        radiusScale: pointRadiusScale,
        radiusMinPixels: pointRadiusMinPixels,
        radiusMaxPixels: pointRadiusMaxPixels,
        lineWidthUnits: lineWidthUnits,
        lineWidthScale: lineWidthScale,
        lineWidthMinPixels: lineWidthMinPixels,
        lineWidthMaxPixels: lineWidthMaxPixels,
        getFillColor: unwrappingAccessor(getFillColor),
        getLineColor: unwrappingAccessor(getLineColor),
        getRadius: unwrappingAccessor(getRadius),
        getLineWidth: unwrappingAccessor(getLineWidth),
        transitions: transitions && {
          getPosition: transitions.geometry,
          getFillColor: transitions.getFillColor,
          getLineColor: transitions.getLineColor,
          getRadius: transitions.getRadius,
          getLineWidth: transitions.getLineWidth
        }
      }, this.getSubLayerProps({
        id: 'points',
        updateTriggers: {
          getFillColor: updateTriggers.getFillColor,
          getLineColor: updateTriggers.getLineColor,
          getRadius: updateTriggers.getRadius,
          getLineWidth: updateTriggers.getLineWidth
        }
      }), {
        data: pointFeatures,
        getPosition: getCoordinates
      });
      return [!extruded && polygonFillLayer, polygonLineLayer, pathLayer, pointLayer, extruded && polygonFillLayer];
    }
  }]);
  return GeoJsonLayer;
}(_core.CompositeLayer);

exports.default = GeoJsonLayer;
GeoJsonLayer.layerName = 'GeoJsonLayer';
GeoJsonLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","../scatterplot-layer/scatterplot-layer":"../../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","../path-layer/path-layer":"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","../solid-polygon-layer/solid-polygon-layer":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","./geojson":"../../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME multi-icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec2 iconsTextureDim;\nuniform float gamma;\nuniform float opacity;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying float vGamma;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale),\n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  \n  if (billboard)  {\n    pixelOffset.y *= -1.0;\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.0)); \n    gl_Position.xy += project_pixel_size_to_clipspace(pixelOffset);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset_common); \n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  vGamma = gamma / (sizeScale * iconSize.y);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform sampler2D iconsTexture;\nuniform float buffer;\nuniform bool sdf;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying float vGamma;\n\nconst float MIN_ALPHA = 0.05;\n\nvoid main(void) {\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  \n  float alpha = texColor.a;\n  if (sdf) {\n    float distance = texture2D(iconsTexture, vTextureCoords).a;\n    alpha = smoothstep(buffer - vGamma, buffer + vGamma, distance);\n  }\n  float a = alpha * vColor.a;\n\n  if (a < MIN_ALPHA) {\n    discard;\n  }\n\n  gl_FragColor = vec4(vColor.rgb, a);\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";
exports.default = _default;
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _iconLayer = _interopRequireDefault(require("../../icon-layer/icon-layer"));

var _multiIconLayerVertex = _interopRequireDefault(require("./multi-icon-layer-vertex.glsl"));

var _multiIconLayerFragment = _interopRequireDefault(require("./multi-icon-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_GAMMA = 0.2;
var DEFAULT_BUFFER = 192.0 / 256;
var defaultProps = {
  getShiftInQueue: {
    type: 'accessor',
    value: function value(x) {
      return x.shift || 0;
    }
  },
  getLengthOfQueue: {
    type: 'accessor',
    value: function value(x) {
      return x.len || 1;
    }
  },
  getAnchorX: {
    type: 'accessor',
    value: function value(x) {
      return x.anchorX || 0;
    }
  },
  getAnchorY: {
    type: 'accessor',
    value: function value(x) {
      return x.anchorY || 0;
    }
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  getPickingIndex: {
    type: 'accessor',
    value: function value(x) {
      return x.objectIndex;
    }
  }
};

var MultiIconLayer = function (_IconLayer) {
  (0, _inherits2.default)(MultiIconLayer, _IconLayer);

  function MultiIconLayer() {
    (0, _classCallCheck2.default)(this, MultiIconLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(MultiIconLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(MultiIconLayer, [{
    key: "getShaders",
    value: function getShaders() {
      return Object.assign({}, (0, _get2.default)((0, _getPrototypeOf2.default)(MultiIconLayer.prototype), "getShaders", this).call(this), {
        vs: _multiIconLayerVertex.default,
        fs: _multiIconLayerFragment.default
      });
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(MultiIconLayer.prototype), "initializeState", this).call(this);
      var attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePixelOffset: {
          size: 2,
          transition: true,
          accessor: 'getPixelOffset'
        }
      });
    }
  }, {
    key: "updateState",
    value: function updateState(updateParams) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(MultiIconLayer.prototype), "updateState", this).call(this, updateParams);
      var changeFlags = updateParams.changeFlags;

      if (changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.getAnchorX || changeFlags.updateTriggersChanged.getAnchorY)) {
        this.getAttributeManager().invalidate('instanceOffsets');
      }
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var uniforms = _ref.uniforms;
      var sdf = this.props.sdf;
      (0, _get2.default)((0, _getPrototypeOf2.default)(MultiIconLayer.prototype), "draw", this).call(this, {
        uniforms: Object.assign({}, uniforms, {
          buffer: DEFAULT_BUFFER,
          gamma: DEFAULT_GAMMA,
          sdf: Boolean(sdf)
        })
      });
    }
  }, {
    key: "calculateInstanceOffsets",
    value: function calculateInstanceOffsets(attribute, _ref2) {
      var startRow = _ref2.startRow,
          endRow = _ref2.endRow;
      var _this$props = this.props,
          data = _this$props.data,
          iconMapping = _this$props.iconMapping,
          getIcon = _this$props.getIcon,
          getAnchorX = _this$props.getAnchorX,
          getAnchorY = _this$props.getAnchorY,
          getLengthOfQueue = _this$props.getLengthOfQueue,
          getShiftInQueue = _this$props.getShiftInQueue;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;

      var _createIterable = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable.iterable;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          var icon = getIcon(object);
          var rect = iconMapping[icon] || {};
          var len = getLengthOfQueue(object);
          var shiftX = getShiftInQueue(object);
          value[i++] = (getAnchorX(object) - 1) * len / 2 + rect.width / 2 + shiftX || 0;
          value[i++] = rect.height / 2 * getAnchorY(object) || 0;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "calculateInstancePickingColors",
    value: function calculateInstancePickingColors(attribute, _ref3) {
      var startRow = _ref3.startRow,
          endRow = _ref3.endRow;
      var _this$props2 = this.props,
          data = _this$props2.data,
          getPickingIndex = _this$props2.getPickingIndex;
      var value = attribute.value,
          size = attribute.size;
      var i = startRow * size;
      var pickingColor = [];

      var _createIterable2 = (0, _core.createIterable)(data, startRow, endRow),
          iterable = _createIterable2.iterable;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var point = _step2.value;
          var index = getPickingIndex(point);
          this.encodePickingColor(index, pickingColor);
          value[i++] = pickingColor[0];
          value[i++] = pickingColor[1];
          value[i++] = pickingColor[2];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }]);
  return MultiIconLayer;
}(_iconLayer.default);

exports.default = MultiIconLayer;
MultiIconLayer.layerName = 'MultiIconLayer';
MultiIconLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","../../icon-layer/icon-layer":"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","./multi-icon-layer-vertex.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-vertex.glsl.js","./multi-icon-layer-fragment.glsl":"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js"}],"../../../node_modules/@mapbox/tiny-sdf/index.js":[function(require,module,exports) {
'use strict';

module.exports = TinySDF;
module.exports.default = TinySDF;

var INF = 1e20;

function TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
    this.fontSize = fontSize || 24;
    this.buffer = buffer === undefined ? 3 : buffer;
    this.cutoff = cutoff || 0.25;
    this.fontFamily = fontFamily || 'sans-serif';
    this.fontWeight = fontWeight || 'normal';
    this.radius = radius || 8;
    var size = this.size = this.fontSize + this.buffer * 2;

    this.canvas = document.createElement('canvas');
    this.canvas.width = this.canvas.height = size;

    this.ctx = this.canvas.getContext('2d');
    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;
    this.ctx.textBaseline = 'middle';
    this.ctx.fillStyle = 'black';

    // temporary arrays for the distance transform
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.d = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Int16Array(size);

    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852
    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));
}

TinySDF.prototype.draw = function (char) {
    this.ctx.clearRect(0, 0, this.size, this.size);
    this.ctx.fillText(char, this.buffer, this.middle);

    var imgData = this.ctx.getImageData(0, 0, this.size, this.size);
    var alphaChannel = new Uint8ClampedArray(this.size * this.size);

    for (var i = 0; i < this.size * this.size; i++) {
        var a = imgData.data[i * 4 + 3] / 255; // alpha value
        this.gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
        this.gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
    }

    edt(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z);
    edt(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z);

    for (i = 0; i < this.size * this.size; i++) {
        var d = this.gridOuter[i] - this.gridInner[i];
        alphaChannel[i] = Math.max(0, Math.min(255, Math.round(255 - 255 * (d / this.radius + this.cutoff))));
    }

    return alphaChannel;
};

// 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
function edt(data, width, height, f, d, v, z) {
    for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
            f[y] = data[y * width + x];
        }
        edt1d(f, d, v, z, height);
        for (y = 0; y < height; y++) {
            data[y * width + x] = d[y];
        }
    }
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            f[x] = data[y * width + x];
        }
        edt1d(f, d, v, z, width);
        for (x = 0; x < width; x++) {
            data[y * width + x] = Math.sqrt(d[x]);
        }
    }
}

// 1D squared distance transform
function edt1d(f, d, v, z, n) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = +INF;

    for (var q = 1, k = 0; q < n; q++) {
        var s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        while (s <= z[k]) {
            k--;
            s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = +INF;
    }

    for (q = 0, k = 0; q < n; q++) {
        while (z[k + 1] < q) k++;
        d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
    }
}

},{}],"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextPowOfTwo = nextPowOfTwo;
exports.buildMapping = buildMapping;

function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}

function buildMapping(_ref) {
  var characterSet = _ref.characterSet,
      getFontWidth = _ref.getFontWidth,
      fontHeight = _ref.fontHeight,
      buffer = _ref.buffer,
      maxCanvasWidth = _ref.maxCanvasWidth,
      _ref$mapping = _ref.mapping,
      mapping = _ref$mapping === void 0 ? {} : _ref$mapping,
      _ref$xOffset = _ref.xOffset,
      xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset,
      _ref$yOffset = _ref.yOffset,
      yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset;
  var row = 0;
  var x = xOffset;
  Array.from(characterSet).forEach(function (char, i) {
    if (!mapping[char]) {
      var width = getFontWidth(char, i);

      if (x + width + buffer * 2 > maxCanvasWidth) {
        x = 0;
        row++;
      }

      mapping[char] = {
        x: x + buffer,
        y: yOffset + row * (fontHeight + buffer * 2) + buffer,
        width: width,
        height: fontHeight,
        mask: true
      };
      x += width + buffer * 2;
    }
  });
  var rowHeight = fontHeight + buffer * 2;
  return {
    mapping: mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
  };
}
},{}],"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LRUCache = function () {
  function LRUCache() {
    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
    (0, _classCallCheck2.default)(this, LRUCache);
    this.limit = limit;
    this.clear();
  }

  (0, _createClass2.default)(LRUCache, [{
    key: "clear",
    value: function clear() {
      this._cache = {};
      this._order = [];
    }
  }, {
    key: "get",
    value: function get(key) {
      var value = this._cache[key];

      if (value) {
        this._deleteOrder(key);

        this._appendOrder(key);
      }

      return value;
    }
  }, {
    key: "set",
    value: function set(key, value) {
      if (!this._cache[key]) {
        if (Object.keys(this._cache).length === this.limit) {
          this.delete(this._order[0]);
        }

        this._cache[key] = value;

        this._appendOrder(key);
      } else {
        this.delete(key);
        this._cache[key] = value;

        this._appendOrder(key);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var value = this._cache[key];

      if (value) {
        this._deleteCache(key);

        this._deleteOrder(key);
      }
    }
  }, {
    key: "_deleteCache",
    value: function _deleteCache(key) {
      delete this._cache[key];
    }
  }, {
    key: "_deleteOrder",
    value: function _deleteOrder(key) {
      var index = this._order.findIndex(function (o) {
        return o === key;
      });

      if (index >= 0) {
        this._order.splice(index, 1);
      }
    }
  }, {
    key: "_appendOrder",
    value: function _appendOrder(key) {
      this._order.push(key);
    }
  }]);
  return LRUCache;
}();

exports.default = LRUCache;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_RADIUS = exports.DEFAULT_CUTOFF = exports.DEFAULT_BUFFER = exports.DEFAULT_FONT_SIZE = exports.DEFAULT_FONT_WEIGHT = exports.DEFAULT_FONT_FAMILY = exports.DEFAULT_CHAR_SET = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _core = require("@luma.gl/core");

var _tinySdf = _interopRequireDefault(require("@mapbox/tiny-sdf"));

var _fontAtlasUtils = require("./font-atlas-utils");

var _lruCache = _interopRequireDefault(require("./lru-cache"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDefaultCharacterSet() {
  var charSet = [];

  for (var i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }

  return charSet;
}

var DEFAULT_CHAR_SET = getDefaultCharacterSet();
exports.DEFAULT_CHAR_SET = DEFAULT_CHAR_SET;
var DEFAULT_FONT_FAMILY = 'Monaco, monospace';
exports.DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY;
var DEFAULT_FONT_WEIGHT = 'normal';
exports.DEFAULT_FONT_WEIGHT = DEFAULT_FONT_WEIGHT;
var DEFAULT_FONT_SIZE = 64;
exports.DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE;
var DEFAULT_BUFFER = 2;
exports.DEFAULT_BUFFER = DEFAULT_BUFFER;
var DEFAULT_CUTOFF = 0.25;
exports.DEFAULT_CUTOFF = DEFAULT_CUTOFF;
var DEFAULT_RADIUS = 3;
exports.DEFAULT_RADIUS = DEFAULT_RADIUS;
var GL_TEXTURE_WRAP_S = 0x2802;
var GL_TEXTURE_WRAP_T = 0x2803;
var GL_CLAMP_TO_EDGE = 0x812f;
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 0.9;
var HEIGHT_SCALE = 1.2;
var CACHE_LIMIT = 3;
var cache = new _lruCache.default(CACHE_LIMIT);
var VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];

function getNewChars(key, characterSet) {
  var cachedFontAtlas = cache.get(key);

  if (!cachedFontAtlas) {
    return characterSet;
  }

  var newChars = [];
  var cachedMapping = cachedFontAtlas.mapping;
  var cachedCharSet = Object.keys(cachedMapping);
  cachedCharSet = new Set(cachedCharSet);
  var charSet = characterSet;

  if (charSet instanceof Array) {
    charSet = new Set(charSet);
  }

  charSet.forEach(function (char) {
    if (!cachedCharSet.has(char)) {
      newChars.push(char);
    }
  });
  return newChars;
}

function populateAlphaChannel(alphaChannel, imageData) {
  for (var i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}

function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = '#000';
  ctx.textBaseline = 'baseline';
  ctx.textAlign = 'left';
}

var FontAtlasManager = function () {
  function FontAtlasManager(gl) {
    (0, _classCallCheck2.default)(this, FontAtlasManager);
    this.gl = gl;
    this.props = {
      fontFamily: DEFAULT_FONT_FAMILY,
      fontWeight: DEFAULT_FONT_WEIGHT,
      characterSet: DEFAULT_CHAR_SET,
      fontSize: DEFAULT_FONT_SIZE,
      buffer: DEFAULT_BUFFER,
      sdf: false,
      cutoff: DEFAULT_CUTOFF,
      radius: DEFAULT_RADIUS
    };
    this._key = null;
    this._texture = new _core.Texture2D(this.gl);
  }

  (0, _createClass2.default)(FontAtlasManager, [{
    key: "finalize",
    value: function finalize() {
      this._texture.delete();
    }
  }, {
    key: "setProps",
    value: function setProps() {
      var _this = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      VALID_PROPS.forEach(function (prop) {
        if (prop in props) {
          _this.props[prop] = props[prop];
        }
      });
      var oldKey = this._key;
      this._key = this._getKey();
      var charSet = getNewChars(this._key, this.props.characterSet);
      var cachedFontAtlas = cache.get(this._key);

      if (cachedFontAtlas && charSet.length === 0) {
        if (this._key !== oldKey) {
          this._updateTexture(cachedFontAtlas);
        }

        return;
      }

      var fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);

      this._updateTexture(fontAtlas);

      cache.set(this._key, fontAtlas);
    }
  }, {
    key: "_updateTexture",
    value: function _updateTexture(_ref) {
      var _parameters;

      var canvas = _ref.data,
          width = _ref.width,
          height = _ref.height;

      if (this._texture.width !== width || this._texture.height !== height) {
        this._texture.resize({
          width: width,
          height: height
        });
      }

      this._texture.setImageData({
        data: canvas,
        width: width,
        height: height,
        parameters: (_parameters = {}, (0, _defineProperty2.default)(_parameters, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE), (0, _defineProperty2.default)(_parameters, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE), (0, _defineProperty2.default)(_parameters, 37440, true), _parameters)
      });

      this._texture.generateMipmap();
    }
  }, {
    key: "_generateFontAtlas",
    value: function _generateFontAtlas(key, characterSet, cachedFontAtlas) {
      var _this$props = this.props,
          fontFamily = _this$props.fontFamily,
          fontWeight = _this$props.fontWeight,
          fontSize = _this$props.fontSize,
          buffer = _this$props.buffer,
          sdf = _this$props.sdf,
          radius = _this$props.radius,
          cutoff = _this$props.cutoff;
      var canvas = cachedFontAtlas && cachedFontAtlas.data;

      if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = MAX_CANVAS_WIDTH;
      }

      var ctx = canvas.getContext('2d');
      setTextStyle(ctx, fontFamily, fontSize, fontWeight);

      var _buildMapping = (0, _fontAtlasUtils.buildMapping)(Object.assign({
        getFontWidth: function getFontWidth(char) {
          return ctx.measureText(char).width;
        },
        fontHeight: fontSize * HEIGHT_SCALE,
        buffer: buffer,
        characterSet: characterSet,
        maxCanvasWidth: MAX_CANVAS_WIDTH
      }, cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      })),
          mapping = _buildMapping.mapping,
          canvasHeight = _buildMapping.canvasHeight,
          xOffset = _buildMapping.xOffset,
          yOffset = _buildMapping.yOffset;

      if (canvas.height !== canvasHeight) {
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        canvas.height = canvasHeight;
        ctx.putImageData(imageData, 0, 0);
      }

      setTextStyle(ctx, fontFamily, fontSize, fontWeight);

      if (sdf) {
        var tinySDF = new _tinySdf.default(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);

        var _imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = characterSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var char = _step.value;
            populateAlphaChannel(tinySDF.draw(char), _imageData);
            ctx.putImageData(_imageData, mapping[char].x - buffer, mapping[char].y - buffer);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = characterSet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _char = _step2.value;
            ctx.fillText(_char, mapping[_char].x, mapping[_char].y + fontSize * BASELINE_SCALE);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return {
        xOffset: xOffset,
        yOffset: yOffset,
        mapping: mapping,
        data: canvas,
        width: canvas.width,
        height: canvas.height
      };
    }
  }, {
    key: "_getKey",
    value: function _getKey() {
      var _this$props2 = this.props,
          gl = _this$props2.gl,
          fontFamily = _this$props2.fontFamily,
          fontWeight = _this$props2.fontWeight,
          fontSize = _this$props2.fontSize,
          buffer = _this$props2.buffer,
          sdf = _this$props2.sdf,
          radius = _this$props2.radius,
          cutoff = _this$props2.cutoff;

      if (sdf) {
        return "".concat(gl, " ").concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
      }

      return "".concat(gl, " ").concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
    }
  }, {
    key: "texture",
    get: function get() {
      return this._texture;
    }
  }, {
    key: "mapping",
    get: function get() {
      var data = cache.get(this._key);
      return data && data.mapping;
    }
  }, {
    key: "scale",
    get: function get() {
      return HEIGHT_SCALE;
    }
  }]);
  return FontAtlasManager;
}();

exports.default = FontAtlasManager;
},{"@babel/runtime/helpers/esm/defineProperty":"../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@luma.gl/core":"../../../node_modules/@luma.gl/core/dist/esm/index.js","@mapbox/tiny-sdf":"../../../node_modules/@mapbox/tiny-sdf/index.js","./font-atlas-utils":"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-utils.js","./lru-cache":"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/inherits"));

var _core = require("@deck.gl/core");

var _multiIconLayer = _interopRequireDefault(require("./multi-icon-layer/multi-icon-layer"));

var _fontAtlasManager = _interopRequireWildcard(require("./font-atlas-manager"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_FONT_SETTINGS = {
  fontSize: _fontAtlasManager.DEFAULT_FONT_SIZE,
  buffer: _fontAtlasManager.DEFAULT_BUFFER,
  sdf: false,
  radius: _fontAtlasManager.DEFAULT_RADIUS,
  cutoff: _fontAtlasManager.DEFAULT_CUTOFF
};
var TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
var ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
var DEFAULT_COLOR = [0, 0, 0, 255];
var MISSING_CHAR_WIDTH = 32;
var FONT_SETTINGS_PROPS = ['fontSize', 'buffer', 'sdf', 'radius', 'cutoff'];
var defaultProps = {
  fp64: false,
  billboard: true,
  sizeScale: 1,
  sizeUnits: 'pixels',
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  characterSet: _fontAtlasManager.DEFAULT_CHAR_SET,
  fontFamily: _fontAtlasManager.DEFAULT_FONT_FAMILY,
  fontWeight: _fontAtlasManager.DEFAULT_FONT_WEIGHT,
  fontSettings: {},
  getText: {
    type: 'accessor',
    value: function value(x) {
      return x.text;
    }
  },
  getPosition: {
    type: 'accessor',
    value: function value(x) {
      return x.position;
    }
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getSize: {
    type: 'accessor',
    value: 32
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getTextAnchor: {
    type: 'accessor',
    value: 'middle'
  },
  getAlignmentBaseline: {
    type: 'accessor',
    value: 'center'
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  }
};

var TextLayer = function (_CompositeLayer) {
  (0, _inherits2.default)(TextLayer, _CompositeLayer);

  function TextLayer() {
    (0, _classCallCheck2.default)(this, TextLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(TextLayer).apply(this, arguments));
  }

  (0, _createClass2.default)(TextLayer, [{
    key: "initializeState",
    value: function initializeState() {
      this.state = {
        fontAtlasManager: new _fontAtlasManager.default(this.context.gl)
      };
    }
  }, {
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps,
          changeFlags = _ref.changeFlags;
      var fontChanged = this.fontChanged(oldProps, props);

      if (fontChanged) {
        this.updateFontAtlas({
          oldProps: oldProps,
          props: props
        });
      }

      if (changeFlags.dataChanged || fontChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText)) {
        this.transformStringToLetters();
      }
    }
  }, {
    key: "finalizeState",
    value: function finalizeState() {
      (0, _get2.default)((0, _getPrototypeOf2.default)(TextLayer.prototype), "finalizeState", this).call(this);
      this.state.fontAtlasManager.finalize();
    }
  }, {
    key: "updateFontAtlas",
    value: function updateFontAtlas(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props;
      var characterSet = props.characterSet,
          fontSettings = props.fontSettings,
          fontFamily = props.fontFamily,
          fontWeight = props.fontWeight;
      var fontAtlasManager = this.state.fontAtlasManager;
      fontAtlasManager.setProps(Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {
        characterSet: characterSet,
        fontFamily: fontFamily,
        fontWeight: fontWeight
      }));
      var scale = fontAtlasManager.scale,
          texture = fontAtlasManager.texture,
          mapping = fontAtlasManager.mapping;
      this.setState({
        scale: scale,
        iconAtlas: texture,
        iconMapping: mapping
      });
      this.setNeedsRedraw(true);
    }
  }, {
    key: "fontChanged",
    value: function fontChanged(oldProps, props) {
      if (oldProps.fontFamily !== props.fontFamily || oldProps.characterSet !== props.characterSet || oldProps.fontWeight !== props.fontWeight) {
        return true;
      }

      if (oldProps.fontSettings === props.fontSettings) {
        return false;
      }

      var oldFontSettings = oldProps.fontSettings || {};
      var fontSettings = props.fontSettings || {};
      return FONT_SETTINGS_PROPS.some(function (prop) {
        return oldFontSettings[prop] !== fontSettings[prop];
      });
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref3) {
      var info = _ref3.info;
      return Object.assign(info, {
        object: info.index >= 0 ? this.props.data[info.index] : null
      });
    }
  }, {
    key: "transformStringToLetters",
    value: function transformStringToLetters() {
      var _this$props = this.props,
          data = _this$props.data,
          getText = _this$props.getText;
      var iconMapping = this.state.iconMapping;
      var transformedData = [];

      var _createIterable = (0, _core.createIterable)(data),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var object = _step.value;
          objectInfo.index++;
          var text = getText(object, objectInfo);

          if (text) {
            var letters = Array.from(text);
            var offsets = [0];
            var offsetLeft = 0;
            letters.forEach(function (letter, i) {
              var datum = {
                text: letter,
                index: i,
                offsets: offsets,
                len: text.length,
                object: object,
                objectIndex: objectInfo.index
              };
              var frame = iconMapping[letter];

              if (frame) {
                offsetLeft += frame.width;
              } else {
                _core.log.warn("Missing character: ".concat(letter))();

                offsetLeft += MISSING_CHAR_WIDTH;
              }

              offsets.push(offsetLeft);
              transformedData.push(datum);
            });
          }
        };

        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.setState({
        data: transformedData
      });
    }
  }, {
    key: "getLetterOffset",
    value: function getLetterOffset(datum) {
      return datum.offsets[datum.index];
    }
  }, {
    key: "getTextLength",
    value: function getTextLength(datum) {
      return datum.offsets[datum.offsets.length - 1];
    }
  }, {
    key: "_getAccessor",
    value: function _getAccessor(accessor) {
      if (typeof accessor === 'function') {
        return function (x) {
          return accessor(x.object);
        };
      }

      return accessor;
    }
  }, {
    key: "getAnchorXFromTextAnchor",
    value: function getAnchorXFromTextAnchor(getTextAnchor) {
      return function (x) {
        var textAnchor = typeof getTextAnchor === 'function' ? getTextAnchor(x.object) : getTextAnchor;

        if (!TEXT_ANCHOR.hasOwnProperty(textAnchor)) {
          throw new Error("Invalid text anchor parameter: ".concat(textAnchor));
        }

        return TEXT_ANCHOR[textAnchor];
      };
    }
  }, {
    key: "getAnchorYFromAlignmentBaseline",
    value: function getAnchorYFromAlignmentBaseline(getAlignmentBaseline) {
      return function (x) {
        var alignmentBaseline = typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(x.object) : getAlignmentBaseline;

        if (!ALIGNMENT_BASELINE.hasOwnProperty(alignmentBaseline)) {
          throw new Error("Invalid alignment baseline parameter: ".concat(alignmentBaseline));
        }

        return ALIGNMENT_BASELINE[alignmentBaseline];
      };
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var _this = this;

      var _this$state = this.state,
          data = _this$state.data,
          scale = _this$state.scale,
          iconAtlas = _this$state.iconAtlas,
          iconMapping = _this$state.iconMapping;
      var _this$props2 = this.props,
          _getPosition = _this$props2.getPosition,
          getColor = _this$props2.getColor,
          getSize = _this$props2.getSize,
          getAngle = _this$props2.getAngle,
          getTextAnchor = _this$props2.getTextAnchor,
          getAlignmentBaseline = _this$props2.getAlignmentBaseline,
          getPixelOffset = _this$props2.getPixelOffset,
          fp64 = _this$props2.fp64,
          billboard = _this$props2.billboard,
          sdf = _this$props2.sdf,
          sizeScale = _this$props2.sizeScale,
          sizeUnits = _this$props2.sizeUnits,
          sizeMinPixels = _this$props2.sizeMinPixels,
          sizeMaxPixels = _this$props2.sizeMaxPixels,
          transitions = _this$props2.transitions,
          updateTriggers = _this$props2.updateTriggers;
      var SubLayerClass = this.getSubLayerClass('characters', _multiIconLayer.default);
      return new SubLayerClass({
        sdf: sdf,
        iconAtlas: iconAtlas,
        iconMapping: iconMapping,
        getPosition: function getPosition(d) {
          return _getPosition(d.object);
        },
        getColor: this._getAccessor(getColor),
        getSize: this._getAccessor(getSize),
        getAngle: this._getAccessor(getAngle),
        getAnchorX: this.getAnchorXFromTextAnchor(getTextAnchor),
        getAnchorY: this.getAnchorYFromAlignmentBaseline(getAlignmentBaseline),
        getPixelOffset: this._getAccessor(getPixelOffset),
        fp64: fp64,
        billboard: billboard,
        sizeScale: sizeScale * scale,
        sizeUnits: sizeUnits,
        sizeMinPixels: sizeMinPixels * scale,
        sizeMaxPixels: sizeMaxPixels * scale,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: updateTriggers.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: 'characters',
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getAnchorX: updateTriggers.getTextAnchor,
          getAnchorY: updateTriggers.getAlignmentBaseline
        }
      }), {
        data: data,
        getIcon: function getIcon(d) {
          return d.text;
        },
        getShiftInQueue: function getShiftInQueue(d) {
          return _this.getLetterOffset(d);
        },
        getLengthOfQueue: function getLengthOfQueue(d) {
          return _this.getTextLength(d);
        }
      });
    }
  }]);
  return TextLayer;
}(_core.CompositeLayer);

exports.default = TextLayer;
TextLayer.layerName = 'TextLayer';
TextLayer.defaultProps = defaultProps;
},{"@babel/runtime/helpers/esm/classCallCheck":"../../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","@babel/runtime/helpers/esm/createClass":"../../../node_modules/@babel/runtime/helpers/esm/createClass.js","@babel/runtime/helpers/esm/possibleConstructorReturn":"../../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","@babel/runtime/helpers/esm/getPrototypeOf":"../../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","@babel/runtime/helpers/esm/get":"../../../node_modules/@babel/runtime/helpers/esm/get.js","@babel/runtime/helpers/esm/inherits":"../../../node_modules/@babel/runtime/helpers/esm/inherits.js","@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","./multi-icon-layer/multi-icon-layer":"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js","./font-atlas-manager":"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js"}],"../../../node_modules/@deck.gl/layers/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ArcLayer", {
  enumerable: true,
  get: function () {
    return _arcLayer.default;
  }
});
Object.defineProperty(exports, "BitmapLayer", {
  enumerable: true,
  get: function () {
    return _bitmapLayer.default;
  }
});
Object.defineProperty(exports, "IconLayer", {
  enumerable: true,
  get: function () {
    return _iconLayer.default;
  }
});
Object.defineProperty(exports, "LineLayer", {
  enumerable: true,
  get: function () {
    return _lineLayer.default;
  }
});
Object.defineProperty(exports, "PointCloudLayer", {
  enumerable: true,
  get: function () {
    return _pointCloudLayer.default;
  }
});
Object.defineProperty(exports, "ScatterplotLayer", {
  enumerable: true,
  get: function () {
    return _scatterplotLayer.default;
  }
});
Object.defineProperty(exports, "ColumnLayer", {
  enumerable: true,
  get: function () {
    return _columnLayer.default;
  }
});
Object.defineProperty(exports, "GridCellLayer", {
  enumerable: true,
  get: function () {
    return _gridCellLayer.default;
  }
});
Object.defineProperty(exports, "PathLayer", {
  enumerable: true,
  get: function () {
    return _pathLayer.default;
  }
});
Object.defineProperty(exports, "PolygonLayer", {
  enumerable: true,
  get: function () {
    return _polygonLayer.default;
  }
});
Object.defineProperty(exports, "GeoJsonLayer", {
  enumerable: true,
  get: function () {
    return _geojsonLayer.default;
  }
});
Object.defineProperty(exports, "TextLayer", {
  enumerable: true,
  get: function () {
    return _textLayer.default;
  }
});
Object.defineProperty(exports, "SolidPolygonLayer", {
  enumerable: true,
  get: function () {
    return _solidPolygonLayer.default;
  }
});
Object.defineProperty(exports, "_MultiIconLayer", {
  enumerable: true,
  get: function () {
    return _multiIconLayer.default;
  }
});

var _arcLayer = _interopRequireDefault(require("./arc-layer/arc-layer"));

var _bitmapLayer = _interopRequireDefault(require("./bitmap-layer/bitmap-layer"));

var _iconLayer = _interopRequireDefault(require("./icon-layer/icon-layer"));

var _lineLayer = _interopRequireDefault(require("./line-layer/line-layer"));

var _pointCloudLayer = _interopRequireDefault(require("./point-cloud-layer/point-cloud-layer"));

var _scatterplotLayer = _interopRequireDefault(require("./scatterplot-layer/scatterplot-layer"));

var _columnLayer = _interopRequireDefault(require("./column-layer/column-layer"));

var _gridCellLayer = _interopRequireDefault(require("./column-layer/grid-cell-layer"));

var _pathLayer = _interopRequireDefault(require("./path-layer/path-layer"));

var _polygonLayer = _interopRequireDefault(require("./polygon-layer/polygon-layer"));

var _geojsonLayer = _interopRequireDefault(require("./geojson-layer/geojson-layer"));

var _textLayer = _interopRequireDefault(require("./text-layer/text-layer"));

var _solidPolygonLayer = _interopRequireDefault(require("./solid-polygon-layer/solid-polygon-layer"));

var _multiIconLayer = _interopRequireDefault(require("./text-layer/multi-icon-layer/multi-icon-layer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./arc-layer/arc-layer":"../../../node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js","./bitmap-layer/bitmap-layer":"../../../node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js","./icon-layer/icon-layer":"../../../node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","./line-layer/line-layer":"../../../node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js","./point-cloud-layer/point-cloud-layer":"../../../node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js","./scatterplot-layer/scatterplot-layer":"../../../node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","./column-layer/column-layer":"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js","./column-layer/grid-cell-layer":"../../../node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js","./path-layer/path-layer":"../../../node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","./polygon-layer/polygon-layer":"../../../node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js","./geojson-layer/geojson-layer":"../../../node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js","./text-layer/text-layer":"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js","./solid-polygon-layer/solid-polygon-layer":"../../../node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","./text-layer/multi-icon-layer/multi-icon-layer":"../../../node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js"}],"map.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var core_1 = require("@deck.gl/core");

var layers_1 = require("@deck.gl/layers"); // const mapboxgl =  require('mapbox-gl');


document.addEventListener('DOMContentLoaded', function () {
  var INITIAL_VIEW_STATE = {
    bearing: 0,
    latitude: 52,
    longitude: 13,
    pitch: 0,
    zoom: 4
  };
  mapboxgl.accessToken = "pk.eyJ1IjoiZm1vcm9uemlyZmFzIiwiYSI6ImNqeXBvZnl4ODE5dmkzbXFmZnNmdGx3ODIifQ.vIP1Xf2Nsso9j1LdrpMt7g"; // eslint-disable-line

  var data = window.mapData;
  console.log('The map data', data); // [{ name: 'Colma (COLM)', code: 'CM', address: '365 D Street,
  // Colma CA 94014', exits: 4214, coordinates: [-122.466233, 37.684638] }];

  var map = new mapboxgl.Map({
    bearing: INITIAL_VIEW_STATE.bearing,
    center: [INITIAL_VIEW_STATE.longitude, INITIAL_VIEW_STATE.latitude],
    container: 'map',
    interactive: false,
    pitch: INITIAL_VIEW_STATE.pitch,
    style: 'mapbox://styles/mapbox/light-v9',
    // Note: deck.gl will be in charge of interaction and event handling
    zoom: INITIAL_VIEW_STATE.zoom
  });
  var layer = new layers_1.ScatterplotLayer({
    data: data,
    filled: true,
    getFillColor: function getFillColor(_d) {
      return [255, 140, 0];
    },
    getLineColor: function getLineColor(_d) {
      return [0, 0, 0];
    },
    getPosition: function getPosition(d) {
      return [d.latitude, d.longitude];
    },
    getRadius: 100,
    id: 'scatterplot-layer',
    lineWidthMinPixels: 1,
    opacity: 0.8,
    pickable: true,
    radiusMaxPixels: 100,
    radiusMinPixels: 1,
    radiusScale: 6,
    stroked: true
  });
  var deck = new core_1.Deck({
    canvas: 'deck-canvas',
    controller: true,
    height: '100%',
    initialViewState: INITIAL_VIEW_STATE,
    layers: [layer],
    onViewStateChange: function onViewStateChange(_a) {
      var viewState = _a.viewState;
      map.jumpTo({
        bearing: viewState.bearing,
        center: [viewState.longitude, viewState.latitude],
        pitch: viewState.pitch,
        zoom: viewState.zoom
      });
    },
    width: '100%'
  });
});
},{"@deck.gl/core":"../../../node_modules/@deck.gl/core/dist/esm/index.js","@deck.gl/layers":"../../../node_modules/@deck.gl/layers/dist/esm/index.js"}],"../../../node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "55035" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../../node_modules/parcel-bundler/src/builtins/hmr-runtime.js","map.ts"], null)
//# sourceMappingURL=/assets/js/map.js.map